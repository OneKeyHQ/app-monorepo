/*! For license information please see 46709.aac20d02e6.chunk.js.LICENSE.txt */
(self.webpackChunkweb=self.webpackChunkweb||[]).push([[46709],{878918:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.s16=t.s8=t.nu64be=t.u48be=t.u40be=t.u32be=t.u24be=t.u16be=t.nu64=t.u48=t.u40=t.u32=t.u24=t.u16=t.u8=t.offset=t.greedy=t.Constant=t.UTF8=t.CString=t.Blob=t.Boolean=t.BitField=t.BitStructure=t.VariantLayout=t.Union=t.UnionLayoutDiscriminator=t.UnionDiscriminator=t.Structure=t.Sequence=t.DoubleBE=t.Double=t.FloatBE=t.Float=t.NearInt64BE=t.NearInt64=t.NearUInt64BE=t.NearUInt64=t.IntBE=t.Int=t.UIntBE=t.UInt=t.OffsetLayout=t.GreedyCount=t.ExternalLayout=t.bindConstructorLayout=t.nameWithProperty=t.Layout=t.uint8ArrayToBuffer=t.checkUint8Array=void 0,t.constant=t.utf8=t.cstr=t.blob=t.unionLayoutDiscriminator=t.union=t.seq=t.bits=t.struct=t.f64be=t.f64=t.f32be=t.f32=t.ns64be=t.s48be=t.s40be=t.s32be=t.s24be=t.s16be=t.ns64=t.s48=t.s40=t.s32=t.s24=void 0;const n=r(901048);function checkUint8Array(e){if(!(e instanceof Uint8Array))throw new TypeError("b must be a Uint8Array")}function uint8ArrayToBuffer(e){return checkUint8Array(e),n.Buffer.from(e.buffer,e.byteOffset,e.length)}t.checkUint8Array=checkUint8Array,t.uint8ArrayToBuffer=uint8ArrayToBuffer;class Layout{constructor(e,t){if(!Number.isInteger(e))throw new TypeError("span must be an integer");this.span=e,this.property=t}makeDestinationObject(){return{}}getSpan(e,t){if(0>this.span)throw new RangeError("indeterminate span");return this.span}replicate(e){const t=Object.create(this.constructor.prototype);return Object.assign(t,this),t.property=e,t}fromArray(e){}}function nameWithProperty(e,t){return t.property?e+"["+t.property+"]":e}t.Layout=Layout,t.nameWithProperty=nameWithProperty,t.bindConstructorLayout=function bindConstructorLayout(e,t){if("function"!=typeof e)throw new TypeError("Class must be constructor");if(Object.prototype.hasOwnProperty.call(e,"layout_"))throw new Error("Class is already bound to a layout");if(!(t&&t instanceof Layout))throw new TypeError("layout must be a Layout");if(Object.prototype.hasOwnProperty.call(t,"boundConstructor_"))throw new Error("layout is already bound to a constructor");e.layout_=t,t.boundConstructor_=e,t.makeDestinationObject=()=>new e,Object.defineProperty(e.prototype,"encode",{value(e,r){return t.encode(this,e,r)},writable:!0}),Object.defineProperty(e,"decode",{value:(e,r)=>t.decode(e,r),writable:!0})};class ExternalLayout extends Layout{isCount(){throw new Error("ExternalLayout is abstract")}}t.ExternalLayout=ExternalLayout;class GreedyCount extends ExternalLayout{constructor(e=1,t){if(!Number.isInteger(e)||0>=e)throw new TypeError("elementSpan must be a (positive) integer");super(-1,t),this.elementSpan=e}isCount(){return!0}decode(e,t=0){checkUint8Array(e);const r=e.length-t;return Math.floor(r/this.elementSpan)}encode(e,t,r){return 0}}t.GreedyCount=GreedyCount;class OffsetLayout extends ExternalLayout{constructor(e,t=0,r){if(!(e instanceof Layout))throw new TypeError("layout must be a Layout");if(!Number.isInteger(t))throw new TypeError("offset must be integer or undefined");super(e.span,r||e.property),this.layout=e,this.offset=t}isCount(){return this.layout instanceof UInt||this.layout instanceof UIntBE}decode(e,t=0){return this.layout.decode(e,t+this.offset)}encode(e,t,r=0){return this.layout.encode(e,t,r+this.offset)}}t.OffsetLayout=OffsetLayout;class UInt extends Layout{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t=0){return uint8ArrayToBuffer(e).readUIntLE(t,this.span)}encode(e,t,r=0){return uint8ArrayToBuffer(t).writeUIntLE(e,r,this.span),this.span}}t.UInt=UInt;class UIntBE extends Layout{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t=0){return uint8ArrayToBuffer(e).readUIntBE(t,this.span)}encode(e,t,r=0){return uint8ArrayToBuffer(t).writeUIntBE(e,r,this.span),this.span}}t.UIntBE=UIntBE;class Int extends Layout{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t=0){return uint8ArrayToBuffer(e).readIntLE(t,this.span)}encode(e,t,r=0){return uint8ArrayToBuffer(t).writeIntLE(e,r,this.span),this.span}}t.Int=Int;class IntBE extends Layout{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t=0){return uint8ArrayToBuffer(e).readIntBE(t,this.span)}encode(e,t,r=0){return uint8ArrayToBuffer(t).writeIntBE(e,r,this.span),this.span}}t.IntBE=IntBE;const s=Math.pow(2,32);function divmodInt64(e){const t=Math.floor(e/s);return{hi32:t,lo32:e-t*s}}function roundedInt64(e,t){return e*s+t}class NearUInt64 extends Layout{constructor(e){super(8,e)}decode(e,t=0){const r=uint8ArrayToBuffer(e),n=r.readUInt32LE(t);return roundedInt64(r.readUInt32LE(t+4),n)}encode(e,t,r=0){const n=divmodInt64(e),s=uint8ArrayToBuffer(t);return s.writeUInt32LE(n.lo32,r),s.writeUInt32LE(n.hi32,r+4),8}}t.NearUInt64=NearUInt64;class NearUInt64BE extends Layout{constructor(e){super(8,e)}decode(e,t=0){const r=uint8ArrayToBuffer(e);return roundedInt64(r.readUInt32BE(t),r.readUInt32BE(t+4))}encode(e,t,r=0){const n=divmodInt64(e),s=uint8ArrayToBuffer(t);return s.writeUInt32BE(n.hi32,r),s.writeUInt32BE(n.lo32,r+4),8}}t.NearUInt64BE=NearUInt64BE;class NearInt64 extends Layout{constructor(e){super(8,e)}decode(e,t=0){const r=uint8ArrayToBuffer(e),n=r.readUInt32LE(t);return roundedInt64(r.readInt32LE(t+4),n)}encode(e,t,r=0){const n=divmodInt64(e),s=uint8ArrayToBuffer(t);return s.writeUInt32LE(n.lo32,r),s.writeInt32LE(n.hi32,r+4),8}}t.NearInt64=NearInt64;class NearInt64BE extends Layout{constructor(e){super(8,e)}decode(e,t=0){const r=uint8ArrayToBuffer(e);return roundedInt64(r.readInt32BE(t),r.readUInt32BE(t+4))}encode(e,t,r=0){const n=divmodInt64(e),s=uint8ArrayToBuffer(t);return s.writeInt32BE(n.hi32,r),s.writeUInt32BE(n.lo32,r+4),8}}t.NearInt64BE=NearInt64BE;class Float extends Layout{constructor(e){super(4,e)}decode(e,t=0){return uint8ArrayToBuffer(e).readFloatLE(t)}encode(e,t,r=0){return uint8ArrayToBuffer(t).writeFloatLE(e,r),4}}t.Float=Float;class FloatBE extends Layout{constructor(e){super(4,e)}decode(e,t=0){return uint8ArrayToBuffer(e).readFloatBE(t)}encode(e,t,r=0){return uint8ArrayToBuffer(t).writeFloatBE(e,r),4}}t.FloatBE=FloatBE;class Double extends Layout{constructor(e){super(8,e)}decode(e,t=0){return uint8ArrayToBuffer(e).readDoubleLE(t)}encode(e,t,r=0){return uint8ArrayToBuffer(t).writeDoubleLE(e,r),8}}t.Double=Double;class DoubleBE extends Layout{constructor(e){super(8,e)}decode(e,t=0){return uint8ArrayToBuffer(e).readDoubleBE(t)}encode(e,t,r=0){return uint8ArrayToBuffer(t).writeDoubleBE(e,r),8}}t.DoubleBE=DoubleBE;class Sequence extends Layout{constructor(e,t,r){if(!(e instanceof Layout))throw new TypeError("elementLayout must be a Layout");if(!(t instanceof ExternalLayout&&t.isCount()||Number.isInteger(t)&&0<=t))throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");let n=-1;!(t instanceof ExternalLayout)&&0<e.span&&(n=t*e.span),super(n,r),this.elementLayout=e,this.count=t}getSpan(e,t=0){if(0<=this.span)return this.span;let r=0,n=this.count;if(n instanceof ExternalLayout&&(n=n.decode(e,t)),0<this.elementLayout.span)r=n*this.elementLayout.span;else{let s=0;for(;s<n;)r+=this.elementLayout.getSpan(e,t+r),++s}return r}decode(e,t=0){const r=[];let n=0,s=this.count;for(s instanceof ExternalLayout&&(s=s.decode(e,t));n<s;)r.push(this.elementLayout.decode(e,t)),t+=this.elementLayout.getSpan(e,t),n+=1;return r}encode(e,t,r=0){const n=this.elementLayout,s=e.reduce(((e,s)=>e+n.encode(s,t,r+e)),0);return this.count instanceof ExternalLayout&&this.count.encode(e.length,t,r),s}}t.Sequence=Sequence;class Structure extends Layout{constructor(e,t,r){if(!Array.isArray(e)||!e.reduce(((e,t)=>e&&t instanceof Layout),!0))throw new TypeError("fields must be array of Layout instances");"boolean"==typeof t&&void 0===r&&(r=t,t=void 0);for(const t of e)if(0>t.span&&void 0===t.property)throw new Error("fields cannot contain unnamed variable-length layout");let n=-1;try{n=e.reduce(((e,t)=>e+t.getSpan()),0)}catch(e){}super(n,t),this.fields=e,this.decodePrefixes=!!r}getSpan(e,t=0){if(0<=this.span)return this.span;let r=0;try{r=this.fields.reduce(((r,n)=>{const s=n.getSpan(e,t);return t+=s,r+s}),0)}catch(e){throw new RangeError("indeterminate span")}return r}decode(e,t=0){checkUint8Array(e);const r=this.makeDestinationObject();for(const n of this.fields)if(void 0!==n.property&&(r[n.property]=n.decode(e,t)),t+=n.getSpan(e,t),this.decodePrefixes&&e.length===t)break;return r}encode(e,t,r=0){const n=r;let s=0,i=0;for(const n of this.fields){let o=n.span;if(i=0<o?o:0,void 0!==n.property){const s=e[n.property];void 0!==s&&(i=n.encode(s,t,r),0>o&&(o=n.getSpan(t,r)))}s=r,r+=o}return s+i-n}fromArray(e){const t=this.makeDestinationObject();for(const r of this.fields)void 0!==r.property&&0<e.length&&(t[r.property]=e.shift());return t}layoutFor(e){if("string"!=typeof e)throw new TypeError("property must be string");for(const t of this.fields)if(t.property===e)return t}offsetOf(e){if("string"!=typeof e)throw new TypeError("property must be string");let t=0;for(const r of this.fields){if(r.property===e)return t;0>r.span?t=-1:0<=t&&(t+=r.span)}}}t.Structure=Structure;class UnionDiscriminator{constructor(e){this.property=e}decode(e,t){throw new Error("UnionDiscriminator is abstract")}encode(e,t,r){throw new Error("UnionDiscriminator is abstract")}}t.UnionDiscriminator=UnionDiscriminator;class UnionLayoutDiscriminator extends UnionDiscriminator{constructor(e,t){if(!(e instanceof ExternalLayout&&e.isCount()))throw new TypeError("layout must be an unsigned integer ExternalLayout");super(t||e.property||"variant"),this.layout=e}decode(e,t){return this.layout.decode(e,t)}encode(e,t,r){return this.layout.encode(e,t,r)}}t.UnionLayoutDiscriminator=UnionLayoutDiscriminator;class Union extends Layout{constructor(e,t,r){let n;if(e instanceof UInt||e instanceof UIntBE)n=new UnionLayoutDiscriminator(new OffsetLayout(e));else if(e instanceof ExternalLayout&&e.isCount())n=new UnionLayoutDiscriminator(e);else{if(!(e instanceof UnionDiscriminator))throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");n=e}if(void 0===t&&(t=null),!(null===t||t instanceof Layout))throw new TypeError("defaultLayout must be null or a Layout");if(null!==t){if(0>t.span)throw new Error("defaultLayout must have constant span");void 0===t.property&&(t=t.replicate("content"))}let s=-1;t&&(s=t.span,0<=s&&(e instanceof UInt||e instanceof UIntBE)&&(s+=n.layout.span)),super(s,r),this.discriminator=n,this.usesPrefixDiscriminator=e instanceof UInt||e instanceof UIntBE,this.defaultLayout=t,this.registry={};let i=this.defaultGetSourceVariant.bind(this);this.getSourceVariant=function(e){return i(e)},this.configGetSourceVariant=function(e){i=e.bind(this)}}getSpan(e,t=0){if(0<=this.span)return this.span;const r=this.getVariant(e,t);if(!r)throw new Error("unable to determine span for unrecognized variant");return r.getSpan(e,t)}defaultGetSourceVariant(e){if(Object.prototype.hasOwnProperty.call(e,this.discriminator.property)){if(this.defaultLayout&&this.defaultLayout.property&&Object.prototype.hasOwnProperty.call(e,this.defaultLayout.property))return;const t=this.registry[e[this.discriminator.property]];if(t&&(!t.layout||t.property&&Object.prototype.hasOwnProperty.call(e,t.property)))return t}else for(const t in this.registry){const r=this.registry[t];if(r.property&&Object.prototype.hasOwnProperty.call(e,r.property))return r}throw new Error("unable to infer src variant")}decode(e,t=0){let r;const n=this.discriminator,s=n.decode(e,t),i=this.registry[s];if(void 0===i){const i=this.defaultLayout;let o=0;this.usesPrefixDiscriminator&&(o=n.layout.span),r=this.makeDestinationObject(),r[n.property]=s,r[i.property]=i.decode(e,t+o)}else r=i.decode(e,t);return r}encode(e,t,r=0){const n=this.getSourceVariant(e);if(void 0===n){const n=this.discriminator,s=this.defaultLayout;let i=0;return this.usesPrefixDiscriminator&&(i=n.layout.span),n.encode(e[n.property],t,r),i+s.encode(e[s.property],t,r+i)}return n.encode(e,t,r)}addVariant(e,t,r){const n=new VariantLayout(this,e,t,r);return this.registry[e]=n,n}getVariant(e,t=0){let r;return r=e instanceof Uint8Array?this.discriminator.decode(e,t):e,this.registry[r]}}t.Union=Union;class VariantLayout extends Layout{constructor(e,t,r,n){if(!(e instanceof Union))throw new TypeError("union must be a Union");if(!Number.isInteger(t)||0>t)throw new TypeError("variant must be a (non-negative) integer");if("string"==typeof r&&void 0===n&&(n=r,r=null),r){if(!(r instanceof Layout))throw new TypeError("layout must be a Layout");if(null!==e.defaultLayout&&0<=r.span&&r.span>e.defaultLayout.span)throw new Error("variant span exceeds span of containing union");if("string"!=typeof n)throw new TypeError("variant must have a String property")}let s=e.span;0>e.span&&(s=r?r.span:0,0<=s&&e.usesPrefixDiscriminator&&(s+=e.discriminator.layout.span)),super(s,n),this.union=e,this.variant=t,this.layout=r||null}getSpan(e,t=0){if(0<=this.span)return this.span;let r=0;this.union.usesPrefixDiscriminator&&(r=this.union.discriminator.layout.span);let n=0;return this.layout&&(n=this.layout.getSpan(e,t+r)),r+n}decode(e,t=0){const r=this.makeDestinationObject();if(this!==this.union.getVariant(e,t))throw new Error("variant mismatch");let n=0;return this.union.usesPrefixDiscriminator&&(n=this.union.discriminator.layout.span),this.layout?r[this.property]=this.layout.decode(e,t+n):this.property?r[this.property]=!0:this.union.usesPrefixDiscriminator&&(r[this.union.discriminator.property]=this.variant),r}encode(e,t,r=0){let n=0;if(this.union.usesPrefixDiscriminator&&(n=this.union.discriminator.layout.span),this.layout&&!Object.prototype.hasOwnProperty.call(e,this.property))throw new TypeError("variant lacks property "+this.property);this.union.discriminator.encode(this.variant,t,r);let s=n;if(this.layout&&(this.layout.encode(e[this.property],t,r+n),s+=this.layout.getSpan(t,r+n),0<=this.union.span&&s>this.union.span))throw new Error("encoded variant overruns containing union");return s}fromArray(e){if(this.layout)return this.layout.fromArray(e)}}function fixBitwiseResult(e){return 0>e&&(e+=4294967296),e}t.VariantLayout=VariantLayout;class BitStructure extends Layout{constructor(e,t,r){if(!(e instanceof UInt||e instanceof UIntBE))throw new TypeError("word must be a UInt or UIntBE layout");if("string"==typeof t&&void 0===r&&(r=t,t=!1),4<e.span)throw new RangeError("word cannot exceed 32 bits");super(e.span,r),this.word=e,this.msb=!!t,this.fields=[];let n=0;this._packedSetValue=function(e){return n=fixBitwiseResult(e),this},this._packedGetValue=function(){return n}}decode(e,t=0){const r=this.makeDestinationObject(),n=this.word.decode(e,t);this._packedSetValue(n);for(const t of this.fields)void 0!==t.property&&(r[t.property]=t.decode(e));return r}encode(e,t,r=0){const n=this.word.decode(t,r);this._packedSetValue(n);for(const t of this.fields)if(void 0!==t.property){const r=e[t.property];void 0!==r&&t.encode(r)}return this.word.encode(this._packedGetValue(),t,r)}addField(e,t){const r=new BitField(this,e,t);return this.fields.push(r),r}addBoolean(e){const t=new Boolean(this,e);return this.fields.push(t),t}fieldFor(e){if("string"!=typeof e)throw new TypeError("property must be string");for(const t of this.fields)if(t.property===e)return t}}t.BitStructure=BitStructure;class BitField{constructor(e,t,r){if(!(e instanceof BitStructure))throw new TypeError("container must be a BitStructure");if(!Number.isInteger(t)||0>=t)throw new TypeError("bits must be positive integer");const n=8*e.span,s=e.fields.reduce(((e,t)=>e+t.bits),0);if(t+s>n)throw new Error("bits too long for span remainder ("+(n-s)+" of "+n+" remain)");this.container=e,this.bits=t,this.valueMask=(1<<t)-1,32===t&&(this.valueMask=4294967295),this.start=s,this.container.msb&&(this.start=n-s-t),this.wordMask=fixBitwiseResult(this.valueMask<<this.start),this.property=r}decode(e,t){return fixBitwiseResult(this.container._packedGetValue()&this.wordMask)>>>this.start}encode(e){if("number"!=typeof e||!Number.isInteger(e)||e!==fixBitwiseResult(e&this.valueMask))throw new TypeError(nameWithProperty("BitField.encode",this)+" value must be integer not exceeding "+this.valueMask);const t=this.container._packedGetValue(),r=fixBitwiseResult(e<<this.start);this.container._packedSetValue(fixBitwiseResult(t&~this.wordMask)|r)}}t.BitField=BitField;class Boolean extends BitField{constructor(e,t){super(e,1,t)}decode(e,t){return!!super.decode(e,t)}encode(e){"boolean"==typeof e&&(e=+e),super.encode(e)}}t.Boolean=Boolean;class Blob extends Layout{constructor(e,t){if(!(e instanceof ExternalLayout&&e.isCount()||Number.isInteger(e)&&0<=e))throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");let r=-1;e instanceof ExternalLayout||(r=e),super(r,t),this.length=e}getSpan(e,t){let r=this.span;return 0>r&&(r=this.length.decode(e,t)),r}decode(e,t=0){let r=this.span;return 0>r&&(r=this.length.decode(e,t)),uint8ArrayToBuffer(e).slice(t,t+r)}encode(e,t,r){let n=this.length;if(this.length instanceof ExternalLayout&&(n=e.length),!(e instanceof Uint8Array&&n===e.length))throw new TypeError(nameWithProperty("Blob.encode",this)+" requires (length "+n+") Uint8Array as src");if(r+n>t.length)throw new RangeError("encoding overruns Uint8Array");const s=uint8ArrayToBuffer(e);return uint8ArrayToBuffer(t).write(s.toString("hex"),r,n,"hex"),this.length instanceof ExternalLayout&&this.length.encode(n,t,r),n}}t.Blob=Blob;class CString extends Layout{constructor(e){super(-1,e)}getSpan(e,t=0){checkUint8Array(e);let r=t;for(;r<e.length&&0!==e[r];)r+=1;return 1+r-t}decode(e,t=0){const r=this.getSpan(e,t);return uint8ArrayToBuffer(e).slice(t,t+r-1).toString("utf-8")}encode(e,t,r=0){"string"!=typeof e&&(e=String(e));const s=n.Buffer.from(e,"utf8"),i=s.length;if(r+i>t.length)throw new RangeError("encoding overruns Buffer");const o=uint8ArrayToBuffer(t);return s.copy(o,r),o[r+i]=0,i+1}}t.CString=CString;class UTF8 extends Layout{constructor(e,t){if("string"==typeof e&&void 0===t&&(t=e,e=void 0),void 0===e)e=-1;else if(!Number.isInteger(e))throw new TypeError("maxSpan must be an integer");super(-1,t),this.maxSpan=e}getSpan(e,t=0){return checkUint8Array(e),e.length-t}decode(e,t=0){const r=this.getSpan(e,t);if(0<=this.maxSpan&&this.maxSpan<r)throw new RangeError("text length exceeds maxSpan");return uint8ArrayToBuffer(e).slice(t,t+r).toString("utf-8")}encode(e,t,r=0){"string"!=typeof e&&(e=String(e));const s=n.Buffer.from(e,"utf8"),i=s.length;if(0<=this.maxSpan&&this.maxSpan<i)throw new RangeError("text length exceeds maxSpan");if(r+i>t.length)throw new RangeError("encoding overruns Buffer");return s.copy(uint8ArrayToBuffer(t),r),i}}t.UTF8=UTF8;class Constant extends Layout{constructor(e,t){super(0,t),this.value=e}decode(e,t){return this.value}encode(e,t,r){return 0}}t.Constant=Constant,t.greedy=(e,t)=>new GreedyCount(e,t),t.offset=(e,t,r)=>new OffsetLayout(e,t,r),t.u8=e=>new UInt(1,e),t.u16=e=>new UInt(2,e),t.u24=e=>new UInt(3,e),t.u32=e=>new UInt(4,e),t.u40=e=>new UInt(5,e),t.u48=e=>new UInt(6,e),t.nu64=e=>new NearUInt64(e),t.u16be=e=>new UIntBE(2,e),t.u24be=e=>new UIntBE(3,e),t.u32be=e=>new UIntBE(4,e),t.u40be=e=>new UIntBE(5,e),t.u48be=e=>new UIntBE(6,e),t.nu64be=e=>new NearUInt64BE(e),t.s8=e=>new Int(1,e),t.s16=e=>new Int(2,e),t.s24=e=>new Int(3,e),t.s32=e=>new Int(4,e),t.s40=e=>new Int(5,e),t.s48=e=>new Int(6,e),t.ns64=e=>new NearInt64(e),t.s16be=e=>new IntBE(2,e),t.s24be=e=>new IntBE(3,e),t.s32be=e=>new IntBE(4,e),t.s40be=e=>new IntBE(5,e),t.s48be=e=>new IntBE(6,e),t.ns64be=e=>new NearInt64BE(e),t.f32=e=>new Float(e),t.f32be=e=>new FloatBE(e),t.f64=e=>new Double(e),t.f64be=e=>new DoubleBE(e),t.struct=(e,t,r)=>new Structure(e,t,r),t.bits=(e,t,r)=>new BitStructure(e,t,r),t.seq=(e,t,r)=>new Sequence(e,t,r),t.union=(e,t,r)=>new Union(e,t,r),t.unionLayoutDiscriminator=(e,t)=>new UnionLayoutDiscriminator(e,t),t.blob=(e,t)=>new Blob(e,t),t.cstr=e=>new CString(e),t.utf8=(e,t)=>new UTF8(e,t),t.constant=(e,t)=>new Constant(e,t)},398532:(e,t,r)=>{"use strict";r.d(t,{kc:()=>AddressLookupTableAccount,$v:()=>ComputeBudgetInstruction,d_:()=>ComputeBudgetProgram,J3:()=>PublicKey,Ur:()=>Ne,Sq:()=>SystemInstruction,yq:()=>SystemProgram,ZX:()=>Transaction,fH:()=>TransactionInstruction,wu:()=>TransactionMessage,Kt:()=>VersionedTransaction});var n={};r.r(n),r.d(n,{DO:()=>utils_abytes,OG:()=>bitMask,My:()=>abstract_utils_bytesToHex,bytesToNumberBE:()=>utils_bytesToNumberBE,lX:()=>utils_bytesToNumberLE,Id:()=>abstract_utils_concatBytes,fg:()=>createHmacDrbg,qj:()=>utils_ensureBytes,hexToBytes:()=>utils_hexToBytes,aY:()=>abstract_utils_isBytes,lq:()=>utils_numberToBytesBE,z:()=>utils_numberToBytesLE,Q5:()=>validateObject});var s=r(901048);function _assert_number(e){if(!Number.isSafeInteger(e)||e<0)throw new Error(`positive integer expected, not ${e}`)}function bytes(e,...t){if(!function isBytes(e){return e instanceof Uint8Array||null!=e&&"object"==typeof e&&"Uint8Array"===e.constructor.name}(e))throw new Error("Uint8Array expected");if(t.length>0&&!t.includes(e.length))throw new Error(`Uint8Array expected of length ${t}, not of length=${e.length}`)}function _assert_hash(e){if("function"!=typeof e||"function"!=typeof e.create)throw new Error("Hash should be wrapped by utils.wrapConstructor");_assert_number(e.outputLen),_assert_number(e.blockLen)}function exists(e,t=!0){if(e.destroyed)throw new Error("Hash instance has been destroyed");if(t&&e.finished)throw new Error("Hash#digest() has already been called")}function output(e,t){bytes(e);const r=t.outputLen;if(e.length<r)throw new Error(`digestInto() expects output buffer of length at least ${r}`)}const i="object"==typeof globalThis&&"crypto"in globalThis?globalThis.crypto:void 0;const createView=e=>new DataView(e.buffer,e.byteOffset,e.byteLength),rotr=(e,t)=>e<<32-t|e>>>t;new Uint8Array(new Uint32Array([287454020]).buffer)[0];function utils_utf8ToBytes(e){if("string"!=typeof e)throw new Error("utf8ToBytes expected string, got "+typeof e);return new Uint8Array((new TextEncoder).encode(e))}function toBytes(e){return"string"==typeof e&&(e=utils_utf8ToBytes(e)),bytes(e),e}function utils_concatBytes(...e){let t=0;for(let r=0;r<e.length;r++){const n=e[r];bytes(n),t+=n.length}const r=new Uint8Array(t);for(let t=0,n=0;t<e.length;t++){const s=e[t];r.set(s,n),n+=s.length}return r}class Hash{clone(){return this._cloneInto()}}function utils_wrapConstructor(e){const hashC=t=>e().update(toBytes(t)).digest(),t=e();return hashC.outputLen=t.outputLen,hashC.blockLen=t.blockLen,hashC.create=()=>e(),hashC}function utils_randomBytes(e=32){if(i&&"function"==typeof i.getRandomValues)return i.getRandomValues(new Uint8Array(e));throw new Error("crypto.getRandomValues must be defined")}const Maj=(e,t,r)=>e&t^e&r^t&r;class HashMD extends Hash{constructor(e,t,r,n){super(),this.blockLen=e,this.outputLen=t,this.padOffset=r,this.isLE=n,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=createView(this.buffer)}update(e){exists(this);const{view:t,buffer:r,blockLen:n}=this,s=(e=toBytes(e)).length;for(let i=0;i<s;){const o=Math.min(n-this.pos,s-i);if(o!==n)r.set(e.subarray(i,i+o),this.pos),this.pos+=o,i+=o,this.pos===n&&(this.process(t,0),this.pos=0);else{const t=createView(e);for(;n<=s-i;i+=n)this.process(t,i)}}return this.length+=e.length,this.roundClean(),this}digestInto(e){exists(this),output(e,this),this.finished=!0;const{buffer:t,view:r,blockLen:n,isLE:s}=this;let{pos:i}=this;t[i++]=128,this.buffer.subarray(i).fill(0),this.padOffset>n-i&&(this.process(r,0),i=0);for(let e=i;e<n;e++)t[e]=0;!function setBigUint64(e,t,r,n){if("function"==typeof e.setBigUint64)return e.setBigUint64(t,r,n);const s=BigInt(32),i=BigInt(4294967295),o=Number(r>>s&i),a=Number(r&i),u=n?4:0,c=n?0:4;e.setUint32(t+u,o,n),e.setUint32(t+c,a,n)}(r,n-8,BigInt(8*this.length),s),this.process(r,0);const o=createView(e),a=this.outputLen;if(a%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const u=a/4,c=this.get();if(u>c.length)throw new Error("_sha2: outputLen bigger than state");for(let e=0;e<u;e++)o.setUint32(4*e,c[e],s)}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const r=e.slice(0,t);return this.destroy(),r}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:t,buffer:r,length:n,finished:s,destroyed:i,pos:o}=this;return e.length=n,e.pos=o,e.finished=s,e.destroyed=i,n%t&&e.buffer.set(r),e}}const o=BigInt(2**32-1),a=BigInt(32);function fromBig(e,t=!1){return t?{h:Number(e&o),l:Number(e>>a&o)}:{h:0|Number(e>>a&o),l:0|Number(e&o)}}const u={fromBig,split:function split(e,t=!1){let r=new Uint32Array(e.length),n=new Uint32Array(e.length);for(let s=0;s<e.length;s++){const{h:i,l:o}=fromBig(e[s],t);[r[s],n[s]]=[i,o]}return[r,n]},toBig:(e,t)=>BigInt(e>>>0)<<a|BigInt(t>>>0),shrSH:(e,t,r)=>e>>>r,shrSL:(e,t,r)=>e<<32-r|t>>>r,rotrSH:(e,t,r)=>e>>>r|t<<32-r,rotrSL:(e,t,r)=>e<<32-r|t>>>r,rotrBH:(e,t,r)=>e<<64-r|t>>>r-32,rotrBL:(e,t,r)=>e>>>r-32|t<<64-r,rotr32H:(e,t)=>t,rotr32L:(e,t)=>e,rotlSH:(e,t,r)=>e<<r|t>>>32-r,rotlSL:(e,t,r)=>t<<r|e>>>32-r,rotlBH:(e,t,r)=>t<<r-32|e>>>64-r,rotlBL:(e,t,r)=>e<<r-32|t>>>64-r,add:function add(e,t,r,n){const s=(t>>>0)+(n>>>0);return{h:e+r+(s/2**32|0)|0,l:0|s}},add3L:(e,t,r)=>(e>>>0)+(t>>>0)+(r>>>0),add3H:(e,t,r,n)=>t+r+n+(e/2**32|0)|0,add4L:(e,t,r,n)=>(e>>>0)+(t>>>0)+(r>>>0)+(n>>>0),add4H:(e,t,r,n,s)=>t+r+n+s+(e/2**32|0)|0,add5H:(e,t,r,n,s,i)=>t+r+n+s+i+(e/2**32|0)|0,add5L:(e,t,r,n,s)=>(e>>>0)+(t>>>0)+(r>>>0)+(n>>>0)+(s>>>0)},[c,d]=(()=>u.split(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map((e=>BigInt(e)))))(),l=new Uint32Array(80),f=new Uint32Array(80);class SHA512 extends HashMD{constructor(){super(128,64,16,!1),this.Ah=1779033703,this.Al=-205731576,this.Bh=-1150833019,this.Bl=-2067093701,this.Ch=1013904242,this.Cl=-23791573,this.Dh=-1521486534,this.Dl=1595750129,this.Eh=1359893119,this.El=-1377402159,this.Fh=-1694144372,this.Fl=725511199,this.Gh=528734635,this.Gl=-79577749,this.Hh=1541459225,this.Hl=327033209}get(){const{Ah:e,Al:t,Bh:r,Bl:n,Ch:s,Cl:i,Dh:o,Dl:a,Eh:u,El:c,Fh:d,Fl:l,Gh:f,Gl:y,Hh:p,Hl:g}=this;return[e,t,r,n,s,i,o,a,u,c,d,l,f,y,p,g]}set(e,t,r,n,s,i,o,a,u,c,d,l,f,y,p,g){this.Ah=0|e,this.Al=0|t,this.Bh=0|r,this.Bl=0|n,this.Ch=0|s,this.Cl=0|i,this.Dh=0|o,this.Dl=0|a,this.Eh=0|u,this.El=0|c,this.Fh=0|d,this.Fl=0|l,this.Gh=0|f,this.Gl=0|y,this.Hh=0|p,this.Hl=0|g}process(e,t){for(let r=0;r<16;r++,t+=4)l[r]=e.getUint32(t),f[r]=e.getUint32(t+=4);for(let e=16;e<80;e++){const t=0|l[e-15],r=0|f[e-15],n=u.rotrSH(t,r,1)^u.rotrSH(t,r,8)^u.shrSH(t,r,7),s=u.rotrSL(t,r,1)^u.rotrSL(t,r,8)^u.shrSL(t,r,7),i=0|l[e-2],o=0|f[e-2],a=u.rotrSH(i,o,19)^u.rotrBH(i,o,61)^u.shrSH(i,o,6),c=u.rotrSL(i,o,19)^u.rotrBL(i,o,61)^u.shrSL(i,o,6),d=u.add4L(s,c,f[e-7],f[e-16]),y=u.add4H(d,n,a,l[e-7],l[e-16]);l[e]=0|y,f[e]=0|d}let{Ah:r,Al:n,Bh:s,Bl:i,Ch:o,Cl:a,Dh:y,Dl:p,Eh:g,El:b,Fh:m,Fl:w,Gh:k,Gl:I,Hh:B,Hl:S}=this;for(let e=0;e<80;e++){const t=u.rotrSH(g,b,14)^u.rotrSH(g,b,18)^u.rotrBH(g,b,41),x=u.rotrSL(g,b,14)^u.rotrSL(g,b,18)^u.rotrBL(g,b,41),E=g&m^~g&k,v=b&w^~b&I,P=u.add5L(S,x,v,d[e],f[e]),A=u.add5H(P,B,t,E,c[e],l[e]),L=0|P,T=u.rotrSH(r,n,28)^u.rotrBH(r,n,34)^u.rotrBH(r,n,39),_=u.rotrSL(r,n,28)^u.rotrBL(r,n,34)^u.rotrBL(r,n,39),K=r&s^r&o^s&o,N=n&i^n&a^i&a;B=0|k,S=0|I,k=0|m,I=0|w,m=0|g,w=0|b,({h:g,l:b}=u.add(0|y,0|p,0|A,0|L)),y=0|o,p=0|a,o=0|s,a=0|i,s=0|r,i=0|n;const W=u.add3L(L,_,N);r=u.add3H(W,A,T,K),n=0|W}({h:r,l:n}=u.add(0|this.Ah,0|this.Al,0|r,0|n)),({h:s,l:i}=u.add(0|this.Bh,0|this.Bl,0|s,0|i)),({h:o,l:a}=u.add(0|this.Ch,0|this.Cl,0|o,0|a)),({h:y,l:p}=u.add(0|this.Dh,0|this.Dl,0|y,0|p)),({h:g,l:b}=u.add(0|this.Eh,0|this.El,0|g,0|b)),({h:m,l:w}=u.add(0|this.Fh,0|this.Fl,0|m,0|w)),({h:k,l:I}=u.add(0|this.Gh,0|this.Gl,0|k,0|I)),({h:B,l:S}=u.add(0|this.Hh,0|this.Hl,0|B,0|S)),this.set(r,n,s,i,o,a,y,p,g,b,m,w,k,I,B,S)}roundClean(){l.fill(0),f.fill(0)}destroy(){this.buffer.fill(0),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}const y=utils_wrapConstructor((()=>new SHA512)),p=(BigInt(0),BigInt(1)),g=BigInt(2);function abstract_utils_isBytes(e){return e instanceof Uint8Array||null!=e&&"object"==typeof e&&"Uint8Array"===e.constructor.name}function utils_abytes(e){if(!abstract_utils_isBytes(e))throw new Error("Uint8Array expected")}const b=Array.from({length:256},((e,t)=>t.toString(16).padStart(2,"0")));function abstract_utils_bytesToHex(e){utils_abytes(e);let t="";for(let r=0;r<e.length;r++)t+=b[e[r]];return t}function hexToNumber(e){if("string"!=typeof e)throw new Error("hex string expected, got "+typeof e);return BigInt(""===e?"0":`0x${e}`)}const m={_0:48,_9:57,_A:65,_F:70,_a:97,_f:102};function utils_asciiToBase16(e){return e>=m._0&&e<=m._9?e-m._0:e>=m._A&&e<=m._F?e-(m._A-10):e>=m._a&&e<=m._f?e-(m._a-10):void 0}function utils_hexToBytes(e){if("string"!=typeof e)throw new Error("hex string expected, got "+typeof e);const t=e.length,r=t/2;if(t%2)throw new Error("padded hex string expected, got unpadded hex of length "+t);const n=new Uint8Array(r);for(let t=0,s=0;t<r;t++,s+=2){const r=utils_asciiToBase16(e.charCodeAt(s)),i=utils_asciiToBase16(e.charCodeAt(s+1));if(void 0===r||void 0===i){const t=e[s]+e[s+1];throw new Error('hex string expected, got non-hex character "'+t+'" at index '+s)}n[t]=16*r+i}return n}function utils_bytesToNumberBE(e){return hexToNumber(abstract_utils_bytesToHex(e))}function utils_bytesToNumberLE(e){return utils_abytes(e),hexToNumber(abstract_utils_bytesToHex(Uint8Array.from(e).reverse()))}function utils_numberToBytesBE(e,t){return utils_hexToBytes(e.toString(16).padStart(2*t,"0"))}function utils_numberToBytesLE(e,t){return utils_numberToBytesBE(e,t).reverse()}function utils_ensureBytes(e,t,r){let n;if("string"==typeof t)try{n=utils_hexToBytes(t)}catch(r){throw new Error(`${e} must be valid hex string, got "${t}". Cause: ${r}`)}else{if(!abstract_utils_isBytes(t))throw new Error(`${e} must be hex string or Uint8Array`);n=Uint8Array.from(t)}const s=n.length;if("number"==typeof r&&s!==r)throw new Error(`${e} expected ${r} bytes, got ${s}`);return n}function abstract_utils_concatBytes(...e){let t=0;for(let r=0;r<e.length;r++){const n=e[r];utils_abytes(n),t+=n.length}const r=new Uint8Array(t);for(let t=0,n=0;t<e.length;t++){const s=e[t];r.set(s,n),n+=s.length}return r}const bitMask=e=>(g<<BigInt(e-1))-p,u8n=e=>new Uint8Array(e),u8fr=e=>Uint8Array.from(e);function createHmacDrbg(e,t,r){if("number"!=typeof e||e<2)throw new Error("hashLen must be a number");if("number"!=typeof t||t<2)throw new Error("qByteLen must be a number");if("function"!=typeof r)throw new Error("hmacFn must be a function");let n=u8n(e),s=u8n(e),i=0;const reset=()=>{n.fill(1),s.fill(0),i=0},h=(...e)=>r(s,n,...e),reseed=(e=u8n())=>{s=h(u8fr([0]),e),n=h(),0!==e.length&&(s=h(u8fr([1]),e),n=h())},gen=()=>{if(i++>=1e3)throw new Error("drbg: tried 1000 values");let e=0;const r=[];for(;e<t;){n=h();const t=n.slice();r.push(t),e+=n.length}return abstract_utils_concatBytes(...r)};return(e,t)=>{let r;for(reset(),reseed(e);!(r=t(gen()));)reseed();return reset(),r}}const w={bigint:e=>"bigint"==typeof e,function:e=>"function"==typeof e,boolean:e=>"boolean"==typeof e,string:e=>"string"==typeof e,stringOrUint8Array:e=>"string"==typeof e||abstract_utils_isBytes(e),isSafeInteger:e=>Number.isSafeInteger(e),array:e=>Array.isArray(e),field:(e,t)=>t.Fp.isValid(e),hash:e=>"function"==typeof e&&Number.isSafeInteger(e.outputLen)};function validateObject(e,t,r={}){const checkField=(t,r,n)=>{const s=w[r];if("function"!=typeof s)throw new Error(`Invalid validator "${r}", expected function`);const i=e[t];if(!(n&&void 0===i||s(i,e)))throw new Error(`Invalid param ${String(t)}=${i} (${typeof i}), expected ${r}`)};for(const[e,r]of Object.entries(t))checkField(e,r,!1);for(const[e,t]of Object.entries(r))checkField(e,t,!0);return e}const k=BigInt(0),I=BigInt(1),B=BigInt(2),S=BigInt(3),x=BigInt(4),E=BigInt(5),v=BigInt(8);BigInt(9),BigInt(16);function modular_mod(e,t){const r=e%t;return r>=k?r:t+r}function pow(e,t,r){if(r<=k||t<k)throw new Error("Expected power/modulo > 0");if(r===I)return k;let n=I;for(;t>k;)t&I&&(n=n*e%r),e=e*e%r,t>>=I;return n}function modular_pow2(e,t,r){let n=e;for(;t-- >k;)n*=n,n%=r;return n}function invert(e,t){if(e===k||t<=k)throw new Error(`invert: expected positive integers, got n=${e} mod=${t}`);let r=modular_mod(e,t),n=t,s=k,i=I,o=I,a=k;for(;r!==k;){const e=n/r,t=n%r,u=s-o*e,c=i-a*e;n=r,r=t,s=o,i=a,o=u,a=c}if(n!==I)throw new Error("invert: does not exist");return modular_mod(s,t)}function FpSqrt(e){if(e%x===S){const t=(e+I)/x;return function sqrt3mod4(e,r){const n=e.pow(r,t);if(!e.eql(e.sqr(n),r))throw new Error("Cannot find square root");return n}}if(e%v===E){const t=(e-E)/v;return function sqrt5mod8(e,r){const n=e.mul(r,B),s=e.pow(n,t),i=e.mul(r,s),o=e.mul(e.mul(i,B),s),a=e.mul(i,e.sub(o,e.ONE));if(!e.eql(e.sqr(a),r))throw new Error("Cannot find square root");return a}}return function tonelliShanks(e){const t=(e-I)/B;let r,n,s;for(r=e-I,n=0;r%B===k;r/=B,n++);for(s=B;s<e&&pow(s,t,e)!==e-I;s++);if(1===n){const t=(e+I)/x;return function tonelliFast(e,r){const n=e.pow(r,t);if(!e.eql(e.sqr(n),r))throw new Error("Cannot find square root");return n}}const i=(r+I)/B;return function tonelliSlow(e,o){if(e.pow(o,t)===e.neg(e.ONE))throw new Error("Cannot find square root");let a=n,u=e.pow(e.mul(e.ONE,s),r),c=e.pow(o,i),d=e.pow(o,r);for(;!e.eql(d,e.ONE);){if(e.eql(d,e.ZERO))return e.ZERO;let t=1;for(let r=e.sqr(d);t<a&&!e.eql(r,e.ONE);t++)r=e.sqr(r);const r=e.pow(u,I<<BigInt(a-t-1));u=e.sqr(r),c=e.mul(c,r),d=e.mul(d,u),a=t}return c}}(e)}const modular_isNegativeLE=(e,t)=>(modular_mod(e,t)&I)===I,P=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function nLength(e,t){const r=void 0!==t?t:e.toString(2).length;return{nBitLength:r,nByteLength:Math.ceil(r/8)}}function Field(e,t,r=!1,n={}){if(e<=k)throw new Error(`Expected Field ORDER > 0, got ${e}`);const{nBitLength:s,nByteLength:i}=nLength(e,t);if(i>2048)throw new Error("Field lengths over 2048 bytes are not supported");const o=FpSqrt(e),a=Object.freeze({ORDER:e,BITS:s,BYTES:i,MASK:bitMask(s),ZERO:k,ONE:I,create:t=>modular_mod(t,e),isValid:t=>{if("bigint"!=typeof t)throw new Error("Invalid field element: expected bigint, got "+typeof t);return k<=t&&t<e},is0:e=>e===k,isOdd:e=>(e&I)===I,neg:t=>modular_mod(-t,e),eql:(e,t)=>e===t,sqr:t=>modular_mod(t*t,e),add:(t,r)=>modular_mod(t+r,e),sub:(t,r)=>modular_mod(t-r,e),mul:(t,r)=>modular_mod(t*r,e),pow:(e,t)=>function FpPow(e,t,r){if(r<k)throw new Error("Expected power > 0");if(r===k)return e.ONE;if(r===I)return t;let n=e.ONE,s=t;for(;r>k;)r&I&&(n=e.mul(n,s)),s=e.sqr(s),r>>=I;return n}(a,e,t),div:(t,r)=>modular_mod(t*invert(r,e),e),sqrN:e=>e*e,addN:(e,t)=>e+t,subN:(e,t)=>e-t,mulN:(e,t)=>e*t,inv:t=>invert(t,e),sqrt:n.sqrt||(e=>o(a,e)),invertBatch:e=>function FpInvertBatch(e,t){const r=new Array(t.length),n=t.reduce(((t,n,s)=>e.is0(n)?t:(r[s]=t,e.mul(t,n))),e.ONE),s=e.inv(n);return t.reduceRight(((t,n,s)=>e.is0(n)?t:(r[s]=e.mul(t,r[s]),e.mul(t,n))),s),r}(a,e),cmov:(e,t,r)=>r?t:e,toBytes:e=>r?utils_numberToBytesLE(e,i):utils_numberToBytesBE(e,i),fromBytes:e=>{if(e.length!==i)throw new Error(`Fp.fromBytes: expected ${i}, got ${e.length}`);return r?utils_bytesToNumberLE(e):utils_bytesToNumberBE(e)}});return Object.freeze(a)}function getFieldBytesLength(e){if("bigint"!=typeof e)throw new Error("field order must be bigint");const t=e.toString(2).length;return Math.ceil(t/8)}function getMinHashLength(e){const t=getFieldBytesLength(e);return t+Math.ceil(t/2)}const A=BigInt(0),L=BigInt(1);function wNAF(e,t){const constTimeNegate=(e,t)=>{const r=t.negate();return e?r:t},opts=e=>({windows:Math.ceil(t/e)+1,windowSize:2**(e-1)});return{constTimeNegate,unsafeLadder(t,r){let n=e.ZERO,s=t;for(;r>A;)r&L&&(n=n.add(s)),s=s.double(),r>>=L;return n},precomputeWindow(e,t){const{windows:r,windowSize:n}=opts(t),s=[];let i=e,o=i;for(let e=0;e<r;e++){o=i,s.push(o);for(let e=1;e<n;e++)o=o.add(i),s.push(o);i=o.double()}return s},wNAF(t,r,n){const{windows:s,windowSize:i}=opts(t);let o=e.ZERO,a=e.BASE;const u=BigInt(2**t-1),c=2**t,d=BigInt(t);for(let e=0;e<s;e++){const t=e*i;let s=Number(n&u);n>>=d,s>i&&(s-=c,n+=L);const l=t,f=t+Math.abs(s)-1,y=e%2!=0,p=s<0;0===s?a=a.add(constTimeNegate(y,r[l])):o=o.add(constTimeNegate(p,r[f]))}return{p:o,f:a}},wNAFCached(e,t,r,n){const s=e._WINDOW_SIZE||1;let i=t.get(e);return i||(i=this.precomputeWindow(e,s),1!==s&&t.set(e,n(i))),this.wNAF(s,i,r)}}}function validateBasic(e){return function validateField(e){return validateObject(e,P.reduce(((e,t)=>(e[t]="function",e)),{ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"}))}(e.Fp),validateObject(e,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...nLength(e.n,e.nBitLength),...e,p:e.Fp.ORDER})}const T=BigInt(0),_=BigInt(1),K=BigInt(2),N=BigInt(8),W={zip215:!0};function twistedEdwards(e){const t=function validateOpts(e){const t=validateBasic(e);return validateObject(e,{hash:"function",a:"bigint",d:"bigint",randomBytes:"function"},{adjustScalarBytes:"function",domain:"function",uvRatio:"function",mapToCurve:"function"}),Object.freeze({...t})}(e),{Fp:r,n,prehash:s,hash:i,randomBytes:o,nByteLength:a,h:u}=t,c=K<<BigInt(8*a)-_,d=r.create,l=t.uvRatio||((e,t)=>{try{return{isValid:!0,value:r.sqrt(e*r.inv(t))}}catch(e){return{isValid:!1,value:T}}}),f=t.adjustScalarBytes||(e=>e),y=t.domain||((e,t,r)=>{if(t.length||r)throw new Error("Contexts/pre-hash are not supported");return e}),inBig=e=>"bigint"==typeof e&&T<e,inRange=(e,t)=>inBig(e)&&inBig(t)&&e<t,in0MaskRange=e=>e===T||inRange(e,c);function assertInRange(e,t){if(inRange(e,t))return e;throw new Error(`Expected valid scalar < ${t}, got ${typeof e} ${e}`)}function assertGE0(e){return e===T?e:assertInRange(e,n)}const p=new Map;function isPoint(e){if(!(e instanceof Point))throw new Error("ExtendedPoint expected")}class Point{constructor(e,t,r,n){if(this.ex=e,this.ey=t,this.ez=r,this.et=n,!in0MaskRange(e))throw new Error("x required");if(!in0MaskRange(t))throw new Error("y required");if(!in0MaskRange(r))throw new Error("z required");if(!in0MaskRange(n))throw new Error("t required")}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static fromAffine(e){if(e instanceof Point)throw new Error("extended point not allowed");const{x:t,y:r}=e||{};if(!in0MaskRange(t)||!in0MaskRange(r))throw new Error("invalid affine point");return new Point(t,r,_,d(t*r))}static normalizeZ(e){const t=r.invertBatch(e.map((e=>e.ez)));return e.map(((e,r)=>e.toAffine(t[r]))).map(Point.fromAffine)}_setWindowSize(e){this._WINDOW_SIZE=e,p.delete(this)}assertValidity(){const{a:e,d:r}=t;if(this.is0())throw new Error("bad point: ZERO");const{ex:n,ey:s,ez:i,et:o}=this,a=d(n*n),u=d(s*s),c=d(i*i),l=d(c*c),f=d(a*e);if(d(c*d(f+u))!==d(l+d(r*d(a*u))))throw new Error("bad point: equation left != right (1)");if(d(n*s)!==d(i*o))throw new Error("bad point: equation left != right (2)")}equals(e){isPoint(e);const{ex:t,ey:r,ez:n}=this,{ex:s,ey:i,ez:o}=e,a=d(t*o),u=d(s*n),c=d(r*o),l=d(i*n);return a===u&&c===l}is0(){return this.equals(Point.ZERO)}negate(){return new Point(d(-this.ex),this.ey,this.ez,d(-this.et))}double(){const{a:e}=t,{ex:r,ey:n,ez:s}=this,i=d(r*r),o=d(n*n),a=d(K*d(s*s)),u=d(e*i),c=r+n,l=d(d(c*c)-i-o),f=u+o,y=f-a,p=u-o,g=d(l*y),b=d(f*p),m=d(l*p),w=d(y*f);return new Point(g,b,w,m)}add(e){isPoint(e);const{a:r,d:n}=t,{ex:s,ey:i,ez:o,et:a}=this,{ex:u,ey:c,ez:l,et:f}=e;if(r===BigInt(-1)){const e=d((i-s)*(c+u)),t=d((i+s)*(c-u)),r=d(t-e);if(r===T)return this.double();const n=d(o*K*f),y=d(a*K*l),p=y+n,g=t+e,b=y-n,m=d(p*r),w=d(g*b),k=d(p*b),I=d(r*g);return new Point(m,w,I,k)}const y=d(s*u),p=d(i*c),g=d(a*n*f),b=d(o*l),m=d((s+i)*(u+c)-y-p),w=b-g,k=b+g,I=d(p-r*y),B=d(m*w),S=d(k*I),x=d(m*I),E=d(w*k);return new Point(B,S,E,x)}subtract(e){return this.add(e.negate())}wNAF(e){return m.wNAFCached(this,p,e,Point.normalizeZ)}multiply(e){const{p:t,f:r}=this.wNAF(assertInRange(e,n));return Point.normalizeZ([t,r])[0]}multiplyUnsafe(e){let t=assertGE0(e);return t===T?b:this.equals(b)||t===_?this:this.equals(g)?this.wNAF(t).p:m.unsafeLadder(this,t)}isSmallOrder(){return this.multiplyUnsafe(u).is0()}isTorsionFree(){return m.unsafeLadder(this,n).is0()}toAffine(e){const{ex:t,ey:n,ez:s}=this,i=this.is0();null==e&&(e=i?N:r.inv(s));const o=d(t*e),a=d(n*e),u=d(s*e);if(i)return{x:T,y:_};if(u!==_)throw new Error("invZ was invalid");return{x:o,y:a}}clearCofactor(){const{h:e}=t;return e===_?this:this.multiplyUnsafe(e)}static fromHex(e,n=!1){const{d:s,a:i}=t,o=r.BYTES,a=(e=utils_ensureBytes("pointHex",e,o)).slice(),u=e[o-1];a[o-1]=-129&u;const f=utils_bytesToNumberLE(a);f===T||assertInRange(f,n?c:r.ORDER);const y=d(f*f),p=d(y-_),g=d(s*y-i);let{isValid:b,value:m}=l(p,g);if(!b)throw new Error("Point.fromHex: invalid y coordinate");const w=(m&_)===_,k=!!(128&u);if(!n&&m===T&&k)throw new Error("Point.fromHex: x=0 and x_0=1");return k!==w&&(m=d(-m)),Point.fromAffine({x:m,y:f})}static fromPrivateKey(e){return getExtendedPublicKey(e).point}toRawBytes(){const{x:e,y:t}=this.toAffine(),n=utils_numberToBytesLE(t,r.BYTES);return n[n.length-1]|=e&_?128:0,n}toHex(){return abstract_utils_bytesToHex(this.toRawBytes())}}Point.BASE=new Point(t.Gx,t.Gy,_,d(t.Gx*t.Gy)),Point.ZERO=new Point(T,_,_,T);const{BASE:g,ZERO:b}=Point,m=wNAF(Point,8*a);function modN(e){return modular_mod(e,n)}function modN_LE(e){return modN(utils_bytesToNumberLE(e))}function getExtendedPublicKey(e){const t=a;e=utils_ensureBytes("private key",e,t);const r=utils_ensureBytes("hashed private key",i(e),2*t),n=f(r.slice(0,t)),s=r.slice(t,2*t),o=modN_LE(n),u=g.multiply(o),c=u.toRawBytes();return{head:n,prefix:s,scalar:o,point:u,pointBytes:c}}function hashDomainToScalar(e=new Uint8Array,...t){const r=abstract_utils_concatBytes(...t);return modN_LE(i(y(r,utils_ensureBytes("context",e),!!s)))}const w=W;g._setWindowSize(8);return{CURVE:t,getPublicKey:function getPublicKey(e){return getExtendedPublicKey(e).pointBytes},sign:function sign(e,t,n={}){e=utils_ensureBytes("message",e),s&&(e=s(e));const{prefix:i,scalar:o,pointBytes:u}=getExtendedPublicKey(t),c=hashDomainToScalar(n.context,i,e),d=g.multiply(c).toRawBytes(),l=modN(c+hashDomainToScalar(n.context,d,u,e)*o);return assertGE0(l),utils_ensureBytes("result",abstract_utils_concatBytes(d,utils_numberToBytesLE(l,r.BYTES)),2*a)},verify:function verify(e,t,n,i=w){const{context:o,zip215:a}=i,u=r.BYTES;e=utils_ensureBytes("signature",e,2*u),t=utils_ensureBytes("message",t),s&&(t=s(t));const c=utils_bytesToNumberLE(e.slice(u,2*u));let d,l,f;try{d=Point.fromHex(n,a),l=Point.fromHex(e.slice(0,u),a),f=g.multiplyUnsafe(c)}catch(e){return!1}if(!a&&d.isSmallOrder())return!1;const y=hashDomainToScalar(o,l.toRawBytes(),d.toRawBytes(),t);return l.add(d.multiplyUnsafe(y)).subtract(f).clearCofactor().equals(Point.ZERO)},ExtendedPoint:Point,utils:{getExtendedPublicKey,randomPrivateKey:()=>o(r.BYTES),precompute:(e=8,t=Point.BASE)=>(t._setWindowSize(e),t.multiply(BigInt(3)),t)}}}const O=BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"),R=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752"),z=(BigInt(0),BigInt(1)),j=BigInt(2),U=BigInt(5),q=BigInt(10),C=BigInt(20),D=BigInt(40),Y=BigInt(80);function ed25519_pow_2_252_3(e){const t=O,r=e*e%t*e%t,n=modular_pow2(r,j,t)*r%t,s=modular_pow2(n,z,t)*e%t,i=modular_pow2(s,U,t)*s%t,o=modular_pow2(i,q,t)*i%t,a=modular_pow2(o,C,t)*o%t,u=modular_pow2(a,D,t)*a%t,c=modular_pow2(u,Y,t)*u%t,d=modular_pow2(c,Y,t)*u%t,l=modular_pow2(d,q,t)*i%t;return{pow_p_5_8:modular_pow2(l,j,t)*e%t,b2:r}}function adjustScalarBytes(e){return e[0]&=248,e[31]&=127,e[31]|=64,e}function uvRatio(e,t){const r=O,n=modular_mod(t*t*t,r),s=modular_mod(n*n*t,r);let i=modular_mod(e*n*ed25519_pow_2_252_3(e*s).pow_p_5_8,r);const o=modular_mod(t*i*i,r),a=i,u=modular_mod(i*R,r),c=o===e,d=o===modular_mod(-e,r),l=o===modular_mod(-e*R,r);return c&&(i=a),(d||l)&&(i=u),modular_isNegativeLE(i,r)&&(i=modular_mod(-i,r)),{isValid:c||d,value:i}}const F=Field(O,void 0,!0),H={a:BigInt(-1),d:BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),Fp:F,n:BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),h:BigInt(8),Gx:BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),Gy:BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),hash:y,randomBytes:utils_randomBytes,adjustScalarBytes,uvRatio},M=twistedEdwards(H);function ed25519_domain(e,t,r){if(t.length>255)throw new Error("Context is too big");return utils_concatBytes(utils_utf8ToBytes("SigEd25519 no Ed25519 collisions"),new Uint8Array([r?1:0,t.length]),t,e)}const V=(F.ORDER+BigInt(3))/BigInt(8);F.pow(j,V),F.sqrt(F.neg(F.ONE)),F.ORDER,BigInt(5),BigInt(8),BigInt(486662);(function FpSqrtEven(e,t){if(!e.isOdd)throw new Error("Field doesn't have isOdd");const r=e.sqrt(t);return e.isOdd(r)?e.neg(r):r})(F,F.neg(BigInt(486664)));BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235"),BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578"),BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838"),BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952"),BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");var $=r(682823),G=r.n($),Z=r(939216),J=r.n(Z),X=r(552001),Q=r(881818),ee=r(878918),te=r(856115),re=r(727801),ne=(r(759499),r(516246)),se=(r(885364),r(52494));const ie=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),oe=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),ae=new Uint32Array(64);class SHA256 extends HashMD{constructor(){super(64,32,8,!1),this.A=0|oe[0],this.B=0|oe[1],this.C=0|oe[2],this.D=0|oe[3],this.E=0|oe[4],this.F=0|oe[5],this.G=0|oe[6],this.H=0|oe[7]}get(){const{A:e,B:t,C:r,D:n,E:s,F:i,G:o,H:a}=this;return[e,t,r,n,s,i,o,a]}set(e,t,r,n,s,i,o,a){this.A=0|e,this.B=0|t,this.C=0|r,this.D=0|n,this.E=0|s,this.F=0|i,this.G=0|o,this.H=0|a}process(e,t){for(let r=0;r<16;r++,t+=4)ae[r]=e.getUint32(t,!1);for(let e=16;e<64;e++){const t=ae[e-15],r=ae[e-2],n=rotr(t,7)^rotr(t,18)^t>>>3,s=rotr(r,17)^rotr(r,19)^r>>>10;ae[e]=s+ae[e-7]+n+ae[e-16]|0}let{A:r,B:n,C:s,D:i,E:o,F:a,G:u,H:c}=this;for(let e=0;e<64;e++){const t=c+(rotr(o,6)^rotr(o,11)^rotr(o,25))+((d=o)&a^~d&u)+ie[e]+ae[e]|0,l=(rotr(r,2)^rotr(r,13)^rotr(r,22))+Maj(r,n,s)|0;c=u,u=a,a=o,o=i+t|0,i=s,s=n,n=r,r=t+l|0}var d;r=r+this.A|0,n=n+this.B|0,s=s+this.C|0,i=i+this.D|0,o=o+this.E|0,a=a+this.F|0,u=u+this.G|0,c=c+this.H|0,this.set(r,n,s,i,o,a,u,c)}roundClean(){ae.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}const ue=utils_wrapConstructor((()=>new SHA256));class HMAC extends Hash{constructor(e,t){super(),this.finished=!1,this.destroyed=!1,_assert_hash(e);const r=toBytes(t);if(this.iHash=e.create(),"function"!=typeof this.iHash.update)throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const n=this.blockLen,s=new Uint8Array(n);s.set(r.length>n?e.create().update(r).digest():r);for(let e=0;e<s.length;e++)s[e]^=54;this.iHash.update(s),this.oHash=e.create();for(let e=0;e<s.length;e++)s[e]^=106;this.oHash.update(s),s.fill(0)}update(e){return exists(this),this.iHash.update(e),this}digestInto(e){exists(this),bytes(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:t,iHash:r,finished:n,destroyed:s,blockLen:i,outputLen:o}=this;return e.finished=n,e.destroyed=s,e.blockLen=i,e.outputLen=o,e.oHash=t._cloneInto(e.oHash),e.iHash=r._cloneInto(e.iHash),e}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const hmac=(e,t,r)=>new HMAC(e,t).update(r).digest();hmac.create=(e,t)=>new HMAC(e,t);const{bytesToNumberBE:ce,hexToBytes:de}=n,le={Err:class DERErr extends Error{constructor(e=""){super(e)}},_parseInt(e){const{Err:t}=le;if(e.length<2||2!==e[0])throw new t("Invalid signature integer tag");const r=e[1],n=e.subarray(2,r+2);if(!r||n.length!==r)throw new t("Invalid signature integer: wrong length");if(128&n[0])throw new t("Invalid signature integer: negative");if(0===n[0]&&!(128&n[1]))throw new t("Invalid signature integer: unnecessary leading zero");return{d:ce(n),l:e.subarray(r+2)}},toSig(e){const{Err:t}=le,r="string"==typeof e?de(e):e;utils_abytes(r);let n=r.length;if(n<2||48!=r[0])throw new t("Invalid signature tag");if(r[1]!==n-2)throw new t("Invalid signature: incorrect length");const{d:s,l:i}=le._parseInt(r.subarray(2)),{d:o,l:a}=le._parseInt(i);if(a.length)throw new t("Invalid signature: left bytes after parsing");return{r:s,s:o}},hexFromSig(e){const slice=e=>8&Number.parseInt(e[0],16)?"00"+e:e,h=e=>{const t=e.toString(16);return 1&t.length?`0${t}`:t},t=slice(h(e.s)),r=slice(h(e.r)),n=t.length/2,s=r.length/2,i=h(n),o=h(s);return`30${h(s+n+4)}02${o}${r}02${i}${t}`}},he=BigInt(0),fe=BigInt(1),ye=(BigInt(2),BigInt(3));BigInt(4);function weierstrassPoints(e){const t=function validatePointOpts(e){const t=validateBasic(e);validateObject(t,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:r,Fp:n,a:s}=t;if(r){if(!n.eql(s,n.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if("object"!=typeof r||"bigint"!=typeof r.beta||"function"!=typeof r.splitScalar)throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...t})}(e),{Fp:r}=t,n=t.toBytes||((e,t,n)=>{const s=t.toAffine();return abstract_utils_concatBytes(Uint8Array.from([4]),r.toBytes(s.x),r.toBytes(s.y))}),s=t.fromBytes||(e=>{const t=e.subarray(1);return{x:r.fromBytes(t.subarray(0,r.BYTES)),y:r.fromBytes(t.subarray(r.BYTES,2*r.BYTES))}});function weierstrassEquation(e){const{a:n,b:s}=t,i=r.sqr(e),o=r.mul(i,e);return r.add(r.add(o,r.mul(e,n)),s)}if(!r.eql(r.sqr(t.Gy),weierstrassEquation(t.Gx)))throw new Error("bad generator point: equation left != right");function isWithinCurveOrder(e){return"bigint"==typeof e&&he<e&&e<t.n}function assertGE(e){if(!isWithinCurveOrder(e))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function normPrivateKeyToScalar(e){const{allowedPrivateKeyLengths:r,nByteLength:n,wrapPrivateKey:s,n:i}=t;if(r&&"bigint"!=typeof e){if(abstract_utils_isBytes(e)&&(e=abstract_utils_bytesToHex(e)),"string"!=typeof e||!r.includes(e.length))throw new Error("Invalid key");e=e.padStart(2*n,"0")}let o;try{o="bigint"==typeof e?e:utils_bytesToNumberBE(utils_ensureBytes("private key",e,n))}catch(t){throw new Error(`private key must be ${n} bytes, hex or bigint, not ${typeof e}`)}return s&&(o=modular_mod(o,i)),assertGE(o),o}const i=new Map;function assertPrjPoint(e){if(!(e instanceof Point))throw new Error("ProjectivePoint expected")}class Point{constructor(e,t,n){if(this.px=e,this.py=t,this.pz=n,null==e||!r.isValid(e))throw new Error("x required");if(null==t||!r.isValid(t))throw new Error("y required");if(null==n||!r.isValid(n))throw new Error("z required")}static fromAffine(e){const{x:t,y:n}=e||{};if(!e||!r.isValid(t)||!r.isValid(n))throw new Error("invalid affine point");if(e instanceof Point)throw new Error("projective point not allowed");const is0=e=>r.eql(e,r.ZERO);return is0(t)&&is0(n)?Point.ZERO:new Point(t,n,r.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(e){const t=r.invertBatch(e.map((e=>e.pz)));return e.map(((e,r)=>e.toAffine(t[r]))).map(Point.fromAffine)}static fromHex(e){const t=Point.fromAffine(s(utils_ensureBytes("pointHex",e)));return t.assertValidity(),t}static fromPrivateKey(e){return Point.BASE.multiply(normPrivateKeyToScalar(e))}_setWindowSize(e){this._WINDOW_SIZE=e,i.delete(this)}assertValidity(){if(this.is0()){if(t.allowInfinityPoint&&!r.is0(this.py))return;throw new Error("bad point: ZERO")}const{x:e,y:n}=this.toAffine();if(!r.isValid(e)||!r.isValid(n))throw new Error("bad point: x or y not FE");const s=r.sqr(n),i=weierstrassEquation(e);if(!r.eql(s,i))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){const{y:e}=this.toAffine();if(r.isOdd)return!r.isOdd(e);throw new Error("Field doesn't support isOdd")}equals(e){assertPrjPoint(e);const{px:t,py:n,pz:s}=this,{px:i,py:o,pz:a}=e,u=r.eql(r.mul(t,a),r.mul(i,s)),c=r.eql(r.mul(n,a),r.mul(o,s));return u&&c}negate(){return new Point(this.px,r.neg(this.py),this.pz)}double(){const{a:e,b:n}=t,s=r.mul(n,ye),{px:i,py:o,pz:a}=this;let u=r.ZERO,c=r.ZERO,d=r.ZERO,l=r.mul(i,i),f=r.mul(o,o),y=r.mul(a,a),p=r.mul(i,o);return p=r.add(p,p),d=r.mul(i,a),d=r.add(d,d),u=r.mul(e,d),c=r.mul(s,y),c=r.add(u,c),u=r.sub(f,c),c=r.add(f,c),c=r.mul(u,c),u=r.mul(p,u),d=r.mul(s,d),y=r.mul(e,y),p=r.sub(l,y),p=r.mul(e,p),p=r.add(p,d),d=r.add(l,l),l=r.add(d,l),l=r.add(l,y),l=r.mul(l,p),c=r.add(c,l),y=r.mul(o,a),y=r.add(y,y),l=r.mul(y,p),u=r.sub(u,l),d=r.mul(y,f),d=r.add(d,d),d=r.add(d,d),new Point(u,c,d)}add(e){assertPrjPoint(e);const{px:n,py:s,pz:i}=this,{px:o,py:a,pz:u}=e;let c=r.ZERO,d=r.ZERO,l=r.ZERO;const f=t.a,y=r.mul(t.b,ye);let p=r.mul(n,o),g=r.mul(s,a),b=r.mul(i,u),m=r.add(n,s),w=r.add(o,a);m=r.mul(m,w),w=r.add(p,g),m=r.sub(m,w),w=r.add(n,i);let k=r.add(o,u);return w=r.mul(w,k),k=r.add(p,b),w=r.sub(w,k),k=r.add(s,i),c=r.add(a,u),k=r.mul(k,c),c=r.add(g,b),k=r.sub(k,c),l=r.mul(f,w),c=r.mul(y,b),l=r.add(c,l),c=r.sub(g,l),l=r.add(g,l),d=r.mul(c,l),g=r.add(p,p),g=r.add(g,p),b=r.mul(f,b),w=r.mul(y,w),g=r.add(g,b),b=r.sub(p,b),b=r.mul(f,b),w=r.add(w,b),p=r.mul(g,w),d=r.add(d,p),p=r.mul(k,w),c=r.mul(m,c),c=r.sub(c,p),p=r.mul(m,g),l=r.mul(k,l),l=r.add(l,p),new Point(c,d,l)}subtract(e){return this.add(e.negate())}is0(){return this.equals(Point.ZERO)}wNAF(e){return a.wNAFCached(this,i,e,(e=>{const t=r.invertBatch(e.map((e=>e.pz)));return e.map(((e,r)=>e.toAffine(t[r]))).map(Point.fromAffine)}))}multiplyUnsafe(e){const n=Point.ZERO;if(e===he)return n;if(assertGE(e),e===fe)return this;const{endo:s}=t;if(!s)return a.unsafeLadder(this,e);let{k1neg:i,k1:o,k2neg:u,k2:c}=s.splitScalar(e),d=n,l=n,f=this;for(;o>he||c>he;)o&fe&&(d=d.add(f)),c&fe&&(l=l.add(f)),f=f.double(),o>>=fe,c>>=fe;return i&&(d=d.negate()),u&&(l=l.negate()),l=new Point(r.mul(l.px,s.beta),l.py,l.pz),d.add(l)}multiply(e){assertGE(e);let n,s,i=e;const{endo:o}=t;if(o){const{k1neg:e,k1:t,k2neg:u,k2:c}=o.splitScalar(i);let{p:d,f:l}=this.wNAF(t),{p:f,f:y}=this.wNAF(c);d=a.constTimeNegate(e,d),f=a.constTimeNegate(u,f),f=new Point(r.mul(f.px,o.beta),f.py,f.pz),n=d.add(f),s=l.add(y)}else{const{p:e,f:t}=this.wNAF(i);n=e,s=t}return Point.normalizeZ([n,s])[0]}multiplyAndAddUnsafe(e,t,r){const n=Point.BASE,mul=(e,t)=>t!==he&&t!==fe&&e.equals(n)?e.multiply(t):e.multiplyUnsafe(t),s=mul(this,t).add(mul(e,r));return s.is0()?void 0:s}toAffine(e){const{px:t,py:n,pz:s}=this,i=this.is0();null==e&&(e=i?r.ONE:r.inv(s));const o=r.mul(t,e),a=r.mul(n,e),u=r.mul(s,e);if(i)return{x:r.ZERO,y:r.ZERO};if(!r.eql(u,r.ONE))throw new Error("invZ was invalid");return{x:o,y:a}}isTorsionFree(){const{h:e,isTorsionFree:r}=t;if(e===fe)return!0;if(r)return r(Point,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:e,clearCofactor:r}=t;return e===fe?this:r?r(Point,this):this.multiplyUnsafe(t.h)}toRawBytes(e=!0){return this.assertValidity(),n(Point,this,e)}toHex(e=!0){return abstract_utils_bytesToHex(this.toRawBytes(e))}}Point.BASE=new Point(t.Gx,t.Gy,r.ONE),Point.ZERO=new Point(r.ZERO,r.ONE,r.ZERO);const o=t.nBitLength,a=wNAF(Point,t.endo?Math.ceil(o/2):o);return{CURVE:t,ProjectivePoint:Point,normPrivateKeyToScalar,weierstrassEquation,isWithinCurveOrder}}function weierstrass(e){const t=function weierstrass_validateOpts(e){const t=validateBasic(e);return validateObject(t,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...t})}(e),{Fp:r,n}=t,s=r.BYTES+1,i=2*r.BYTES+1;function modN(e){return modular_mod(e,n)}function invN(e){return invert(e,n)}const{ProjectivePoint:o,normPrivateKeyToScalar:a,weierstrassEquation:u,isWithinCurveOrder:c}=weierstrassPoints({...t,toBytes(e,t,n){const s=t.toAffine(),i=r.toBytes(s.x),o=abstract_utils_concatBytes;return n?o(Uint8Array.from([t.hasEvenY()?2:3]),i):o(Uint8Array.from([4]),i,r.toBytes(s.y))},fromBytes(e){const t=e.length,n=e[0],o=e.subarray(1);if(t!==s||2!==n&&3!==n){if(t===i&&4===n){return{x:r.fromBytes(o.subarray(0,r.BYTES)),y:r.fromBytes(o.subarray(r.BYTES,2*r.BYTES))}}throw new Error(`Point of length ${t} was invalid. Expected ${s} compressed bytes or ${i} uncompressed bytes`)}{const e=utils_bytesToNumberBE(o);if(!function isValidFieldElement(e){return he<e&&e<r.ORDER}(e))throw new Error("Point is not on curve");const t=u(e);let s;try{s=r.sqrt(t)}catch(e){const t=e instanceof Error?": "+e.message:"";throw new Error("Point is not on curve"+t)}return!(1&~n)!==((s&fe)===fe)&&(s=r.neg(s)),{x:e,y:s}}}}),numToNByteStr=e=>abstract_utils_bytesToHex(utils_numberToBytesBE(e,t.nByteLength));function isBiggerThanHalfOrder(e){return e>n>>fe}const slcNum=(e,t,r)=>utils_bytesToNumberBE(e.slice(t,r));class Signature{constructor(e,t,r){this.r=e,this.s=t,this.recovery=r,this.assertValidity()}static fromCompact(e){const r=t.nByteLength;return e=utils_ensureBytes("compactSignature",e,2*r),new Signature(slcNum(e,0,r),slcNum(e,r,2*r))}static fromDER(e){const{r:t,s:r}=le.toSig(utils_ensureBytes("DER",e));return new Signature(t,r)}assertValidity(){if(!c(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!c(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(e){return new Signature(this.r,this.s,e)}recoverPublicKey(e){const{r:n,s,recovery:i}=this,a=f(utils_ensureBytes("msgHash",e));if(null==i||![0,1,2,3].includes(i))throw new Error("recovery id invalid");const u=2===i||3===i?n+t.n:n;if(u>=r.ORDER)throw new Error("recovery id 2 or 3 invalid");const c=1&i?"03":"02",d=o.fromHex(c+numToNByteStr(u)),l=invN(u),y=modN(-a*l),p=modN(s*l),g=o.BASE.multiplyAndAddUnsafe(d,y,p);if(!g)throw new Error("point at infinify");return g.assertValidity(),g}hasHighS(){return isBiggerThanHalfOrder(this.s)}normalizeS(){return this.hasHighS()?new Signature(this.r,modN(-this.s),this.recovery):this}toDERRawBytes(){return utils_hexToBytes(this.toDERHex())}toDERHex(){return le.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return utils_hexToBytes(this.toCompactHex())}toCompactHex(){return numToNByteStr(this.r)+numToNByteStr(this.s)}}const d={isValidPrivateKey(e){try{return a(e),!0}catch(e){return!1}},normPrivateKeyToScalar:a,randomPrivateKey:()=>{const e=getMinHashLength(t.n);return function mapHashToField(e,t,r=!1){const n=e.length,s=getFieldBytesLength(t),i=getMinHashLength(t);if(n<16||n<i||n>1024)throw new Error(`expected ${i}-1024 bytes of input, got ${n}`);const o=modular_mod(r?utils_bytesToNumberBE(e):utils_bytesToNumberLE(e),t-I)+I;return r?utils_numberToBytesLE(o,s):utils_numberToBytesBE(o,s)}(t.randomBytes(e),t.n)},precompute:(e=8,t=o.BASE)=>(t._setWindowSize(e),t.multiply(BigInt(3)),t)};function isProbPub(e){const t=abstract_utils_isBytes(e),r="string"==typeof e,n=(t||r)&&e.length;return t?n===s||n===i:r?n===2*s||n===2*i:e instanceof o}const l=t.bits2int||function(e){const r=utils_bytesToNumberBE(e),n=8*e.length-t.nBitLength;return n>0?r>>BigInt(n):r},f=t.bits2int_modN||function(e){return modN(l(e))},y=bitMask(t.nBitLength);function int2octets(e){if("bigint"!=typeof e)throw new Error("bigint expected");if(!(he<=e&&e<y))throw new Error(`bigint expected < 2^${t.nBitLength}`);return utils_numberToBytesBE(e,t.nByteLength)}function prepSig(e,n,s=p){if(["recovered","canonical"].some((e=>e in s)))throw new Error("sign() legacy options not supported");const{hash:i,randomBytes:u}=t;let{lowS:d,prehash:y,extraEntropy:g}=s;null==d&&(d=!0),e=utils_ensureBytes("msgHash",e),y&&(e=utils_ensureBytes("prehashed msgHash",i(e)));const b=f(e),m=a(n),w=[int2octets(m),int2octets(b)];if(null!=g&&!1!==g){const e=!0===g?u(r.BYTES):g;w.push(utils_ensureBytes("extraEntropy",e))}const k=abstract_utils_concatBytes(...w),I=b;return{seed:k,k2sig:function k2sig(e){const t=l(e);if(!c(t))return;const r=invN(t),n=o.BASE.multiply(t).toAffine(),s=modN(n.x);if(s===he)return;const i=modN(r*modN(I+s*m));if(i===he)return;let a=(n.x===s?0:2)|Number(n.y&fe),u=i;return d&&isBiggerThanHalfOrder(i)&&(u=function normalizeS(e){return isBiggerThanHalfOrder(e)?modN(-e):e}(i),a^=1),new Signature(s,u,a)}}}const p={lowS:t.lowS,prehash:!1},g={lowS:t.lowS,prehash:!1};return o.BASE._setWindowSize(8),{CURVE:t,getPublicKey:function getPublicKey(e,t=!0){return o.fromPrivateKey(e).toRawBytes(t)},getSharedSecret:function getSharedSecret(e,t,r=!0){if(isProbPub(e))throw new Error("first arg must be private key");if(!isProbPub(t))throw new Error("second arg must be public key");return o.fromHex(t).multiply(a(e)).toRawBytes(r)},sign:function sign(e,r,n=p){const{seed:s,k2sig:i}=prepSig(e,r,n),o=t;return createHmacDrbg(o.hash.outputLen,o.nByteLength,o.hmac)(s,i)},verify:function verify(e,r,n,s=g){const i=e;if(r=utils_ensureBytes("msgHash",r),n=utils_ensureBytes("publicKey",n),"strict"in s)throw new Error("options.strict was renamed to lowS");const{lowS:a,prehash:u}=s;let c,d;try{if("string"==typeof i||abstract_utils_isBytes(i))try{c=Signature.fromDER(i)}catch(e){if(!(e instanceof le.Err))throw e;c=Signature.fromCompact(i)}else{if("object"!=typeof i||"bigint"!=typeof i.r||"bigint"!=typeof i.s)throw new Error("PARSE");{const{r:e,s:t}=i;c=new Signature(e,t)}}d=o.fromHex(n)}catch(e){if("PARSE"===e.message)throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(a&&c.hasHighS())return!1;u&&(r=t.hash(r));const{r:l,s:y}=c,p=f(r),b=invN(y),m=modN(p*b),w=modN(l*b),k=o.BASE.multiplyAndAddUnsafe(d,m,w)?.toAffine();return!!k&&modN(k.x)===l},ProjectivePoint:o,Signature,utils:d}}function getHash(e){return{hash:e,hmac:(t,...r)=>hmac(e,t,utils_concatBytes(...r)),randomBytes:utils_randomBytes}}const pe=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),ge=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),be=BigInt(1),me=BigInt(2),divNearest=(e,t)=>(e+t/me)/t;function sqrtMod(e){const t=pe,r=BigInt(3),n=BigInt(6),s=BigInt(11),i=BigInt(22),o=BigInt(23),a=BigInt(44),u=BigInt(88),c=e*e*e%t,d=c*c*e%t,l=modular_pow2(d,r,t)*d%t,f=modular_pow2(l,r,t)*d%t,y=modular_pow2(f,me,t)*c%t,p=modular_pow2(y,s,t)*y%t,g=modular_pow2(p,i,t)*p%t,b=modular_pow2(g,a,t)*g%t,m=modular_pow2(b,u,t)*b%t,w=modular_pow2(m,a,t)*g%t,k=modular_pow2(w,r,t)*d%t,I=modular_pow2(k,o,t)*p%t,B=modular_pow2(I,n,t)*c%t,S=modular_pow2(B,me,t);if(!we.eql(we.sqr(S),e))throw new Error("Cannot find square root");return S}const we=Field(pe,void 0,void 0,{sqrt:sqrtMod}),ke=function createCurve(e,t){const create=t=>weierstrass({...e,...getHash(t)});return Object.freeze({...create(t),create})}({a:BigInt(0),b:BigInt(7),Fp:we,n:ge,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:e=>{const t=ge,r=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),n=-be*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),s=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),i=r,o=BigInt("0x100000000000000000000000000000000"),a=divNearest(i*e,t),u=divNearest(-n*e,t);let c=modular_mod(e-a*r-u*s,t),d=modular_mod(-a*n-u*i,t);const l=c>o,f=d>o;if(l&&(c=t-c),f&&(d=t-d),c>o||d>o)throw new Error("splitScalar: Endomorphism failed, k="+e);return{k1neg:l,k1:c,k2neg:f,k2:d}}}},ue);BigInt(0);ke.ProjectivePoint;M.utils.randomPrivateKey;const generateKeypair=()=>{const e=M.utils.randomPrivateKey(),t=Ie(e),r=new Uint8Array(64);return r.set(e),r.set(t,32),{publicKey:t,secretKey:r}},Ie=M.getPublicKey;function isOnCurve(e){try{return M.ExtendedPoint.fromHex(e),!0}catch{return!1}}const sign=(e,t)=>M.sign(e,t.slice(0,32)),Be=M.verify,toBuffer=e=>s.Buffer.isBuffer(e)?e:e instanceof Uint8Array?s.Buffer.from(e.buffer,e.byteOffset,e.byteLength):s.Buffer.from(e);class Struct{constructor(e){Object.assign(this,e)}encode(){return s.Buffer.from((0,Q.serialize)(Se,this))}static decode(e){return(0,Q.deserialize)(Se,this,e)}static decodeUnchecked(e){return(0,Q.deserializeUnchecked)(Se,this,e)}}const Se=new Map;var xe;let Ee;const ve=32;let Pe=1;Ee=Symbol.toStringTag;class PublicKey extends Struct{constructor(e){if(super({}),this._bn=void 0,function isPublicKeyData(e){return void 0!==e._bn}(e))this._bn=e._bn;else{if("string"==typeof e){const t=J().decode(e);if(t.length!=ve)throw new Error("Invalid public key input");this._bn=new(G())(t)}else this._bn=new(G())(e);if(this._bn.byteLength()>ve)throw new Error("Invalid public key input")}}static unique(){const e=new PublicKey(Pe);return Pe+=1,new PublicKey(e.toBuffer())}equals(e){return this._bn.eq(e._bn)}toBase58(){return J().encode(this.toBytes())}toJSON(){return this.toBase58()}toBytes(){const e=this.toBuffer();return new Uint8Array(e.buffer,e.byteOffset,e.byteLength)}toBuffer(){const e=this._bn.toArrayLike(s.Buffer);if(e.length===ve)return e;const t=s.Buffer.alloc(32);return e.copy(t,32-e.length),t}get[Ee](){return`PublicKey(${this.toString()})`}toString(){return this.toBase58()}static async createWithSeed(e,t,r){const n=s.Buffer.concat([e.toBuffer(),s.Buffer.from(t),r.toBuffer()]),i=(0,X.s)(n);return new PublicKey(i)}static createProgramAddressSync(e,t){let r=s.Buffer.alloc(0);e.forEach((function(e){if(e.length>32)throw new TypeError("Max seed length exceeded");r=s.Buffer.concat([r,toBuffer(e)])})),r=s.Buffer.concat([r,t.toBuffer(),s.Buffer.from("ProgramDerivedAddress")]);const n=(0,X.s)(r);if(isOnCurve(n))throw new Error("Invalid seeds, address must fall off the curve");return new PublicKey(n)}static async createProgramAddress(e,t){return this.createProgramAddressSync(e,t)}static findProgramAddressSync(e,t){let r,n=255;for(;0!=n;){try{const i=e.concat(s.Buffer.from([n]));r=this.createProgramAddressSync(i,t)}catch(e){if(e instanceof TypeError)throw e;n--;continue}return[r,n]}throw new Error("Unable to find a viable program address nonce")}static async findProgramAddress(e,t){return this.findProgramAddressSync(e,t)}static isOnCurve(e){return isOnCurve(new PublicKey(e).toBytes())}}xe=PublicKey,PublicKey.default=new xe("11111111111111111111111111111111"),Se.set(PublicKey,{kind:"struct",fields:[["_bn","u256"]]});new PublicKey("BPFLoader1111111111111111111111111111111111");const Ae=1232;class TransactionExpiredBlockheightExceededError extends Error{constructor(e){super(`Signature ${e} has expired: block height exceeded.`),this.signature=void 0,this.signature=e}}Object.defineProperty(TransactionExpiredBlockheightExceededError.prototype,"name",{value:"TransactionExpiredBlockheightExceededError"});class TransactionExpiredTimeoutError extends Error{constructor(e,t){super(`Transaction was not confirmed in ${t.toFixed(2)} seconds. It is unknown if it succeeded or failed. Check signature ${e} using the Solana Explorer or CLI tools.`),this.signature=void 0,this.signature=e}}Object.defineProperty(TransactionExpiredTimeoutError.prototype,"name",{value:"TransactionExpiredTimeoutError"});class TransactionExpiredNonceInvalidError extends Error{constructor(e){super(`Signature ${e} has expired: the nonce is no longer valid.`),this.signature=void 0,this.signature=e}}Object.defineProperty(TransactionExpiredNonceInvalidError.prototype,"name",{value:"TransactionExpiredNonceInvalidError"});class MessageAccountKeys{constructor(e,t){this.staticAccountKeys=void 0,this.accountKeysFromLookups=void 0,this.staticAccountKeys=e,this.accountKeysFromLookups=t}keySegments(){const e=[this.staticAccountKeys];return this.accountKeysFromLookups&&(e.push(this.accountKeysFromLookups.writable),e.push(this.accountKeysFromLookups.readonly)),e}get(e){for(const t of this.keySegments()){if(e<t.length)return t[e];e-=t.length}}get length(){return this.keySegments().flat().length}compileInstructions(e){if(this.length>256)throw new Error("Account index overflow encountered during compilation");const t=new Map;this.keySegments().flat().forEach(((e,r)=>{t.set(e.toBase58(),r)}));const findKeyIndex=e=>{const r=t.get(e.toBase58());if(void 0===r)throw new Error("Encountered an unknown instruction account key during compilation");return r};return e.map((e=>({programIdIndex:findKeyIndex(e.programId),accountKeyIndexes:e.keys.map((e=>findKeyIndex(e.pubkey))),data:e.data})))}}const publicKey=(e="publicKey")=>ee.blob(32,e),signature=(e="signature")=>ee.blob(64,e),rustString=(e="string")=>{const t=ee.struct([ee.u32("length"),ee.u32("lengthPadding"),ee.blob(ee.offset(ee.u32(),-8),"chars")],e),r=t.decode.bind(t),n=t.encode.bind(t),i=t;return i.decode=(e,t)=>r(e,t).chars.toString(),i.encode=(e,t,r)=>{const i={chars:s.Buffer.from(e,"utf8")};return n(i,t,r)},i.alloc=e=>ee.u32().span+ee.u32().span+s.Buffer.from(e,"utf8").length,i};function getAlloc(e,t){const getItemAlloc=e=>{if(e.span>=0)return e.span;if("function"==typeof e.alloc)return e.alloc(t[e.property]);if("count"in e&&"elementLayout"in e){const r=t[e.property];if(Array.isArray(r))return r.length*getItemAlloc(e.elementLayout)}else if("fields"in e)return getAlloc({layout:e},t[e.property]);return 0};let r=0;return e.layout.fields.forEach((e=>{r+=getItemAlloc(e)})),r}function decodeLength(e){let t=0,r=0;for(;;){let n=e.shift();if(t|=(127&n)<<7*r,r+=1,!(128&n))break}return t}function encodeLength(e,t){let r=t;for(;;){let t=127&r;if(r>>=7,0==r){e.push(t);break}t|=128,e.push(t)}}function index_browser_esm_assert(e,t){if(!e)throw new Error(t||"Assertion failed")}class CompiledKeys{constructor(e,t){this.payer=void 0,this.keyMetaMap=void 0,this.payer=e,this.keyMetaMap=t}static compile(e,t){const r=new Map,getOrInsertDefault=e=>{const t=e.toBase58();let n=r.get(t);return void 0===n&&(n={isSigner:!1,isWritable:!1,isInvoked:!1},r.set(t,n)),n},n=getOrInsertDefault(t);n.isSigner=!0,n.isWritable=!0;for(const t of e){getOrInsertDefault(t.programId).isInvoked=!0;for(const e of t.keys){const t=getOrInsertDefault(e.pubkey);t.isSigner||=e.isSigner,t.isWritable||=e.isWritable}}return new CompiledKeys(t,r)}getMessageComponents(){const e=[...this.keyMetaMap.entries()];index_browser_esm_assert(e.length<=256,"Max static account keys length exceeded");const t=e.filter((([,e])=>e.isSigner&&e.isWritable)),r=e.filter((([,e])=>e.isSigner&&!e.isWritable)),n=e.filter((([,e])=>!e.isSigner&&e.isWritable)),s=e.filter((([,e])=>!e.isSigner&&!e.isWritable)),i={numRequiredSignatures:t.length+r.length,numReadonlySignedAccounts:r.length,numReadonlyUnsignedAccounts:s.length};{index_browser_esm_assert(t.length>0,"Expected at least one writable signer key");const[e]=t[0];index_browser_esm_assert(e===this.payer.toBase58(),"Expected first writable signer key to be the fee payer")}return[i,[...t.map((([e])=>new PublicKey(e))),...r.map((([e])=>new PublicKey(e))),...n.map((([e])=>new PublicKey(e))),...s.map((([e])=>new PublicKey(e)))]]}extractTableLookup(e){const[t,r]=this.drainKeysFoundInLookupTable(e.state.addresses,(e=>!e.isSigner&&!e.isInvoked&&e.isWritable)),[n,s]=this.drainKeysFoundInLookupTable(e.state.addresses,(e=>!e.isSigner&&!e.isInvoked&&!e.isWritable));if(0!==t.length||0!==n.length)return[{accountKey:e.key,writableIndexes:t,readonlyIndexes:n},{writable:r,readonly:s}]}drainKeysFoundInLookupTable(e,t){const r=new Array,n=new Array;for(const[s,i]of this.keyMetaMap.entries())if(t(i)){const t=new PublicKey(s),i=e.findIndex((e=>e.equals(t)));i>=0&&(index_browser_esm_assert(i<256,"Max lookup table index exceeded"),r.push(i),n.push(t),this.keyMetaMap.delete(s))}return[r,n]}}const Le="Reached end of buffer unexpectedly";function guardedShift(e){if(0===e.length)throw new Error(Le);return e.shift()}function guardedSplice(e,...t){const[r]=t;if(2===t.length?r+(t[1]??0)>e.length:r>=e.length)throw new Error(Le);return e.splice(...t)}class Message{constructor(e){this.header=void 0,this.accountKeys=void 0,this.recentBlockhash=void 0,this.instructions=void 0,this.indexToProgramIds=new Map,this.header=e.header,this.accountKeys=e.accountKeys.map((e=>new PublicKey(e))),this.recentBlockhash=e.recentBlockhash,this.instructions=e.instructions,this.instructions.forEach((e=>this.indexToProgramIds.set(e.programIdIndex,this.accountKeys[e.programIdIndex])))}get version(){return"legacy"}get staticAccountKeys(){return this.accountKeys}get compiledInstructions(){return this.instructions.map((e=>({programIdIndex:e.programIdIndex,accountKeyIndexes:e.accounts,data:J().decode(e.data)})))}get addressTableLookups(){return[]}getAccountKeys(){return new MessageAccountKeys(this.staticAccountKeys)}static compile(e){const t=CompiledKeys.compile(e.instructions,e.payerKey),[r,n]=t.getMessageComponents(),s=new MessageAccountKeys(n).compileInstructions(e.instructions).map((e=>({programIdIndex:e.programIdIndex,accounts:e.accountKeyIndexes,data:J().encode(e.data)})));return new Message({header:r,accountKeys:n,recentBlockhash:e.recentBlockhash,instructions:s})}isAccountSigner(e){return e<this.header.numRequiredSignatures}isAccountWritable(e){const t=this.header.numRequiredSignatures;if(e>=this.header.numRequiredSignatures){return e-t<this.accountKeys.length-t-this.header.numReadonlyUnsignedAccounts}return e<t-this.header.numReadonlySignedAccounts}isProgramId(e){return this.indexToProgramIds.has(e)}programIds(){return[...this.indexToProgramIds.values()]}nonProgramIds(){return this.accountKeys.filter(((e,t)=>!this.isProgramId(t)))}serialize(){const e=this.accountKeys.length;let t=[];encodeLength(t,e);const r=this.instructions.map((e=>{const{accounts:t,programIdIndex:r}=e,n=Array.from(J().decode(e.data));let i=[];encodeLength(i,t.length);let o=[];return encodeLength(o,n.length),{programIdIndex:r,keyIndicesCount:s.Buffer.from(i),keyIndices:t,dataLength:s.Buffer.from(o),data:n}}));let n=[];encodeLength(n,r.length);let i=s.Buffer.alloc(Ae);s.Buffer.from(n).copy(i);let o=n.length;r.forEach((e=>{const t=ee.struct([ee.u8("programIdIndex"),ee.blob(e.keyIndicesCount.length,"keyIndicesCount"),ee.seq(ee.u8("keyIndex"),e.keyIndices.length,"keyIndices"),ee.blob(e.dataLength.length,"dataLength"),ee.seq(ee.u8("userdatum"),e.data.length,"data")]).encode(e,i,o);o+=t})),i=i.slice(0,o);const a=ee.struct([ee.blob(1,"numRequiredSignatures"),ee.blob(1,"numReadonlySignedAccounts"),ee.blob(1,"numReadonlyUnsignedAccounts"),ee.blob(t.length,"keyCount"),ee.seq(publicKey("key"),e,"keys"),publicKey("recentBlockhash")]),u={numRequiredSignatures:s.Buffer.from([this.header.numRequiredSignatures]),numReadonlySignedAccounts:s.Buffer.from([this.header.numReadonlySignedAccounts]),numReadonlyUnsignedAccounts:s.Buffer.from([this.header.numReadonlyUnsignedAccounts]),keyCount:s.Buffer.from(t),keys:this.accountKeys.map((e=>toBuffer(e.toBytes()))),recentBlockhash:J().decode(this.recentBlockhash)};let c=s.Buffer.alloc(2048);const d=a.encode(u,c);return i.copy(c,d),c.slice(0,d+i.length)}static from(e){let t=[...e];const r=guardedShift(t);if(r!==(127&r))throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");const n=guardedShift(t),i=guardedShift(t),o=decodeLength(t);let a=[];for(let e=0;e<o;e++){const e=guardedSplice(t,0,ve);a.push(new PublicKey(s.Buffer.from(e)))}const u=guardedSplice(t,0,ve),c=decodeLength(t);let d=[];for(let e=0;e<c;e++){const e=guardedShift(t),r=guardedSplice(t,0,decodeLength(t)),n=guardedSplice(t,0,decodeLength(t)),i=J().encode(s.Buffer.from(n));d.push({programIdIndex:e,accounts:r,data:i})}const l={header:{numRequiredSignatures:r,numReadonlySignedAccounts:n,numReadonlyUnsignedAccounts:i},recentBlockhash:J().encode(s.Buffer.from(u)),accountKeys:a,instructions:d};return new Message(l)}}class MessageV0{constructor(e){this.header=void 0,this.staticAccountKeys=void 0,this.recentBlockhash=void 0,this.compiledInstructions=void 0,this.addressTableLookups=void 0,this.header=e.header,this.staticAccountKeys=e.staticAccountKeys,this.recentBlockhash=e.recentBlockhash,this.compiledInstructions=e.compiledInstructions,this.addressTableLookups=e.addressTableLookups}get version(){return 0}get numAccountKeysFromLookups(){let e=0;for(const t of this.addressTableLookups)e+=t.readonlyIndexes.length+t.writableIndexes.length;return e}getAccountKeys(e){let t;if(e&&"accountKeysFromLookups"in e&&e.accountKeysFromLookups){if(this.numAccountKeysFromLookups!=e.accountKeysFromLookups.writable.length+e.accountKeysFromLookups.readonly.length)throw new Error("Failed to get account keys because of a mismatch in the number of account keys from lookups");t=e.accountKeysFromLookups}else if(e&&"addressLookupTableAccounts"in e&&e.addressLookupTableAccounts)t=this.resolveAddressTableLookups(e.addressLookupTableAccounts);else if(this.addressTableLookups.length>0)throw new Error("Failed to get account keys because address table lookups were not resolved");return new MessageAccountKeys(this.staticAccountKeys,t)}isAccountSigner(e){return e<this.header.numRequiredSignatures}isAccountWritable(e){const t=this.header.numRequiredSignatures,r=this.staticAccountKeys.length;if(e>=r){return e-r<this.addressTableLookups.reduce(((e,t)=>e+t.writableIndexes.length),0)}if(e>=this.header.numRequiredSignatures){return e-t<r-t-this.header.numReadonlyUnsignedAccounts}return e<t-this.header.numReadonlySignedAccounts}resolveAddressTableLookups(e){const t={writable:[],readonly:[]};for(const r of this.addressTableLookups){const n=e.find((e=>e.key.equals(r.accountKey)));if(!n)throw new Error(`Failed to find address lookup table account for table key ${r.accountKey.toBase58()}`);for(const e of r.writableIndexes){if(!(e<n.state.addresses.length))throw new Error(`Failed to find address for index ${e} in address lookup table ${r.accountKey.toBase58()}`);t.writable.push(n.state.addresses[e])}for(const e of r.readonlyIndexes){if(!(e<n.state.addresses.length))throw new Error(`Failed to find address for index ${e} in address lookup table ${r.accountKey.toBase58()}`);t.readonly.push(n.state.addresses[e])}}return t}static compile(e){const t=CompiledKeys.compile(e.instructions,e.payerKey),r=new Array,n={writable:new Array,readonly:new Array},s=e.addressLookupTableAccounts||[];for(const e of s){const s=t.extractTableLookup(e);if(void 0!==s){const[e,{writable:t,readonly:i}]=s;r.push(e),n.writable.push(...t),n.readonly.push(...i)}}const[i,o]=t.getMessageComponents(),a=new MessageAccountKeys(o,n).compileInstructions(e.instructions);return new MessageV0({header:i,staticAccountKeys:o,recentBlockhash:e.recentBlockhash,compiledInstructions:a,addressTableLookups:r})}serialize(){const e=Array();encodeLength(e,this.staticAccountKeys.length);const t=this.serializeInstructions(),r=Array();encodeLength(r,this.compiledInstructions.length);const n=this.serializeAddressTableLookups(),s=Array();encodeLength(s,this.addressTableLookups.length);const i=ee.struct([ee.u8("prefix"),ee.struct([ee.u8("numRequiredSignatures"),ee.u8("numReadonlySignedAccounts"),ee.u8("numReadonlyUnsignedAccounts")],"header"),ee.blob(e.length,"staticAccountKeysLength"),ee.seq(publicKey(),this.staticAccountKeys.length,"staticAccountKeys"),publicKey("recentBlockhash"),ee.blob(r.length,"instructionsLength"),ee.blob(t.length,"serializedInstructions"),ee.blob(s.length,"addressTableLookupsLength"),ee.blob(n.length,"serializedAddressTableLookups")]),o=new Uint8Array(Ae),a=i.encode({prefix:128,header:this.header,staticAccountKeysLength:new Uint8Array(e),staticAccountKeys:this.staticAccountKeys.map((e=>e.toBytes())),recentBlockhash:J().decode(this.recentBlockhash),instructionsLength:new Uint8Array(r),serializedInstructions:t,addressTableLookupsLength:new Uint8Array(s),serializedAddressTableLookups:n},o);return o.slice(0,a)}serializeInstructions(){let e=0;const t=new Uint8Array(Ae);for(const r of this.compiledInstructions){const n=Array();encodeLength(n,r.accountKeyIndexes.length);const s=Array();encodeLength(s,r.data.length);e+=ee.struct([ee.u8("programIdIndex"),ee.blob(n.length,"encodedAccountKeyIndexesLength"),ee.seq(ee.u8(),r.accountKeyIndexes.length,"accountKeyIndexes"),ee.blob(s.length,"encodedDataLength"),ee.blob(r.data.length,"data")]).encode({programIdIndex:r.programIdIndex,encodedAccountKeyIndexesLength:new Uint8Array(n),accountKeyIndexes:r.accountKeyIndexes,encodedDataLength:new Uint8Array(s),data:r.data},t,e)}return t.slice(0,e)}serializeAddressTableLookups(){let e=0;const t=new Uint8Array(Ae);for(const r of this.addressTableLookups){const n=Array();encodeLength(n,r.writableIndexes.length);const s=Array();encodeLength(s,r.readonlyIndexes.length);e+=ee.struct([publicKey("accountKey"),ee.blob(n.length,"encodedWritableIndexesLength"),ee.seq(ee.u8(),r.writableIndexes.length,"writableIndexes"),ee.blob(s.length,"encodedReadonlyIndexesLength"),ee.seq(ee.u8(),r.readonlyIndexes.length,"readonlyIndexes")]).encode({accountKey:r.accountKey.toBytes(),encodedWritableIndexesLength:new Uint8Array(n),writableIndexes:r.writableIndexes,encodedReadonlyIndexesLength:new Uint8Array(s),readonlyIndexes:r.readonlyIndexes},t,e)}return t.slice(0,e)}static deserialize(e){let t=[...e];const r=guardedShift(t),n=127&r;index_browser_esm_assert(r!==n,"Expected versioned message but received legacy message");index_browser_esm_assert(0===n,`Expected versioned message with version 0 but found version ${n}`);const s={numRequiredSignatures:guardedShift(t),numReadonlySignedAccounts:guardedShift(t),numReadonlyUnsignedAccounts:guardedShift(t)},i=[],o=decodeLength(t);for(let e=0;e<o;e++)i.push(new PublicKey(guardedSplice(t,0,ve)));const a=J().encode(guardedSplice(t,0,ve)),u=decodeLength(t),c=[];for(let e=0;e<u;e++){const e=guardedShift(t),r=guardedSplice(t,0,decodeLength(t)),n=decodeLength(t),s=new Uint8Array(guardedSplice(t,0,n));c.push({programIdIndex:e,accountKeyIndexes:r,data:s})}const d=decodeLength(t),l=[];for(let e=0;e<d;e++){const e=new PublicKey(guardedSplice(t,0,ve)),r=guardedSplice(t,0,decodeLength(t)),n=guardedSplice(t,0,decodeLength(t));l.push({accountKey:e,writableIndexes:r,readonlyIndexes:n})}return new MessageV0({header:s,staticAccountKeys:i,recentBlockhash:a,compiledInstructions:c,addressTableLookups:l})}}const Te={deserializeMessageVersion(e){const t=e[0],r=127&t;return r===t?"legacy":r},deserialize:e=>{const t=Te.deserializeMessageVersion(e);if("legacy"===t)return Message.from(e);if(0===t)return MessageV0.deserialize(e);throw new Error(`Transaction message version ${t} deserialization is not supported`)}};const _e=s.Buffer.alloc(64).fill(0);class TransactionInstruction{constructor(e){this.keys=void 0,this.programId=void 0,this.data=s.Buffer.alloc(0),this.programId=e.programId,this.keys=e.keys,e.data&&(this.data=e.data)}toJSON(){return{keys:this.keys.map((({pubkey:e,isSigner:t,isWritable:r})=>({pubkey:e.toJSON(),isSigner:t,isWritable:r}))),programId:this.programId.toJSON(),data:[...this.data]}}}class Transaction{get signature(){return this.signatures.length>0?this.signatures[0].signature:null}constructor(e){if(this.signatures=[],this.feePayer=void 0,this.instructions=[],this.recentBlockhash=void 0,this.lastValidBlockHeight=void 0,this.nonceInfo=void 0,this.minNonceContextSlot=void 0,this._message=void 0,this._json=void 0,e)if(e.feePayer&&(this.feePayer=e.feePayer),e.signatures&&(this.signatures=e.signatures),Object.prototype.hasOwnProperty.call(e,"nonceInfo")){const{minContextSlot:t,nonceInfo:r}=e;this.minNonceContextSlot=t,this.nonceInfo=r}else if(Object.prototype.hasOwnProperty.call(e,"lastValidBlockHeight")){const{blockhash:t,lastValidBlockHeight:r}=e;this.recentBlockhash=t,this.lastValidBlockHeight=r}else{const{recentBlockhash:t,nonceInfo:r}=e;r&&(this.nonceInfo=r),this.recentBlockhash=t}}toJSON(){return{recentBlockhash:this.recentBlockhash||null,feePayer:this.feePayer?this.feePayer.toJSON():null,nonceInfo:this.nonceInfo?{nonce:this.nonceInfo.nonce,nonceInstruction:this.nonceInfo.nonceInstruction.toJSON()}:null,instructions:this.instructions.map((e=>e.toJSON())),signers:this.signatures.map((({publicKey:e})=>e.toJSON()))}}add(...e){if(0===e.length)throw new Error("No instructions");return e.forEach((e=>{"instructions"in e?this.instructions=this.instructions.concat(e.instructions):"data"in e&&"programId"in e&&"keys"in e?this.instructions.push(e):this.instructions.push(new TransactionInstruction(e))})),this}compileMessage(){if(this._message&&JSON.stringify(this.toJSON())===JSON.stringify(this._json))return this._message;let e,t,r;if(this.nonceInfo?(e=this.nonceInfo.nonce,t=this.instructions[0]!=this.nonceInfo.nonceInstruction?[this.nonceInfo.nonceInstruction,...this.instructions]:this.instructions):(e=this.recentBlockhash,t=this.instructions),!e)throw new Error("Transaction recentBlockhash required");if(t.length<1&&console.warn("No instructions provided"),this.feePayer)r=this.feePayer;else{if(!(this.signatures.length>0&&this.signatures[0].publicKey))throw new Error("Transaction fee payer required");r=this.signatures[0].publicKey}for(let e=0;e<t.length;e++)if(void 0===t[e].programId)throw new Error(`Transaction instruction index ${e} has undefined program id`);const n=[],s=[];t.forEach((e=>{e.keys.forEach((e=>{s.push({...e})}));const t=e.programId.toString();n.includes(t)||n.push(t)})),n.forEach((e=>{s.push({pubkey:new PublicKey(e),isSigner:!1,isWritable:!1})}));const i=[];s.forEach((e=>{const t=e.pubkey.toString(),r=i.findIndex((e=>e.pubkey.toString()===t));r>-1?(i[r].isWritable=i[r].isWritable||e.isWritable,i[r].isSigner=i[r].isSigner||e.isSigner):i.push(e)})),i.sort((function(e,t){if(e.isSigner!==t.isSigner)return e.isSigner?-1:1;if(e.isWritable!==t.isWritable)return e.isWritable?-1:1;return e.pubkey.toBase58().localeCompare(t.pubkey.toBase58(),"en",{localeMatcher:"best fit",usage:"sort",sensitivity:"variant",ignorePunctuation:!1,numeric:!1,caseFirst:"lower"})}));const o=i.findIndex((e=>e.pubkey.equals(r)));if(o>-1){const[e]=i.splice(o,1);e.isSigner=!0,e.isWritable=!0,i.unshift(e)}else i.unshift({pubkey:r,isSigner:!0,isWritable:!0});for(const e of this.signatures){const t=i.findIndex((t=>t.pubkey.equals(e.publicKey)));if(!(t>-1))throw new Error(`unknown signer: ${e.publicKey.toString()}`);i[t].isSigner||(i[t].isSigner=!0,console.warn("Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release."))}let a=0,u=0,c=0;const d=[],l=[];i.forEach((({pubkey:e,isSigner:t,isWritable:r})=>{t?(d.push(e.toString()),a+=1,r||(u+=1)):(l.push(e.toString()),r||(c+=1))}));const f=d.concat(l),y=t.map((e=>{const{data:t,programId:r}=e;return{programIdIndex:f.indexOf(r.toString()),accounts:e.keys.map((e=>f.indexOf(e.pubkey.toString()))),data:J().encode(t)}}));return y.forEach((e=>{index_browser_esm_assert(e.programIdIndex>=0),e.accounts.forEach((e=>index_browser_esm_assert(e>=0)))})),new Message({header:{numRequiredSignatures:a,numReadonlySignedAccounts:u,numReadonlyUnsignedAccounts:c},accountKeys:f,recentBlockhash:e,instructions:y})}_compile(){const e=this.compileMessage(),t=e.accountKeys.slice(0,e.header.numRequiredSignatures);if(this.signatures.length===t.length){if(this.signatures.every(((e,r)=>t[r].equals(e.publicKey))))return e}return this.signatures=t.map((e=>({signature:null,publicKey:e}))),e}serializeMessage(){return this._compile().serialize()}async getEstimatedFee(e){return(await e.getFeeForMessage(this.compileMessage())).value}setSigners(...e){if(0===e.length)throw new Error("No signers");const t=new Set;this.signatures=e.filter((e=>{const r=e.toString();return!t.has(r)&&(t.add(r),!0)})).map((e=>({signature:null,publicKey:e})))}sign(...e){if(0===e.length)throw new Error("No signers");const t=new Set,r=[];for(const n of e){const e=n.publicKey.toString();t.has(e)||(t.add(e),r.push(n))}this.signatures=r.map((e=>({signature:null,publicKey:e.publicKey})));const n=this._compile();this._partialSign(n,...r)}partialSign(...e){if(0===e.length)throw new Error("No signers");const t=new Set,r=[];for(const n of e){const e=n.publicKey.toString();t.has(e)||(t.add(e),r.push(n))}const n=this._compile();this._partialSign(n,...r)}_partialSign(e,...t){const r=e.serialize();t.forEach((e=>{const t=sign(r,e.secretKey);this._addSignature(e.publicKey,toBuffer(t))}))}addSignature(e,t){this._compile(),this._addSignature(e,t)}_addSignature(e,t){index_browser_esm_assert(64===t.length);const r=this.signatures.findIndex((t=>e.equals(t.publicKey)));if(r<0)throw new Error(`unknown signer: ${e.toString()}`);this.signatures[r].signature=s.Buffer.from(t)}verifySignatures(e=!0){return!this._getMessageSignednessErrors(this.serializeMessage(),e)}_getMessageSignednessErrors(e,t){const r={};for(const{signature:n,publicKey:s}of this.signatures)null===n?t&&(r.missing||=[]).push(s):Be(n,e,s.toBytes())||(r.invalid||=[]).push(s);return r.invalid||r.missing?r:void 0}serialize(e){const{requireAllSignatures:t,verifySignatures:r}=Object.assign({requireAllSignatures:!0,verifySignatures:!0},e),n=this.serializeMessage();if(r){const e=this._getMessageSignednessErrors(n,t);if(e){let t="Signature verification failed.";throw e.invalid&&(t+=`\nInvalid signature for public key${1===e.invalid.length?"":"(s)"} [\`${e.invalid.map((e=>e.toBase58())).join("`, `")}\`].`),e.missing&&(t+=`\nMissing signature for public key${1===e.missing.length?"":"(s)"} [\`${e.missing.map((e=>e.toBase58())).join("`, `")}\`].`),new Error(t)}}return this._serialize(n)}_serialize(e){const{signatures:t}=this,r=[];encodeLength(r,t.length);const n=r.length+64*t.length+e.length,i=s.Buffer.alloc(n);return index_browser_esm_assert(t.length<256),s.Buffer.from(r).copy(i,0),t.forEach((({signature:e},t)=>{null!==e&&(index_browser_esm_assert(64===e.length,"signature has invalid length"),s.Buffer.from(e).copy(i,r.length+64*t))})),e.copy(i,r.length+64*t.length),index_browser_esm_assert(i.length<=Ae,`Transaction too large: ${i.length} > 1232`),i}get keys(){return index_browser_esm_assert(1===this.instructions.length),this.instructions[0].keys.map((e=>e.pubkey))}get programId(){return index_browser_esm_assert(1===this.instructions.length),this.instructions[0].programId}get data(){return index_browser_esm_assert(1===this.instructions.length),this.instructions[0].data}static from(e){let t=[...e];const r=decodeLength(t);let n=[];for(let e=0;e<r;e++){const e=guardedSplice(t,0,64);n.push(J().encode(s.Buffer.from(e)))}return Transaction.populate(Message.from(t),n)}static populate(e,t=[]){const r=new Transaction;return r.recentBlockhash=e.recentBlockhash,e.header.numRequiredSignatures>0&&(r.feePayer=e.accountKeys[0]),t.forEach(((t,n)=>{const s={signature:t==J().encode(_e)?null:J().decode(t),publicKey:e.accountKeys[n]};r.signatures.push(s)})),e.instructions.forEach((t=>{const n=t.accounts.map((t=>{const n=e.accountKeys[t];return{pubkey:n,isSigner:r.signatures.some((e=>e.publicKey.toString()===n.toString()))||e.isAccountSigner(t),isWritable:e.isAccountWritable(t)}}));r.instructions.push(new TransactionInstruction({keys:n,programId:e.accountKeys[t.programIdIndex],data:J().decode(t.data)}))})),r._message=e,r._json=r.toJSON(),r}}class TransactionMessage{constructor(e){this.payerKey=void 0,this.instructions=void 0,this.recentBlockhash=void 0,this.payerKey=e.payerKey,this.instructions=e.instructions,this.recentBlockhash=e.recentBlockhash}static decompile(e,t){const{header:r,compiledInstructions:n,recentBlockhash:s}=e,{numRequiredSignatures:i,numReadonlySignedAccounts:o,numReadonlyUnsignedAccounts:a}=r,u=i-o;index_browser_esm_assert(u>0,"Message header is invalid");const c=e.staticAccountKeys.length-i-a;index_browser_esm_assert(c>=0,"Message header is invalid");const d=e.getAccountKeys(t),l=d.get(0);if(void 0===l)throw new Error("Failed to decompile message because no account keys were found");const f=[];for(const e of n){const t=[];for(const n of e.accountKeyIndexes){const e=d.get(n);if(void 0===e)throw new Error(`Failed to find key for account key index ${n}`);let s;s=n<i?n<u:n<d.staticAccountKeys.length?n-i<c:n-d.staticAccountKeys.length<d.accountKeysFromLookups.writable.length,t.push({pubkey:e,isSigner:n<r.numRequiredSignatures,isWritable:s})}const n=d.get(e.programIdIndex);if(void 0===n)throw new Error(`Failed to find program id for program id index ${e.programIdIndex}`);f.push(new TransactionInstruction({programId:n,data:toBuffer(e.data),keys:t}))}return new TransactionMessage({payerKey:l,instructions:f,recentBlockhash:s})}compileToLegacyMessage(){return Message.compile({payerKey:this.payerKey,recentBlockhash:this.recentBlockhash,instructions:this.instructions})}compileToV0Message(e){return MessageV0.compile({payerKey:this.payerKey,recentBlockhash:this.recentBlockhash,instructions:this.instructions,addressLookupTableAccounts:e})}}class VersionedTransaction{get version(){return this.message.version}constructor(e,t){if(this.signatures=void 0,this.message=void 0,void 0!==t)index_browser_esm_assert(t.length===e.header.numRequiredSignatures,"Expected signatures length to be equal to the number of required signatures"),this.signatures=t;else{const t=[];for(let r=0;r<e.header.numRequiredSignatures;r++)t.push(new Uint8Array(64));this.signatures=t}this.message=e}serialize(){const e=this.message.serialize(),t=Array();encodeLength(t,this.signatures.length);const r=ee.struct([ee.blob(t.length,"encodedSignaturesLength"),ee.seq(signature(),this.signatures.length,"signatures"),ee.blob(e.length,"serializedMessage")]),n=new Uint8Array(2048),s=r.encode({encodedSignaturesLength:new Uint8Array(t),signatures:this.signatures,serializedMessage:e},n);return n.slice(0,s)}static deserialize(e){let t=[...e];const r=[],n=decodeLength(t);for(let e=0;e<n;e++)r.push(new Uint8Array(guardedSplice(t,0,64)));const s=Te.deserialize(new Uint8Array(t));return new VersionedTransaction(s,r)}sign(e){const t=this.message.serialize(),r=this.message.staticAccountKeys.slice(0,this.message.header.numRequiredSignatures);for(const n of e){const e=r.findIndex((e=>e.equals(n.publicKey)));index_browser_esm_assert(e>=0,`Cannot sign with non signer key ${n.publicKey.toBase58()}`),this.signatures[e]=sign(t,n.secretKey)}}addSignature(e,t){index_browser_esm_assert(64===t.byteLength,"Signature must be 64 bytes long");const r=this.message.staticAccountKeys.slice(0,this.message.header.numRequiredSignatures).findIndex((t=>t.equals(e)));index_browser_esm_assert(r>=0,`Can not add signature; \`${e.toBase58()}\` is not required to sign this transaction`),this.signatures[r]=t}}const Ke=new PublicKey("SysvarC1ock11111111111111111111111111111111"),Ne=(new PublicKey("SysvarEpochSchedu1e111111111111111111111111"),new PublicKey("Sysvar1nstructions1111111111111111111111111")),We=new PublicKey("SysvarRecentB1ockHashes11111111111111111111"),Oe=new PublicKey("SysvarRent111111111111111111111111111111111"),Re=(new PublicKey("SysvarRewards111111111111111111111111111111"),new PublicKey("SysvarS1otHashes111111111111111111111111111"),new PublicKey("SysvarS1otHistory11111111111111111111111111"),new PublicKey("SysvarStakeHistory1111111111111111111111111"));async function sendAndConfirmTransaction(e,t,r,n){const s=n&&{skipPreflight:n.skipPreflight,preflightCommitment:n.preflightCommitment||n.commitment,maxRetries:n.maxRetries,minContextSlot:n.minContextSlot},i=await e.sendTransaction(t,r,s);let o;if(null!=t.recentBlockhash&&null!=t.lastValidBlockHeight)o=(await e.confirmTransaction({abortSignal:n?.abortSignal,signature:i,blockhash:t.recentBlockhash,lastValidBlockHeight:t.lastValidBlockHeight},n&&n.commitment)).value;else if(null!=t.minNonceContextSlot&&null!=t.nonceInfo){const{nonceInstruction:r}=t.nonceInfo,s=r.keys[0].pubkey;o=(await e.confirmTransaction({abortSignal:n?.abortSignal,minContextSlot:t.minNonceContextSlot,nonceAccountPubkey:s,nonceValue:t.nonceInfo.nonce,signature:i},n&&n.commitment)).value}else null!=n?.abortSignal&&console.warn("sendAndConfirmTransaction(): A transaction with a deprecated confirmation strategy was supplied along with an `abortSignal`. Only transactions having `lastValidBlockHeight` or a combination of `nonceInfo` and `minNonceContextSlot` are abortable."),o=(await e.confirmTransaction(i,n&&n.commitment)).value;if(o.err)throw new Error(`Transaction ${i} failed (${JSON.stringify(o)})`);return i}function sleep(e){return new Promise((t=>setTimeout(t,e)))}function encodeData(e,t){const r=e.layout.span>=0?e.layout.span:getAlloc(e,t),n=s.Buffer.alloc(r),i=Object.assign({instruction:e.index},t);return e.layout.encode(i,n),n}function decodeData$1(e,t){let r;try{r=e.layout.decode(t)}catch(e){throw new Error("invalid instruction; "+e)}if(r.instruction!==e.index)throw new Error(`invalid instruction; instruction index mismatch ${r.instruction} != ${e.index}`);return r}const ze=ee.nu64("lamportsPerSignature"),je=ee.struct([ee.u32("version"),ee.u32("state"),publicKey("authorizedPubkey"),publicKey("nonce"),ee.struct([ze],"feeCalculator")]),Ue=je.span;const qe=(Ce=8,e=>{const t=(0,ee.blob)(Ce,e),{encode:r,decode:n}=(e=>({decode:e.decode.bind(e),encode:e.encode.bind(e)}))(t),i=t;return i.decode=(e,t)=>{const r=n(e,t);return(0,te.toBigIntLE)(s.Buffer.from(r))},i.encode=(e,t,n)=>{const s=(0,te.toBufferLE)(e,Ce);return r(s,t,n)},i});var Ce;class SystemInstruction{constructor(){}static decodeInstructionType(e){this.checkProgramId(e.programId);const t=ee.u32("instruction").decode(e.data);let r;for(const[e,n]of Object.entries(De))if(n.index==t){r=e;break}if(!r)throw new Error("Instruction type incorrect; not a SystemInstruction");return r}static decodeCreateAccount(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{lamports:t,space:r,programId:n}=decodeData$1(De.Create,e.data);return{fromPubkey:e.keys[0].pubkey,newAccountPubkey:e.keys[1].pubkey,lamports:t,space:r,programId:new PublicKey(n)}}static decodeTransfer(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{lamports:t}=decodeData$1(De.Transfer,e.data);return{fromPubkey:e.keys[0].pubkey,toPubkey:e.keys[1].pubkey,lamports:t}}static decodeTransferWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{lamports:t,seed:r,programId:n}=decodeData$1(De.TransferWithSeed,e.data);return{fromPubkey:e.keys[0].pubkey,basePubkey:e.keys[1].pubkey,toPubkey:e.keys[2].pubkey,lamports:t,seed:r,programId:new PublicKey(n)}}static decodeAllocate(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,1);const{space:t}=decodeData$1(De.Allocate,e.data);return{accountPubkey:e.keys[0].pubkey,space:t}}static decodeAllocateWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,1);const{base:t,seed:r,space:n,programId:s}=decodeData$1(De.AllocateWithSeed,e.data);return{accountPubkey:e.keys[0].pubkey,basePubkey:new PublicKey(t),seed:r,space:n,programId:new PublicKey(s)}}static decodeAssign(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,1);const{programId:t}=decodeData$1(De.Assign,e.data);return{accountPubkey:e.keys[0].pubkey,programId:new PublicKey(t)}}static decodeAssignWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,1);const{base:t,seed:r,programId:n}=decodeData$1(De.AssignWithSeed,e.data);return{accountPubkey:e.keys[0].pubkey,basePubkey:new PublicKey(t),seed:r,programId:new PublicKey(n)}}static decodeCreateWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{base:t,seed:r,lamports:n,space:s,programId:i}=decodeData$1(De.CreateWithSeed,e.data);return{fromPubkey:e.keys[0].pubkey,newAccountPubkey:e.keys[1].pubkey,basePubkey:new PublicKey(t),seed:r,lamports:n,space:s,programId:new PublicKey(i)}}static decodeNonceInitialize(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{authorized:t}=decodeData$1(De.InitializeNonceAccount,e.data);return{noncePubkey:e.keys[0].pubkey,authorizedPubkey:new PublicKey(t)}}static decodeNonceAdvance(e){return this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3),decodeData$1(De.AdvanceNonceAccount,e.data),{noncePubkey:e.keys[0].pubkey,authorizedPubkey:e.keys[2].pubkey}}static decodeNonceWithdraw(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,5);const{lamports:t}=decodeData$1(De.WithdrawNonceAccount,e.data);return{noncePubkey:e.keys[0].pubkey,toPubkey:e.keys[1].pubkey,authorizedPubkey:e.keys[4].pubkey,lamports:t}}static decodeNonceAuthorize(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{authorized:t}=decodeData$1(De.AuthorizeNonceAccount,e.data);return{noncePubkey:e.keys[0].pubkey,authorizedPubkey:e.keys[1].pubkey,newAuthorizedPubkey:new PublicKey(t)}}static checkProgramId(e){if(!e.equals(SystemProgram.programId))throw new Error("invalid instruction; programId is not SystemProgram")}static checkKeyLength(e,t){if(e.length<t)throw new Error(`invalid instruction; found ${e.length} keys, expected at least ${t}`)}}const De=Object.freeze({Create:{index:0,layout:ee.struct([ee.u32("instruction"),ee.ns64("lamports"),ee.ns64("space"),publicKey("programId")])},Assign:{index:1,layout:ee.struct([ee.u32("instruction"),publicKey("programId")])},Transfer:{index:2,layout:ee.struct([ee.u32("instruction"),qe("lamports")])},CreateWithSeed:{index:3,layout:ee.struct([ee.u32("instruction"),publicKey("base"),rustString("seed"),ee.ns64("lamports"),ee.ns64("space"),publicKey("programId")])},AdvanceNonceAccount:{index:4,layout:ee.struct([ee.u32("instruction")])},WithdrawNonceAccount:{index:5,layout:ee.struct([ee.u32("instruction"),ee.ns64("lamports")])},InitializeNonceAccount:{index:6,layout:ee.struct([ee.u32("instruction"),publicKey("authorized")])},AuthorizeNonceAccount:{index:7,layout:ee.struct([ee.u32("instruction"),publicKey("authorized")])},Allocate:{index:8,layout:ee.struct([ee.u32("instruction"),ee.ns64("space")])},AllocateWithSeed:{index:9,layout:ee.struct([ee.u32("instruction"),publicKey("base"),rustString("seed"),ee.ns64("space"),publicKey("programId")])},AssignWithSeed:{index:10,layout:ee.struct([ee.u32("instruction"),publicKey("base"),rustString("seed"),publicKey("programId")])},TransferWithSeed:{index:11,layout:ee.struct([ee.u32("instruction"),qe("lamports"),rustString("seed"),publicKey("programId")])},UpgradeNonceAccount:{index:12,layout:ee.struct([ee.u32("instruction")])}});class SystemProgram{constructor(){}static createAccount(e){const t=encodeData(De.Create,{lamports:e.lamports,space:e.space,programId:toBuffer(e.programId.toBuffer())});return new TransactionInstruction({keys:[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.newAccountPubkey,isSigner:!0,isWritable:!0}],programId:this.programId,data:t})}static transfer(e){let t,r;if("basePubkey"in e){t=encodeData(De.TransferWithSeed,{lamports:BigInt(e.lamports),seed:e.seed,programId:toBuffer(e.programId.toBuffer())}),r=[{pubkey:e.fromPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0}]}else{t=encodeData(De.Transfer,{lamports:BigInt(e.lamports)}),r=[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0}]}return new TransactionInstruction({keys:r,programId:this.programId,data:t})}static assign(e){let t,r;if("basePubkey"in e){t=encodeData(De.AssignWithSeed,{base:toBuffer(e.basePubkey.toBuffer()),seed:e.seed,programId:toBuffer(e.programId.toBuffer())}),r=[{pubkey:e.accountPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1}]}else{t=encodeData(De.Assign,{programId:toBuffer(e.programId.toBuffer())}),r=[{pubkey:e.accountPubkey,isSigner:!0,isWritable:!0}]}return new TransactionInstruction({keys:r,programId:this.programId,data:t})}static createAccountWithSeed(e){const t=encodeData(De.CreateWithSeed,{base:toBuffer(e.basePubkey.toBuffer()),seed:e.seed,lamports:e.lamports,space:e.space,programId:toBuffer(e.programId.toBuffer())});let r=[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.newAccountPubkey,isSigner:!1,isWritable:!0}];return e.basePubkey!=e.fromPubkey&&r.push({pubkey:e.basePubkey,isSigner:!0,isWritable:!1}),new TransactionInstruction({keys:r,programId:this.programId,data:t})}static createNonceAccount(e){const t=new Transaction;"basePubkey"in e&&"seed"in e?t.add(SystemProgram.createAccountWithSeed({fromPubkey:e.fromPubkey,newAccountPubkey:e.noncePubkey,basePubkey:e.basePubkey,seed:e.seed,lamports:e.lamports,space:Ue,programId:this.programId})):t.add(SystemProgram.createAccount({fromPubkey:e.fromPubkey,newAccountPubkey:e.noncePubkey,lamports:e.lamports,space:Ue,programId:this.programId}));const r={noncePubkey:e.noncePubkey,authorizedPubkey:e.authorizedPubkey};return t.add(this.nonceInitialize(r)),t}static nonceInitialize(e){const t=encodeData(De.InitializeNonceAccount,{authorized:toBuffer(e.authorizedPubkey.toBuffer())}),r={keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:We,isSigner:!1,isWritable:!1},{pubkey:Oe,isSigner:!1,isWritable:!1}],programId:this.programId,data:t};return new TransactionInstruction(r)}static nonceAdvance(e){const t=encodeData(De.AdvanceNonceAccount),r={keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:We,isSigner:!1,isWritable:!1},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:t};return new TransactionInstruction(r)}static nonceWithdraw(e){const t=encodeData(De.WithdrawNonceAccount,{lamports:e.lamports});return new TransactionInstruction({keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0},{pubkey:We,isSigner:!1,isWritable:!1},{pubkey:Oe,isSigner:!1,isWritable:!1},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:t})}static nonceAuthorize(e){const t=encodeData(De.AuthorizeNonceAccount,{authorized:toBuffer(e.newAuthorizedPubkey.toBuffer())});return new TransactionInstruction({keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:t})}static allocate(e){let t,r;if("basePubkey"in e){t=encodeData(De.AllocateWithSeed,{base:toBuffer(e.basePubkey.toBuffer()),seed:e.seed,space:e.space,programId:toBuffer(e.programId.toBuffer())}),r=[{pubkey:e.accountPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1}]}else{t=encodeData(De.Allocate,{space:e.space}),r=[{pubkey:e.accountPubkey,isSigner:!0,isWritable:!0}]}return new TransactionInstruction({keys:r,programId:this.programId,data:t})}}SystemProgram.programId=new PublicKey("11111111111111111111111111111111");class Loader{constructor(){}static getMinNumSignatures(e){return 2*(Math.ceil(e/Loader.chunkSize)+1+1)}static async load(e,t,r,n,i){{const s=await e.getMinimumBalanceForRentExemption(i.length),o=await e.getAccountInfo(r.publicKey,"confirmed");let a=null;if(null!==o){if(o.executable)return console.error("Program load failed, account is already executable"),!1;o.data.length!==i.length&&(a=a||new Transaction,a.add(SystemProgram.allocate({accountPubkey:r.publicKey,space:i.length}))),o.owner.equals(n)||(a=a||new Transaction,a.add(SystemProgram.assign({accountPubkey:r.publicKey,programId:n}))),o.lamports<s&&(a=a||new Transaction,a.add(SystemProgram.transfer({fromPubkey:t.publicKey,toPubkey:r.publicKey,lamports:s-o.lamports})))}else a=(new Transaction).add(SystemProgram.createAccount({fromPubkey:t.publicKey,newAccountPubkey:r.publicKey,lamports:s>0?s:1,space:i.length,programId:n}));null!==a&&await sendAndConfirmTransaction(e,a,[t,r],{commitment:"confirmed"})}const o=ee.struct([ee.u32("instruction"),ee.u32("offset"),ee.u32("bytesLength"),ee.u32("bytesLengthPadding"),ee.seq(ee.u8("byte"),ee.offset(ee.u32(),-8),"bytes")]),a=Loader.chunkSize;let u=0,c=i,d=[];for(;c.length>0;){const i=c.slice(0,a),l=s.Buffer.alloc(a+16);o.encode({instruction:0,offset:u,bytes:i,bytesLength:0,bytesLengthPadding:0},l);const f=(new Transaction).add({keys:[{pubkey:r.publicKey,isSigner:!0,isWritable:!0}],programId:n,data:l});if(d.push(sendAndConfirmTransaction(e,f,[t,r],{commitment:"confirmed"})),e._rpcEndpoint.includes("solana.com")){const e=4;await sleep(1e3/e)}u+=a,c=c.slice(a)}await Promise.all(d);{const i=ee.struct([ee.u32("instruction")]),o=s.Buffer.alloc(i.span);i.encode({instruction:1},o);const a=(new Transaction).add({keys:[{pubkey:r.publicKey,isSigner:!0,isWritable:!0},{pubkey:Oe,isSigner:!1,isWritable:!1}],programId:n,data:o}),u="processed",c=await e.sendTransaction(a,[t,r],{preflightCommitment:u}),{context:d,value:l}=await e.confirmTransaction({signature:c,lastValidBlockHeight:a.lastValidBlockHeight,blockhash:a.recentBlockhash},u);if(l.err)throw new Error(`Transaction ${c} failed (${JSON.stringify(l)})`);for(;;){try{if(await e.getSlot({commitment:u})>d.slot)break}catch{}await new Promise((e=>setTimeout(e,Math.round(200))))}}return!0}}Loader.chunkSize=932;new PublicKey("BPFLoader2111111111111111111111111111111111");Object.prototype.toString,Object.keys;Error;Error;globalThis.fetch;ne.default;class AddressLookupTableAccount{constructor(e){this.key=void 0,this.state=void 0,this.key=e.key,this.state=e.state}isActive(){const e=BigInt("0xffffffffffffffff");return this.state.deactivationSlot===e}static deserialize(e){const t=function decodeData(e,t){let r;try{r=e.layout.decode(t)}catch(e){throw new Error("invalid instruction; "+e)}if(r.typeIndex!==e.index)throw new Error(`invalid account data; account type mismatch ${r.typeIndex} != ${e.index}`);return r}(Ye,e),r=e.length-56;index_browser_esm_assert(r>=0,"lookup table is invalid"),index_browser_esm_assert(r%32==0,"lookup table is invalid");const n=r/32,{addresses:s}=ee.struct([ee.seq(publicKey(),n,"addresses")]).decode(e.slice(56));return{deactivationSlot:t.deactivationSlot,lastExtendedSlot:t.lastExtendedSlot,lastExtendedSlotStartIndex:t.lastExtendedStartIndex,authority:0!==t.authority.length?new PublicKey(t.authority[0]):void 0,addresses:s.map((e=>new PublicKey(e)))}}}const Ye={index:1,layout:ee.struct([ee.u32("typeIndex"),qe("deactivationSlot"),ee.nu64("lastExtendedSlot"),ee.u8("lastExtendedStartIndex"),ee.u8(),ee.seq(publicKey(),ee.offset(ee.u8(),-1),"authority")])};const Fe=(0,re.au)((0,re.KJ)(PublicKey),(0,re.Yj)(),(e=>new PublicKey(e))),He=(0,re.PV)([(0,re.Yj)(),(0,re.eu)("base64")]),Me=(0,re.au)((0,re.KJ)(s.Buffer),He,(e=>s.Buffer.from(e[0],"base64")));function createRpcResult(e){return(0,re.KC)([(0,re.NW)({jsonrpc:(0,re.eu)("2.0"),id:(0,re.Yj)(),result:e}),(0,re.NW)({jsonrpc:(0,re.eu)("2.0"),id:(0,re.Yj)(),error:(0,re.NW)({code:(0,re.L5)(),message:(0,re.Yj)(),data:(0,re.lq)((0,re.bz)())})})])}const Ve=createRpcResult((0,re.L5)());function jsonRpcResult(e){return(0,re.au)(createRpcResult(e),Ve,(t=>"error"in t?t:{...t,result:(0,re.vt)(t.result,e)}))}function jsonRpcResultAndContext(e){return jsonRpcResult((0,re.NW)({context:(0,re.NW)({slot:(0,re.ai)()}),value:e}))}function notificationResultAndContext(e){return(0,re.NW)({context:(0,re.NW)({slot:(0,re.ai)()}),value:e})}const $e=(0,re.NW)({foundation:(0,re.ai)(),foundationTerm:(0,re.ai)(),initial:(0,re.ai)(),taper:(0,re.ai)(),terminal:(0,re.ai)()}),Ge=(jsonRpcResult((0,re.YO)((0,re.me)((0,re.NW)({epoch:(0,re.ai)(),effectiveSlot:(0,re.ai)(),amount:(0,re.ai)(),postBalance:(0,re.ai)(),commission:(0,re.lq)((0,re.me)((0,re.ai)()))})))),(0,re.YO)((0,re.NW)({slot:(0,re.ai)(),prioritizationFee:(0,re.ai)()}))),Ze=(0,re.NW)({total:(0,re.ai)(),validator:(0,re.ai)(),foundation:(0,re.ai)(),epoch:(0,re.ai)()}),Je=(0,re.NW)({epoch:(0,re.ai)(),slotIndex:(0,re.ai)(),slotsInEpoch:(0,re.ai)(),absoluteSlot:(0,re.ai)(),blockHeight:(0,re.lq)((0,re.ai)()),transactionCount:(0,re.lq)((0,re.ai)())}),Xe=(0,re.NW)({slotsPerEpoch:(0,re.ai)(),leaderScheduleSlotOffset:(0,re.ai)(),warmup:(0,re.zM)(),firstNormalEpoch:(0,re.ai)(),firstNormalSlot:(0,re.ai)()}),Qe=(0,re.g1)((0,re.Yj)(),(0,re.YO)((0,re.ai)())),et=(0,re.me)((0,re.KC)([(0,re.NW)({}),(0,re.Yj)()])),tt=(0,re.NW)({err:et}),rt=(0,re.eu)("receivedSignature");(0,re.NW)({"solana-core":(0,re.Yj)(),"feature-set":(0,re.lq)((0,re.ai)())}),jsonRpcResultAndContext((0,re.NW)({err:(0,re.me)((0,re.KC)([(0,re.NW)({}),(0,re.Yj)()])),logs:(0,re.me)((0,re.YO)((0,re.Yj)())),accounts:(0,re.lq)((0,re.me)((0,re.YO)((0,re.me)((0,re.NW)({executable:(0,re.zM)(),owner:(0,re.Yj)(),lamports:(0,re.ai)(),data:(0,re.YO)((0,re.Yj)()),rentEpoch:(0,re.lq)((0,re.ai)())}))))),unitsConsumed:(0,re.lq)((0,re.ai)()),returnData:(0,re.lq)((0,re.me)((0,re.NW)({programId:(0,re.Yj)(),data:(0,re.PV)([(0,re.Yj)(),(0,re.eu)("base64")])})))})),jsonRpcResultAndContext((0,re.NW)({byIdentity:(0,re.g1)((0,re.Yj)(),(0,re.YO)((0,re.ai)())),range:(0,re.NW)({firstSlot:(0,re.ai)(),lastSlot:(0,re.ai)()})}));jsonRpcResult($e),jsonRpcResult(Ze),jsonRpcResult(Ge),jsonRpcResult(Je),jsonRpcResult(Xe),jsonRpcResult(Qe),jsonRpcResult((0,re.ai)()),jsonRpcResultAndContext((0,re.NW)({total:(0,re.ai)(),circulating:(0,re.ai)(),nonCirculating:(0,re.ai)(),nonCirculatingAccounts:(0,re.YO)(Fe)}));const nt=(0,re.NW)({amount:(0,re.Yj)(),uiAmount:(0,re.me)((0,re.ai)()),decimals:(0,re.ai)(),uiAmountString:(0,re.lq)((0,re.Yj)())}),st=(jsonRpcResultAndContext((0,re.YO)((0,re.NW)({address:Fe,amount:(0,re.Yj)(),uiAmount:(0,re.me)((0,re.ai)()),decimals:(0,re.ai)(),uiAmountString:(0,re.lq)((0,re.Yj)())}))),jsonRpcResultAndContext((0,re.YO)((0,re.NW)({pubkey:Fe,account:(0,re.NW)({executable:(0,re.zM)(),owner:Fe,lamports:(0,re.ai)(),data:Me,rentEpoch:(0,re.ai)()})}))),(0,re.NW)({program:(0,re.Yj)(),parsed:(0,re.L5)(),space:(0,re.ai)()})),it=(jsonRpcResultAndContext((0,re.YO)((0,re.NW)({pubkey:Fe,account:(0,re.NW)({executable:(0,re.zM)(),owner:Fe,lamports:(0,re.ai)(),data:st,rentEpoch:(0,re.ai)()})}))),jsonRpcResultAndContext((0,re.YO)((0,re.NW)({lamports:(0,re.ai)(),address:Fe}))),(0,re.NW)({executable:(0,re.zM)(),owner:Fe,lamports:(0,re.ai)(),data:Me,rentEpoch:(0,re.ai)()})),ot=((0,re.NW)({pubkey:Fe,account:it}),(0,re.au)((0,re.KC)([(0,re.KJ)(s.Buffer),st]),(0,re.KC)([He,st]),(e=>Array.isArray(e)?(0,re.vt)(e,Me):e))),at=(0,re.NW)({executable:(0,re.zM)(),owner:Fe,lamports:(0,re.ai)(),data:ot,rentEpoch:(0,re.ai)()}),ut=((0,re.NW)({pubkey:Fe,account:at}),(0,re.NW)({state:(0,re.KC)([(0,re.eu)("active"),(0,re.eu)("inactive"),(0,re.eu)("activating"),(0,re.eu)("deactivating")]),active:(0,re.ai)(),inactive:(0,re.ai)()}),jsonRpcResult((0,re.YO)((0,re.NW)({signature:(0,re.Yj)(),slot:(0,re.ai)(),err:et,memo:(0,re.me)((0,re.Yj)()),blockTime:(0,re.lq)((0,re.me)((0,re.ai)()))}))),jsonRpcResult((0,re.YO)((0,re.NW)({signature:(0,re.Yj)(),slot:(0,re.ai)(),err:et,memo:(0,re.me)((0,re.Yj)()),blockTime:(0,re.lq)((0,re.me)((0,re.ai)()))}))),(0,re.NW)({subscription:(0,re.ai)(),result:notificationResultAndContext(it)}),(0,re.NW)({pubkey:Fe,account:it})),ct=((0,re.NW)({subscription:(0,re.ai)(),result:notificationResultAndContext(ut)}),(0,re.NW)({parent:(0,re.ai)(),slot:(0,re.ai)(),root:(0,re.ai)()})),dt=((0,re.NW)({subscription:(0,re.ai)(),result:ct}),(0,re.KC)([(0,re.NW)({type:(0,re.KC)([(0,re.eu)("firstShredReceived"),(0,re.eu)("completed"),(0,re.eu)("optimisticConfirmation"),(0,re.eu)("root")]),slot:(0,re.ai)(),timestamp:(0,re.ai)()}),(0,re.NW)({type:(0,re.eu)("createdBank"),parent:(0,re.ai)(),slot:(0,re.ai)(),timestamp:(0,re.ai)()}),(0,re.NW)({type:(0,re.eu)("frozen"),slot:(0,re.ai)(),timestamp:(0,re.ai)(),stats:(0,re.NW)({numTransactionEntries:(0,re.ai)(),numSuccessfulTransactions:(0,re.ai)(),numFailedTransactions:(0,re.ai)(),maxTransactionsPerEntry:(0,re.ai)()})}),(0,re.NW)({type:(0,re.eu)("dead"),slot:(0,re.ai)(),timestamp:(0,re.ai)(),err:(0,re.Yj)()})])),lt=((0,re.NW)({subscription:(0,re.ai)(),result:dt}),(0,re.NW)({subscription:(0,re.ai)(),result:notificationResultAndContext((0,re.KC)([tt,rt]))}),(0,re.NW)({subscription:(0,re.ai)(),result:(0,re.ai)()}),(0,re.NW)({pubkey:(0,re.Yj)(),gossip:(0,re.me)((0,re.Yj)()),tpu:(0,re.me)((0,re.Yj)()),rpc:(0,re.me)((0,re.Yj)()),version:(0,re.me)((0,re.Yj)())}),(0,re.NW)({votePubkey:(0,re.Yj)(),nodePubkey:(0,re.Yj)(),activatedStake:(0,re.ai)(),epochVoteAccount:(0,re.zM)(),epochCredits:(0,re.YO)((0,re.PV)([(0,re.ai)(),(0,re.ai)(),(0,re.ai)()])),commission:(0,re.ai)(),lastVote:(0,re.ai)(),rootSlot:(0,re.me)((0,re.ai)())})),ht=(jsonRpcResult((0,re.NW)({current:(0,re.YO)(lt),delinquent:(0,re.YO)(lt)})),(0,re.KC)([(0,re.eu)("processed"),(0,re.eu)("confirmed"),(0,re.eu)("finalized")])),ft=(0,re.NW)({slot:(0,re.ai)(),confirmations:(0,re.me)((0,re.ai)()),err:et,confirmationStatus:(0,re.lq)(ht)}),yt=(jsonRpcResultAndContext((0,re.YO)((0,re.me)(ft))),jsonRpcResult((0,re.ai)()),(0,re.NW)({accountKey:Fe,writableIndexes:(0,re.YO)((0,re.ai)()),readonlyIndexes:(0,re.YO)((0,re.ai)())})),pt=(0,re.NW)({signatures:(0,re.YO)((0,re.Yj)()),message:(0,re.NW)({accountKeys:(0,re.YO)((0,re.Yj)()),header:(0,re.NW)({numRequiredSignatures:(0,re.ai)(),numReadonlySignedAccounts:(0,re.ai)(),numReadonlyUnsignedAccounts:(0,re.ai)()}),instructions:(0,re.YO)((0,re.NW)({accounts:(0,re.YO)((0,re.ai)()),data:(0,re.Yj)(),programIdIndex:(0,re.ai)()})),recentBlockhash:(0,re.Yj)(),addressTableLookups:(0,re.lq)((0,re.YO)(yt))})}),gt=(0,re.NW)({pubkey:Fe,signer:(0,re.zM)(),writable:(0,re.zM)(),source:(0,re.lq)((0,re.KC)([(0,re.eu)("transaction"),(0,re.eu)("lookupTable")]))}),bt=(0,re.NW)({accountKeys:(0,re.YO)(gt),signatures:(0,re.YO)((0,re.Yj)())}),mt=(0,re.NW)({parsed:(0,re.L5)(),program:(0,re.Yj)(),programId:Fe}),wt=(0,re.NW)({accounts:(0,re.YO)(Fe),data:(0,re.Yj)(),programId:Fe}),kt=(0,re.KC)([wt,mt]),It=(0,re.KC)([(0,re.NW)({parsed:(0,re.L5)(),program:(0,re.Yj)(),programId:(0,re.Yj)()}),(0,re.NW)({accounts:(0,re.YO)((0,re.Yj)()),data:(0,re.Yj)(),programId:(0,re.Yj)()})]),Bt=(0,re.au)(kt,It,(e=>"accounts"in e?(0,re.vt)(e,wt):(0,re.vt)(e,mt))),St=(0,re.NW)({signatures:(0,re.YO)((0,re.Yj)()),message:(0,re.NW)({accountKeys:(0,re.YO)(gt),instructions:(0,re.YO)(Bt),recentBlockhash:(0,re.Yj)(),addressTableLookups:(0,re.lq)((0,re.me)((0,re.YO)(yt)))})}),xt=(0,re.NW)({accountIndex:(0,re.ai)(),mint:(0,re.Yj)(),owner:(0,re.lq)((0,re.Yj)()),uiTokenAmount:nt}),Et=(0,re.NW)({writable:(0,re.YO)(Fe),readonly:(0,re.YO)(Fe)}),vt=(0,re.NW)({err:et,fee:(0,re.ai)(),innerInstructions:(0,re.lq)((0,re.me)((0,re.YO)((0,re.NW)({index:(0,re.ai)(),instructions:(0,re.YO)((0,re.NW)({accounts:(0,re.YO)((0,re.ai)()),data:(0,re.Yj)(),programIdIndex:(0,re.ai)()}))})))),preBalances:(0,re.YO)((0,re.ai)()),postBalances:(0,re.YO)((0,re.ai)()),logMessages:(0,re.lq)((0,re.me)((0,re.YO)((0,re.Yj)()))),preTokenBalances:(0,re.lq)((0,re.me)((0,re.YO)(xt))),postTokenBalances:(0,re.lq)((0,re.me)((0,re.YO)(xt))),loadedAddresses:(0,re.lq)(Et),computeUnitsConsumed:(0,re.lq)((0,re.ai)())}),Pt=(0,re.NW)({err:et,fee:(0,re.ai)(),innerInstructions:(0,re.lq)((0,re.me)((0,re.YO)((0,re.NW)({index:(0,re.ai)(),instructions:(0,re.YO)(Bt)})))),preBalances:(0,re.YO)((0,re.ai)()),postBalances:(0,re.YO)((0,re.ai)()),logMessages:(0,re.lq)((0,re.me)((0,re.YO)((0,re.Yj)()))),preTokenBalances:(0,re.lq)((0,re.me)((0,re.YO)(xt))),postTokenBalances:(0,re.lq)((0,re.me)((0,re.YO)(xt))),loadedAddresses:(0,re.lq)(Et),computeUnitsConsumed:(0,re.lq)((0,re.ai)())}),At=(0,re.KC)([(0,re.eu)(0),(0,re.eu)("legacy")]),Lt=(0,re.NW)({pubkey:(0,re.Yj)(),lamports:(0,re.ai)(),postBalance:(0,re.me)((0,re.ai)()),rewardType:(0,re.me)((0,re.Yj)()),commission:(0,re.lq)((0,re.me)((0,re.ai)()))}),Tt=(jsonRpcResult((0,re.me)((0,re.NW)({blockhash:(0,re.Yj)(),previousBlockhash:(0,re.Yj)(),parentSlot:(0,re.ai)(),transactions:(0,re.YO)((0,re.NW)({transaction:pt,meta:(0,re.me)(vt),version:(0,re.lq)(At)})),rewards:(0,re.lq)((0,re.YO)(Lt)),blockTime:(0,re.me)((0,re.ai)()),blockHeight:(0,re.me)((0,re.ai)())}))),jsonRpcResult((0,re.me)((0,re.NW)({blockhash:(0,re.Yj)(),previousBlockhash:(0,re.Yj)(),parentSlot:(0,re.ai)(),rewards:(0,re.lq)((0,re.YO)(Lt)),blockTime:(0,re.me)((0,re.ai)()),blockHeight:(0,re.me)((0,re.ai)())}))),jsonRpcResult((0,re.me)((0,re.NW)({blockhash:(0,re.Yj)(),previousBlockhash:(0,re.Yj)(),parentSlot:(0,re.ai)(),transactions:(0,re.YO)((0,re.NW)({transaction:bt,meta:(0,re.me)(vt),version:(0,re.lq)(At)})),rewards:(0,re.lq)((0,re.YO)(Lt)),blockTime:(0,re.me)((0,re.ai)()),blockHeight:(0,re.me)((0,re.ai)())}))),jsonRpcResult((0,re.me)((0,re.NW)({blockhash:(0,re.Yj)(),previousBlockhash:(0,re.Yj)(),parentSlot:(0,re.ai)(),transactions:(0,re.YO)((0,re.NW)({transaction:St,meta:(0,re.me)(Pt),version:(0,re.lq)(At)})),rewards:(0,re.lq)((0,re.YO)(Lt)),blockTime:(0,re.me)((0,re.ai)()),blockHeight:(0,re.me)((0,re.ai)())}))),jsonRpcResult((0,re.me)((0,re.NW)({blockhash:(0,re.Yj)(),previousBlockhash:(0,re.Yj)(),parentSlot:(0,re.ai)(),transactions:(0,re.YO)((0,re.NW)({transaction:bt,meta:(0,re.me)(Pt),version:(0,re.lq)(At)})),rewards:(0,re.lq)((0,re.YO)(Lt)),blockTime:(0,re.me)((0,re.ai)()),blockHeight:(0,re.me)((0,re.ai)())}))),jsonRpcResult((0,re.me)((0,re.NW)({blockhash:(0,re.Yj)(),previousBlockhash:(0,re.Yj)(),parentSlot:(0,re.ai)(),rewards:(0,re.lq)((0,re.YO)(Lt)),blockTime:(0,re.me)((0,re.ai)()),blockHeight:(0,re.me)((0,re.ai)())}))),jsonRpcResult((0,re.me)((0,re.NW)({blockhash:(0,re.Yj)(),previousBlockhash:(0,re.Yj)(),parentSlot:(0,re.ai)(),transactions:(0,re.YO)((0,re.NW)({transaction:pt,meta:(0,re.me)(vt)})),rewards:(0,re.lq)((0,re.YO)(Lt)),blockTime:(0,re.me)((0,re.ai)())}))),jsonRpcResult((0,re.me)((0,re.NW)({blockhash:(0,re.Yj)(),previousBlockhash:(0,re.Yj)(),parentSlot:(0,re.ai)(),signatures:(0,re.YO)((0,re.Yj)()),blockTime:(0,re.me)((0,re.ai)())}))),jsonRpcResult((0,re.me)((0,re.NW)({slot:(0,re.ai)(),meta:(0,re.me)(vt),blockTime:(0,re.lq)((0,re.me)((0,re.ai)())),transaction:pt,version:(0,re.lq)(At)}))),jsonRpcResult((0,re.me)((0,re.NW)({slot:(0,re.ai)(),transaction:St,meta:(0,re.me)(Pt),blockTime:(0,re.lq)((0,re.me)((0,re.ai)())),version:(0,re.lq)(At)}))),jsonRpcResultAndContext((0,re.NW)({blockhash:(0,re.Yj)(),feeCalculator:(0,re.NW)({lamportsPerSignature:(0,re.ai)()})})),jsonRpcResultAndContext((0,re.NW)({blockhash:(0,re.Yj)(),lastValidBlockHeight:(0,re.ai)()})),jsonRpcResultAndContext((0,re.zM)()),(0,re.NW)({slot:(0,re.ai)(),numTransactions:(0,re.ai)(),numSlots:(0,re.ai)(),samplePeriodSecs:(0,re.ai)()})),_t=(jsonRpcResult((0,re.YO)(Tt)),jsonRpcResultAndContext((0,re.me)((0,re.NW)({feeCalculator:(0,re.NW)({lamportsPerSignature:(0,re.ai)()})}))),jsonRpcResult((0,re.Yj)()),jsonRpcResult((0,re.Yj)()),(0,re.NW)({err:et,logs:(0,re.YO)((0,re.Yj)()),signature:(0,re.Yj)()}));(0,re.NW)({result:notificationResultAndContext(_t),subscription:(0,re.ai)()});class Keypair{constructor(e){this._keypair=void 0,this._keypair=e??generateKeypair()}static generate(){return new Keypair(generateKeypair())}static fromSecretKey(e,t){if(64!==e.byteLength)throw new Error("bad secret key size");const r=e.slice(32,64);if(!t||!t.skipValidation){const t=e.slice(0,32),n=Ie(t);for(let e=0;e<32;e++)if(r[e]!==n[e])throw new Error("provided secretKey is invalid")}return new Keypair({publicKey:r,secretKey:e})}static fromSeed(e){const t=Ie(e),r=new Uint8Array(64);return r.set(e),r.set(t,32),new Keypair({publicKey:t,secretKey:r})}get publicKey(){return new PublicKey(this._keypair.publicKey)}get secretKey(){return new Uint8Array(this._keypair.secretKey)}}const Kt=Object.freeze({CreateLookupTable:{index:0,layout:ee.struct([ee.u32("instruction"),qe("recentSlot"),ee.u8("bumpSeed")])},FreezeLookupTable:{index:1,layout:ee.struct([ee.u32("instruction")])},ExtendLookupTable:{index:2,layout:ee.struct([ee.u32("instruction"),qe(),ee.seq(publicKey(),ee.offset(ee.u32(),-8),"addresses")])},DeactivateLookupTable:{index:3,layout:ee.struct([ee.u32("instruction")])},CloseLookupTable:{index:4,layout:ee.struct([ee.u32("instruction")])}});class AddressLookupTableProgram{constructor(){}static createLookupTable(e){const[t,r]=PublicKey.findProgramAddressSync([e.authority.toBuffer(),(0,te.toBufferLE)(BigInt(e.recentSlot),8)],this.programId),n=encodeData(Kt.CreateLookupTable,{recentSlot:BigInt(e.recentSlot),bumpSeed:r}),s=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1},{pubkey:e.payer,isSigner:!0,isWritable:!0},{pubkey:SystemProgram.programId,isSigner:!1,isWritable:!1}];return[new TransactionInstruction({programId:this.programId,keys:s,data:n}),t]}static freezeLookupTable(e){const t=encodeData(Kt.FreezeLookupTable),r=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1}];return new TransactionInstruction({programId:this.programId,keys:r,data:t})}static extendLookupTable(e){const t=encodeData(Kt.ExtendLookupTable,{addresses:e.addresses.map((e=>e.toBytes()))}),r=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1}];return e.payer&&r.push({pubkey:e.payer,isSigner:!0,isWritable:!0},{pubkey:SystemProgram.programId,isSigner:!1,isWritable:!1}),new TransactionInstruction({programId:this.programId,keys:r,data:t})}static deactivateLookupTable(e){const t=encodeData(Kt.DeactivateLookupTable),r=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1}];return new TransactionInstruction({programId:this.programId,keys:r,data:t})}static closeLookupTable(e){const t=encodeData(Kt.CloseLookupTable),r=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1},{pubkey:e.recipient,isSigner:!1,isWritable:!0}];return new TransactionInstruction({programId:this.programId,keys:r,data:t})}}AddressLookupTableProgram.programId=new PublicKey("AddressLookupTab1e1111111111111111111111111");class ComputeBudgetInstruction{constructor(){}static decodeInstructionType(e){this.checkProgramId(e.programId);const t=ee.u8("instruction").decode(e.data);let r;for(const[e,n]of Object.entries(Nt))if(n.index==t){r=e;break}if(!r)throw new Error("Instruction type incorrect; not a ComputeBudgetInstruction");return r}static decodeRequestUnits(e){this.checkProgramId(e.programId);const{units:t,additionalFee:r}=decodeData$1(Nt.RequestUnits,e.data);return{units:t,additionalFee:r}}static decodeRequestHeapFrame(e){this.checkProgramId(e.programId);const{bytes:t}=decodeData$1(Nt.RequestHeapFrame,e.data);return{bytes:t}}static decodeSetComputeUnitLimit(e){this.checkProgramId(e.programId);const{units:t}=decodeData$1(Nt.SetComputeUnitLimit,e.data);return{units:t}}static decodeSetComputeUnitPrice(e){this.checkProgramId(e.programId);const{microLamports:t}=decodeData$1(Nt.SetComputeUnitPrice,e.data);return{microLamports:t}}static checkProgramId(e){if(!e.equals(ComputeBudgetProgram.programId))throw new Error("invalid instruction; programId is not ComputeBudgetProgram")}}const Nt=Object.freeze({RequestUnits:{index:0,layout:ee.struct([ee.u8("instruction"),ee.u32("units"),ee.u32("additionalFee")])},RequestHeapFrame:{index:1,layout:ee.struct([ee.u8("instruction"),ee.u32("bytes")])},SetComputeUnitLimit:{index:2,layout:ee.struct([ee.u8("instruction"),ee.u32("units")])},SetComputeUnitPrice:{index:3,layout:ee.struct([ee.u8("instruction"),qe("microLamports")])}});class ComputeBudgetProgram{constructor(){}static requestUnits(e){const t=encodeData(Nt.RequestUnits,e);return new TransactionInstruction({keys:[],programId:this.programId,data:t})}static requestHeapFrame(e){const t=encodeData(Nt.RequestHeapFrame,e);return new TransactionInstruction({keys:[],programId:this.programId,data:t})}static setComputeUnitLimit(e){const t=encodeData(Nt.SetComputeUnitLimit,e);return new TransactionInstruction({keys:[],programId:this.programId,data:t})}static setComputeUnitPrice(e){const t=encodeData(Nt.SetComputeUnitPrice,{microLamports:BigInt(e.microLamports)});return new TransactionInstruction({keys:[],programId:this.programId,data:t})}}ComputeBudgetProgram.programId=new PublicKey("ComputeBudget111111111111111111111111111111");const Wt=ee.struct([ee.u8("numSignatures"),ee.u8("padding"),ee.u16("signatureOffset"),ee.u16("signatureInstructionIndex"),ee.u16("publicKeyOffset"),ee.u16("publicKeyInstructionIndex"),ee.u16("messageDataOffset"),ee.u16("messageDataSize"),ee.u16("messageInstructionIndex")]);class Ed25519Program{constructor(){}static createInstructionWithPublicKey(e){const{publicKey:t,message:r,signature:n,instructionIndex:i}=e;index_browser_esm_assert(32===t.length,`Public Key must be 32 bytes but received ${t.length} bytes`),index_browser_esm_assert(64===n.length,`Signature must be 64 bytes but received ${n.length} bytes`);const o=Wt.span,a=o+t.length,u=a+n.length,c=s.Buffer.alloc(u+r.length),d=null==i?65535:i;return Wt.encode({numSignatures:1,padding:0,signatureOffset:a,signatureInstructionIndex:d,publicKeyOffset:o,publicKeyInstructionIndex:d,messageDataOffset:u,messageDataSize:r.length,messageInstructionIndex:d},c),c.fill(t,o),c.fill(n,a),c.fill(r,u),new TransactionInstruction({keys:[],programId:Ed25519Program.programId,data:c})}static createInstructionWithPrivateKey(e){const{privateKey:t,message:r,instructionIndex:n}=e;index_browser_esm_assert(64===t.length,`Private key must be 64 bytes but received ${t.length} bytes`);try{const e=Keypair.fromSecretKey(t),s=e.publicKey.toBytes(),i=sign(r,e.secretKey);return this.createInstructionWithPublicKey({publicKey:s,message:r,signature:i,instructionIndex:n})}catch(e){throw new Error(`Error creating instruction; ${e}`)}}}Ed25519Program.programId=new PublicKey("Ed25519SigVerify111111111111111111111111111");ke.utils.isValidPrivateKey;const Ot=ke.getPublicKey,Rt=ee.struct([ee.u8("numSignatures"),ee.u16("signatureOffset"),ee.u8("signatureInstructionIndex"),ee.u16("ethAddressOffset"),ee.u8("ethAddressInstructionIndex"),ee.u16("messageDataOffset"),ee.u16("messageDataSize"),ee.u8("messageInstructionIndex"),ee.blob(20,"ethAddress"),ee.blob(64,"signature"),ee.u8("recoveryId")]);class Secp256k1Program{constructor(){}static publicKeyToEthAddress(e){index_browser_esm_assert(64===e.length,`Public key must be 64 bytes but received ${e.length} bytes`);try{return s.Buffer.from((0,se.lY)(toBuffer(e))).slice(-20)}catch(e){throw new Error(`Error constructing Ethereum address: ${e}`)}}static createInstructionWithPublicKey(e){const{publicKey:t,message:r,signature:n,recoveryId:s,instructionIndex:i}=e;return Secp256k1Program.createInstructionWithEthAddress({ethAddress:Secp256k1Program.publicKeyToEthAddress(t),message:r,signature:n,recoveryId:s,instructionIndex:i})}static createInstructionWithEthAddress(e){const{ethAddress:t,message:r,signature:n,recoveryId:i,instructionIndex:o=0}=e;let a;a="string"==typeof t?t.startsWith("0x")?s.Buffer.from(t.substr(2),"hex"):s.Buffer.from(t,"hex"):t,index_browser_esm_assert(20===a.length,`Address must be 20 bytes but received ${a.length} bytes`);const u=12+a.length,c=u+n.length+1,d=s.Buffer.alloc(Rt.span+r.length);return Rt.encode({numSignatures:1,signatureOffset:u,signatureInstructionIndex:o,ethAddressOffset:12,ethAddressInstructionIndex:o,messageDataOffset:c,messageDataSize:r.length,messageInstructionIndex:o,signature:toBuffer(n),ethAddress:toBuffer(a),recoveryId:i},d),d.fill(toBuffer(r),Rt.span),new TransactionInstruction({keys:[],programId:Secp256k1Program.programId,data:d})}static createInstructionWithPrivateKey(e){const{privateKey:t,message:r,instructionIndex:n}=e;index_browser_esm_assert(32===t.length,`Private key must be 32 bytes but received ${t.length} bytes`);try{const e=toBuffer(t),i=Ot(e,!1).slice(1),o=s.Buffer.from((0,se.lY)(toBuffer(r))),[a,u]=((e,t)=>{const r=ke.sign(e,t);return[r.toCompactRawBytes(),r.recovery]})(o,e);return this.createInstructionWithPublicKey({publicKey:i,message:r,signature:a,recoveryId:u,instructionIndex:n})}catch(e){throw new Error(`Error creating instruction; ${e}`)}}}var zt;Secp256k1Program.programId=new PublicKey("KeccakSecp256k11111111111111111111111111111");const jt=new PublicKey("StakeConfig11111111111111111111111111111111");class Lockup{constructor(e,t,r){this.unixTimestamp=void 0,this.epoch=void 0,this.custodian=void 0,this.unixTimestamp=e,this.epoch=t,this.custodian=r}}zt=Lockup,Lockup.default=new zt(0,0,PublicKey.default);const Ut=Object.freeze({Initialize:{index:0,layout:ee.struct([ee.u32("instruction"),((e="authorized")=>ee.struct([publicKey("staker"),publicKey("withdrawer")],e))(),((e="lockup")=>ee.struct([ee.ns64("unixTimestamp"),ee.ns64("epoch"),publicKey("custodian")],e))()])},Authorize:{index:1,layout:ee.struct([ee.u32("instruction"),publicKey("newAuthorized"),ee.u32("stakeAuthorizationType")])},Delegate:{index:2,layout:ee.struct([ee.u32("instruction")])},Split:{index:3,layout:ee.struct([ee.u32("instruction"),ee.ns64("lamports")])},Withdraw:{index:4,layout:ee.struct([ee.u32("instruction"),ee.ns64("lamports")])},Deactivate:{index:5,layout:ee.struct([ee.u32("instruction")])},Merge:{index:7,layout:ee.struct([ee.u32("instruction")])},AuthorizeWithSeed:{index:8,layout:ee.struct([ee.u32("instruction"),publicKey("newAuthorized"),ee.u32("stakeAuthorizationType"),rustString("authoritySeed"),publicKey("authorityOwner")])}});Object.freeze({Staker:{index:0},Withdrawer:{index:1}});class StakeProgram{constructor(){}static initialize(e){const{stakePubkey:t,authorized:r,lockup:n}=e,s=n||Lockup.default,i=encodeData(Ut.Initialize,{authorized:{staker:toBuffer(r.staker.toBuffer()),withdrawer:toBuffer(r.withdrawer.toBuffer())},lockup:{unixTimestamp:s.unixTimestamp,epoch:s.epoch,custodian:toBuffer(s.custodian.toBuffer())}}),o={keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:Oe,isSigner:!1,isWritable:!1}],programId:this.programId,data:i};return new TransactionInstruction(o)}static createAccountWithSeed(e){const t=new Transaction;t.add(SystemProgram.createAccountWithSeed({fromPubkey:e.fromPubkey,newAccountPubkey:e.stakePubkey,basePubkey:e.basePubkey,seed:e.seed,lamports:e.lamports,space:this.space,programId:this.programId}));const{stakePubkey:r,authorized:n,lockup:s}=e;return t.add(this.initialize({stakePubkey:r,authorized:n,lockup:s}))}static createAccount(e){const t=new Transaction;t.add(SystemProgram.createAccount({fromPubkey:e.fromPubkey,newAccountPubkey:e.stakePubkey,lamports:e.lamports,space:this.space,programId:this.programId}));const{stakePubkey:r,authorized:n,lockup:s}=e;return t.add(this.initialize({stakePubkey:r,authorized:n,lockup:s}))}static delegate(e){const{stakePubkey:t,authorizedPubkey:r,votePubkey:n}=e,s=encodeData(Ut.Delegate);return(new Transaction).add({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:Ke,isSigner:!1,isWritable:!1},{pubkey:Re,isSigner:!1,isWritable:!1},{pubkey:jt,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}],programId:this.programId,data:s})}static authorize(e){const{stakePubkey:t,authorizedPubkey:r,newAuthorizedPubkey:n,stakeAuthorizationType:s,custodianPubkey:i}=e,o=encodeData(Ut.Authorize,{newAuthorized:toBuffer(n.toBuffer()),stakeAuthorizationType:s.index}),a=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:Ke,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!0,isWritable:!1}];return i&&a.push({pubkey:i,isSigner:!0,isWritable:!1}),(new Transaction).add({keys:a,programId:this.programId,data:o})}static authorizeWithSeed(e){const{stakePubkey:t,authorityBase:r,authoritySeed:n,authorityOwner:s,newAuthorizedPubkey:i,stakeAuthorizationType:o,custodianPubkey:a}=e,u=encodeData(Ut.AuthorizeWithSeed,{newAuthorized:toBuffer(i.toBuffer()),stakeAuthorizationType:o.index,authoritySeed:n,authorityOwner:toBuffer(s.toBuffer())}),c=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!0,isWritable:!1},{pubkey:Ke,isSigner:!1,isWritable:!1}];return a&&c.push({pubkey:a,isSigner:!0,isWritable:!1}),(new Transaction).add({keys:c,programId:this.programId,data:u})}static splitInstruction(e){const{stakePubkey:t,authorizedPubkey:r,splitStakePubkey:n,lamports:s}=e,i=encodeData(Ut.Split,{lamports:s});return new TransactionInstruction({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!0,isWritable:!1}],programId:this.programId,data:i})}static split(e,t){const r=new Transaction;return r.add(SystemProgram.createAccount({fromPubkey:e.authorizedPubkey,newAccountPubkey:e.splitStakePubkey,lamports:t,space:this.space,programId:this.programId})),r.add(this.splitInstruction(e))}static splitWithSeed(e,t){const{stakePubkey:r,authorizedPubkey:n,splitStakePubkey:s,basePubkey:i,seed:o,lamports:a}=e,u=new Transaction;return u.add(SystemProgram.allocate({accountPubkey:s,basePubkey:i,seed:o,space:this.space,programId:this.programId})),t&&t>0&&u.add(SystemProgram.transfer({fromPubkey:e.authorizedPubkey,toPubkey:s,lamports:t})),u.add(this.splitInstruction({stakePubkey:r,authorizedPubkey:n,splitStakePubkey:s,lamports:a}))}static merge(e){const{stakePubkey:t,sourceStakePubKey:r,authorizedPubkey:n}=e,s=encodeData(Ut.Merge);return(new Transaction).add({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:Ke,isSigner:!1,isWritable:!1},{pubkey:Re,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!1}],programId:this.programId,data:s})}static withdraw(e){const{stakePubkey:t,authorizedPubkey:r,toPubkey:n,lamports:s,custodianPubkey:i}=e,o=encodeData(Ut.Withdraw,{lamports:s}),a=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:Ke,isSigner:!1,isWritable:!1},{pubkey:Re,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}];return i&&a.push({pubkey:i,isSigner:!0,isWritable:!1}),(new Transaction).add({keys:a,programId:this.programId,data:o})}static deactivate(e){const{stakePubkey:t,authorizedPubkey:r}=e,n=encodeData(Ut.Deactivate);return(new Transaction).add({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:Ke,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}],programId:this.programId,data:n})}}StakeProgram.programId=new PublicKey("Stake11111111111111111111111111111111111111"),StakeProgram.space=200;const qt=Object.freeze({InitializeAccount:{index:0,layout:ee.struct([ee.u32("instruction"),((e="voteInit")=>ee.struct([publicKey("nodePubkey"),publicKey("authorizedVoter"),publicKey("authorizedWithdrawer"),ee.u8("commission")],e))()])},Authorize:{index:1,layout:ee.struct([ee.u32("instruction"),publicKey("newAuthorized"),ee.u32("voteAuthorizationType")])},Withdraw:{index:3,layout:ee.struct([ee.u32("instruction"),ee.ns64("lamports")])},UpdateValidatorIdentity:{index:4,layout:ee.struct([ee.u32("instruction")])},AuthorizeWithSeed:{index:10,layout:ee.struct([ee.u32("instruction"),((e="voteAuthorizeWithSeedArgs")=>ee.struct([ee.u32("voteAuthorizationType"),publicKey("currentAuthorityDerivedKeyOwnerPubkey"),rustString("currentAuthorityDerivedKeySeed"),publicKey("newAuthorized")],e))()])}});Object.freeze({Voter:{index:0},Withdrawer:{index:1}});class VoteProgram{constructor(){}static initializeAccount(e){const{votePubkey:t,nodePubkey:r,voteInit:n}=e,s=encodeData(qt.InitializeAccount,{voteInit:{nodePubkey:toBuffer(n.nodePubkey.toBuffer()),authorizedVoter:toBuffer(n.authorizedVoter.toBuffer()),authorizedWithdrawer:toBuffer(n.authorizedWithdrawer.toBuffer()),commission:n.commission}}),i={keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:Oe,isSigner:!1,isWritable:!1},{pubkey:Ke,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}],programId:this.programId,data:s};return new TransactionInstruction(i)}static createAccount(e){const t=new Transaction;return t.add(SystemProgram.createAccount({fromPubkey:e.fromPubkey,newAccountPubkey:e.votePubkey,lamports:e.lamports,space:this.space,programId:this.programId})),t.add(this.initializeAccount({votePubkey:e.votePubkey,nodePubkey:e.voteInit.nodePubkey,voteInit:e.voteInit}))}static authorize(e){const{votePubkey:t,authorizedPubkey:r,newAuthorizedPubkey:n,voteAuthorizationType:s}=e,i=encodeData(qt.Authorize,{newAuthorized:toBuffer(n.toBuffer()),voteAuthorizationType:s.index}),o=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:Ke,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}];return(new Transaction).add({keys:o,programId:this.programId,data:i})}static authorizeWithSeed(e){const{currentAuthorityDerivedKeyBasePubkey:t,currentAuthorityDerivedKeyOwnerPubkey:r,currentAuthorityDerivedKeySeed:n,newAuthorizedPubkey:s,voteAuthorizationType:i,votePubkey:o}=e,a=encodeData(qt.AuthorizeWithSeed,{voteAuthorizeWithSeedArgs:{currentAuthorityDerivedKeyOwnerPubkey:toBuffer(r.toBuffer()),currentAuthorityDerivedKeySeed:n,newAuthorized:toBuffer(s.toBuffer()),voteAuthorizationType:i.index}}),u=[{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:Ke,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!0,isWritable:!1}];return(new Transaction).add({keys:u,programId:this.programId,data:a})}static withdraw(e){const{votePubkey:t,authorizedWithdrawerPubkey:r,lamports:n,toPubkey:s}=e,i=encodeData(qt.Withdraw,{lamports:n}),o=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!0,isWritable:!1}];return(new Transaction).add({keys:o,programId:this.programId,data:i})}static safeWithdraw(e,t,r){if(e.lamports>t-r)throw new Error("Withdraw will leave vote account with insufficient funds.");return VoteProgram.withdraw(e)}static updateValidatorIdentity(e){const{votePubkey:t,authorizedWithdrawerPubkey:r,nodePubkey:n}=e,s=encodeData(qt.UpdateValidatorIdentity),i=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!0,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}];return(new Transaction).add({keys:i,programId:this.programId,data:s})}}VoteProgram.programId=new PublicKey("Vote111111111111111111111111111111111111111"),VoteProgram.space=3762;new PublicKey("Va1idator1nfo111111111111111111111111111111"),(0,re.NW)({name:(0,re.Yj)(),website:(0,re.lq)((0,re.Yj)()),details:(0,re.lq)((0,re.Yj)()),keybaseUsername:(0,re.lq)((0,re.Yj)())});new PublicKey("Vote111111111111111111111111111111111111111"),ee.struct([publicKey("nodePubkey"),publicKey("authorizedWithdrawer"),ee.u8("commission"),ee.nu64(),ee.seq(ee.struct([ee.nu64("slot"),ee.u32("confirmationCount")]),ee.offset(ee.u32(),-8),"votes"),ee.u8("rootSlotValid"),ee.nu64("rootSlot"),ee.nu64(),ee.seq(ee.struct([ee.nu64("epoch"),publicKey("authorizedVoter")]),ee.offset(ee.u32(),-8),"authorizedVoters"),ee.struct([ee.seq(ee.struct([publicKey("authorizedPubkey"),ee.nu64("epochOfLastAuthorizedSwitch"),ee.nu64("targetEpoch")]),32,"buf"),ee.nu64("idx"),ee.u8("isEmpty")],"priorVoters"),ee.nu64(),ee.seq(ee.struct([ee.nu64("epoch"),ee.nu64("credits"),ee.nu64("prevCredits")]),ee.offset(ee.u32(),-8),"epochCredits"),ee.struct([ee.nu64("slot"),ee.nu64("timestamp")],"lastTimestamp")])},856115:(e,t,r)=>{"use strict";var n=r(901048).Buffer;Object.defineProperty(t,"__esModule",{value:!0}),t.toBigIntLE=function toBigIntLE(e){{const t=n.from(e);t.reverse();const r=t.toString("hex");return 0===r.length?BigInt(0):BigInt(`0x${r}`)}},t.toBigIntBE=function toBigIntBE(e){{const t=e.toString("hex");return 0===t.length?BigInt(0):BigInt(`0x${t}`)}},t.toBufferLE=function toBufferLE(e,t){{const r=e.toString(16),s=n.from(r.padStart(2*t,"0").slice(0,2*t),"hex");return s.reverse(),s}},t.toBufferBE=function toBufferBE(e,t){{const r=e.toString(16);return n.from(r.padStart(2*t,"0").slice(0,2*t),"hex")}}},90366:e=>{var t=10,r=41,n=107,s=9,i=25,o=10;function inputBytes(e){return r+(e.script?e.script.length:n)}function outputBytes(e){return e.script?o+e.script.length+(e.script.length>=74?2:1):s+(e.script?e.script.length:i)}function dustThreshold(e,t){return 3*inputBytes({})}function transactionBytes(e,r){return t+e.reduce((function(e,t){return e+inputBytes(t)}),0)+r.reduce((function(e,t){return e+outputBytes(t)}),0)}function uintOrNaN(e){return"number"!=typeof e?NaN:isFinite(e)?Math.floor(e)!==e||e<0?NaN:e:NaN}function sumOrNaN(e){return e.reduce((function(e,t){return e+uintOrNaN(t.value)}),0)}var a=outputBytes({});e.exports={dustThreshold,finalize:function finalize(e,t,r){var n=transactionBytes(e,t),s=r*(n+a),i=sumOrNaN(e)-(sumOrNaN(t)+s);i>dustThreshold()&&(t=t.concat({value:i}));var o=sumOrNaN(e)-sumOrNaN(t);return isFinite(o)?{inputs:e,outputs:t,fee:o}:{fee:r*n}},inputBytes,outputBytes,sumOrNaN,sumForgiving:function sumForgiving(e){return e.reduce((function(e,t){return e+(isFinite(t.value)?t.value:0)}),0)},transactionBytes,uintOrNaN}},727801:(e,t,r)=>{"use strict";r.d(t,{KC:()=>union,KJ:()=>instance,L5:()=>unknown,NW:()=>type,PV:()=>tuple,YO:()=>array,Yj:()=>string,ai:()=>number,au:()=>coerce,bz:()=>any,eu:()=>literal,g1:()=>record,lq:()=>optional,me:()=>nullable,vA:()=>assert,vt:()=>create,zM:()=>boolean});class StructError extends TypeError{constructor(e,t){let r;const{message:n,...s}=e,{path:i}=e;super(0===i.length?n:"At path: "+i.join(".")+" -- "+n),Object.assign(this,s),this.name=this.constructor.name,this.failures=()=>{var n;return null!=(n=r)?n:r=[e,...t()]}}}function isObject(e){return"object"==typeof e&&null!=e}function print(e){return"string"==typeof e?JSON.stringify(e):""+e}function toFailure(e,t,r,n){if(!0===e)return;!1===e?e={}:"string"==typeof e&&(e={message:e});const{path:s,branch:i}=t,{type:o}=r,{refinement:a,message:u="Expected a value of type `"+o+"`"+(a?" with refinement `"+a+"`":"")+", but received: `"+print(n)+"`"}=e;return{value:n,type:o,refinement:a,key:s[s.length-1],path:s,branch:i,...e,message:u}}function*toFailures(e,t,r,n){(function isIterable(e){return isObject(e)&&"function"==typeof e[Symbol.iterator]})(e)||(e=[e]);for(const s of e){const e=toFailure(s,t,r,n);e&&(yield e)}}function*run(e,t,r={}){const{path:n=[],branch:s=[e],coerce:i=!1,mask:o=!1}=r,a={path:n,branch:s};if(i&&(e=t.coercer(e,a),o&&"type"!==t.type&&isObject(t.schema)&&isObject(e)&&!Array.isArray(e)))for(const r in e)void 0===t.schema[r]&&delete e[r];let u=!0;for(const r of t.validator(e,a))u=!1,yield[r,void 0];for(let[r,c,d]of t.entries(e,a)){const t=run(c,d,{path:void 0===r?n:[...n,r],branch:void 0===r?s:[...s,c],coerce:i,mask:o});for(const n of t)n[0]?(u=!1,yield[n[0],void 0]):i&&(c=n[1],void 0===r?e=c:e instanceof Map?e.set(r,c):e instanceof Set?e.add(c):isObject(e)&&(e[r]=c))}if(u)for(const r of t.refiner(e,a))u=!1,yield[r,void 0];u&&(yield[void 0,e])}class Struct{constructor(e){const{type:t,schema:r,validator:n,refiner:s,coercer:i=(e=>e),entries:o=function*(){}}=e;this.type=t,this.schema=r,this.entries=o,this.coercer=i,this.validator=n?(e,t)=>toFailures(n(e,t),t,this,e):()=>[],this.refiner=s?(e,t)=>toFailures(s(e,t),t,this,e):()=>[]}assert(e){return assert(e,this)}create(e){return create(e,this)}is(e){return is(e,this)}mask(e){return function mask(e,t){const r=validate(e,t,{coerce:!0,mask:!0});if(r[0])throw r[0];return r[1]}(e,this)}validate(e,t={}){return validate(e,this,t)}}function assert(e,t){const r=validate(e,t);if(r[0])throw r[0]}function create(e,t){const r=validate(e,t,{coerce:!0});if(r[0])throw r[0];return r[1]}function is(e,t){return!validate(e,t)[0]}function validate(e,t,r={}){const n=run(e,t,r),s=function shiftIterator(e){const{done:t,value:r}=e.next();return t?void 0:r}(n);if(s[0]){return[new StructError(s[0],(function*(){for(const e of n)e[0]&&(yield e[0])})),void 0]}return[void 0,s[1]]}function define(e,t){return new Struct({type:e,schema:null,validator:t})}function any(){return define("any",(()=>!0))}function array(e){return new Struct({type:"array",schema:e,*entries(t){if(e&&Array.isArray(t))for(const[r,n]of t.entries())yield[r,n,e]},coercer:e=>Array.isArray(e)?e.slice():e,validator:e=>Array.isArray(e)||"Expected an array value, but received: "+print(e)})}function boolean(){return define("boolean",(e=>"boolean"==typeof e))}function instance(e){return define("instance",(t=>t instanceof e||"Expected a `"+e.name+"` instance, but received: "+print(t)))}function literal(e){const t=print(e),r=typeof e;return new Struct({type:"literal",schema:"string"===r||"number"===r||"boolean"===r?e:null,validator:r=>r===e||"Expected the literal `"+t+"`, but received: "+print(r)})}function never(){return define("never",(()=>!1))}function nullable(e){return new Struct({...e,validator:(t,r)=>null===t||e.validator(t,r),refiner:(t,r)=>null===t||e.refiner(t,r)})}function number(){return define("number",(e=>"number"==typeof e&&!isNaN(e)||"Expected a number, but received: "+print(e)))}function optional(e){return new Struct({...e,validator:(t,r)=>void 0===t||e.validator(t,r),refiner:(t,r)=>void 0===t||e.refiner(t,r)})}function record(e,t){return new Struct({type:"record",schema:null,*entries(r){if(isObject(r))for(const n in r){const s=r[n];yield[n,n,e],yield[n,s,t]}},validator:e=>isObject(e)||"Expected an object, but received: "+print(e)})}function string(){return define("string",(e=>"string"==typeof e||"Expected a string, but received: "+print(e)))}function tuple(e){const t=never();return new Struct({type:"tuple",schema:null,*entries(r){if(Array.isArray(r)){const n=Math.max(e.length,r.length);for(let s=0;s<n;s++)yield[s,r[s],e[s]||t]}},validator:e=>Array.isArray(e)||"Expected an array, but received: "+print(e)})}function type(e){const t=Object.keys(e);return new Struct({type:"type",schema:e,*entries(r){if(isObject(r))for(const n of t)yield[n,r[n],e[n]]},validator:e=>isObject(e)||"Expected an object, but received: "+print(e)})}function union(e){const t=e.map((e=>e.type)).join(" | ");return new Struct({type:"union",schema:null,validator(r,n){const s=[];for(const t of e){const[...e]=run(r,t,n),[i]=e;if(!i[0])return[];for(const[t]of e)t&&s.push(t)}return["Expected the value to satisfy a union of `"+t+"`, but received: "+print(r),...s]}})}function unknown(){return define("unknown",(()=>!0))}function coerce(e,t,r){return new Struct({...e,coercer:(n,s)=>is(n,t)?e.coercer(r(n,s),s):e.coercer(n,s)})}}}]);