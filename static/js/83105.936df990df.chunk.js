(self.webpackChunkweb=self.webpackChunkweb||[]).push([[83105],{438341:(t,e,o)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.convertQueryOptionToLumosSearchKey=convertQueryOptionToLumosSearchKey,e.filterByLumosQueryOptions=function filterByLumosQueryOptions(t,e){const o=convertQueryOptionToLumosSearchKey(e);let r=t.filter((t=>filterByLumosSearchKey(t,o)));e.argsLen&&"any"!==e.argsLen&&-1!==e.argsLen&&(r=r.filter((t=>i.bytes.bytify(t.cellOutput.lock.args).length===e.argsLen)));if(e.data&&"any"!==e.data)if(instanceOfDataWithSearchMode(e.data)&&"exact"===e.data.searchMode){const t=e.data;r=r.filter((e=>i.bytes.equal(i.bytes.bytify(e.data),i.bytes.bytify(t.data))))}else if(instanceOfDataWithSearchMode(e.data)&&"prefix"===e.data.searchMode){const t=e.data;r=r.filter((e=>{const o=i.bytes.bytify(t.data),r=i.bytes.bytify(e.data).slice(0,o.length);return i.bytes.equal(o,r)}))}else r=r.filter((t=>{const o=i.bytes.bytify(e.data),r=i.bytes.bytify(t.data).slice(0,o.length);return i.bytes.equal(o,r)}));return r},e.filterByLumosSearchKey=filterByLumosSearchKey,e.instanceOfDataWithSearchMode=instanceOfDataWithSearchMode,e.instanceOfScriptWrapper=instanceOfScriptWrapper,e.unwrapScriptWrapper=e.unwrapDataWrapper=void 0;var r=o(140993),i=o(852966),n=o(739609);function convertQueryOptionToLumosSearchKey(t){let e,o,r;const i=t.lock,n=t.type;if(i&&(e=instanceOfScriptWrapper(i)?i.script:i),n&&"empty"!==n&&(o=instanceOfScriptWrapper(n)?n.script:n),e)r={script:e,scriptType:"lock",scriptSearchMode:instanceOfScriptWrapper(i)&&i.searchMode||"prefix",filter:{}},o&&(r.filter.script=o);else{if(!o)throw new Error("query.lock and query.type can't be both empty");r={script:o,scriptType:"type",scriptSearchMode:instanceOfScriptWrapper(n)&&n.searchMode||"prefix",filter:{}}}const{outputDataLenRange:a,outputCapacityRange:s,scriptLenRange:c}=t;return r.filter.outputDataLenRange=a,r.filter.outputCapacityRange=s,r.filter.scriptLenRange=c,"empty"===n&&(r.filter.scriptLenRange=["0x0","0x1"]),r}function filterByLumosSearchKey(t,e){const o="exact"===e.scriptSearchMode,{cellOutput:a}=t,{scriptType:s,script:c,filter:l}=e;if(o){if("lock"===s){if(!i.bytes.equal(r.blockchain.Script.pack(a.lock),r.blockchain.Script.pack(c)))return!1}else if(!a.type||!i.bytes.equal(r.blockchain.Script.pack(a.type),r.blockchain.Script.pack(c)))return!1}else if("lock"===s){if(!checkScriptWithPrefixMode(a.lock,c))return!1}else if(!checkScriptWithPrefixMode(a.type,c))return!1;if(!l)return!0;if("lock"===s){if(l.script&&!checkScriptWithPrefixMode(a.type,l.script))return!1;if(l.scriptLenRange&&!checkScriptLenRange(a.type,l.scriptLenRange))return!1}else{if(l.script&&!checkScriptWithPrefixMode(a.lock,l.script))return!1;if(l.scriptLenRange&&!checkScriptLenRange(a.lock,l.scriptLenRange))return!1}const{outputCapacityRange:u,outputDataLenRange:p}=l;if(u){const t=n.BI.from(a.capacity),e=n.BI.from(u[0]),o=n.BI.from(u[1]);if(t.lt(e)||t.gte(o))return!1}if(p){const e=n.BI.from(i.bytes.bytify(t.data).length),o=n.BI.from(p[0]),r=n.BI.from(p[1]);if(e.lt(o)||e.gte(r))return!1}return!0}function checkScriptWithPrefixMode(t,e){if(!t)return!1;if(!i.bytes.equal(e.codeHash,t.codeHash))return!1;const o=i.bytes.bytify(e.args),r=i.bytes.bytify(t.args).slice(0,o.length);return!!i.bytes.equal(o,r)&&t.hashType===e.hashType}function checkScriptLenRange(t,e){const o=t?n.BI.from(i.bytes.concat(t.codeHash,t.args).length+1):n.BI.from(0),r=n.BI.from(e[0]),a=n.BI.from(e[1]);return!o.lt(r)&&!o.gte(a)}function instanceOfScriptWrapper(t){return"object"==typeof t&&null!=t&&"script"in t}function instanceOfDataWithSearchMode(t){return"object"==typeof t&&null!=t&&"data"in t}e.unwrapScriptWrapper=t=>instanceOfScriptWrapper(t)?t.script:t;e.unwrapDataWrapper=t=>instanceOfDataWithSearchMode(t)?t.data:t},239397:(t,e,o)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.CKBCellCollector=void 0;var r=o(140993),i=o(750458),n=o(821824),a=function _interopRequireDefault(t){return t&&t.__esModule?t:{default:t}}(o(410288)),s=o(438341);e.CKBCellCollector=class CKBCellCollector{constructor(t,e,o){this.terminableCellFetcher=t,this.otherQueryOptions=o;const r={lock:void 0,type:void 0,argsLen:-1,data:"any",fromBlock:void 0,toBlock:void 0,order:"asc",skip:void 0,outputDataLenRange:void 0,outputCapacityRange:void 0,bufferSize:void 0};this.queries=(Array.isArray(e)?e:[e]).map((t=>({...r,...t}))),this.queries.forEach((t=>{this.validateQueryOption(t)})),this.convertQueryOptionToSearchKey()}validateQueryOption(t){if(!(t.lock||t.type&&"empty"!==t.type))throw new Error("Either lock or type script must be provided!");if(t.lock&&((0,s.instanceOfScriptWrapper)(t.lock)?(0,s.instanceOfScriptWrapper)(t.lock)&&i.validators.ValidateScript(t.lock.script):i.validators.ValidateScript(t.lock)),t.type&&"empty"!==t.type&&("object"!=typeof t.type||(0,s.instanceOfScriptWrapper)(t.type)?"object"==typeof t.type&&(0,s.instanceOfScriptWrapper)(t.type)&&i.validators.ValidateScript(t.type.script):i.validators.ValidateScript(t.type)),t.fromBlock&&r.utils.assertHexadecimal("fromBlock",t.fromBlock),t.toBlock&&r.utils.assertHexadecimal("toBlock",t.toBlock),"asc"!==t.order&&"desc"!==t.order)throw new Error("Order must be either asc or desc!");if(t.outputCapacityRange&&(r.utils.assertHexadecimal("outputCapacityRange[0]",t.outputCapacityRange[0]),r.utils.assertHexadecimal("outputCapacityRange[1]",t.outputCapacityRange[1])),t.outputDataLenRange&&(r.utils.assertHexadecimal("outputDataLenRange[0]",t.outputDataLenRange[0]),r.utils.assertHexadecimal("outputDataLenRange[1]",t.outputDataLenRange[1])),t.scriptLenRange&&(r.utils.assertHexadecimal("scriptLenRange[0]",t.scriptLenRange[0]),r.utils.assertHexadecimal("scriptLenRange[1]",t.scriptLenRange[1])),t.outputDataLenRange&&t.data&&"any"!==t.data){const e=(0,n.getHexStringBytes)((0,s.unwrapDataWrapper)(t.data));if(e<Number(t.outputDataLenRange[0])||e>=Number(t.outputDataLenRange[1]))throw new Error("data length not match outputDataLenRange")}if(t.skip&&"number"!=typeof t.skip)throw new Error("skip must be a number!");if(t.bufferSize&&"number"!=typeof t.bufferSize)throw new Error("bufferSize must be a number!")}convertQueryOptionToSearchKey(){this.queries.forEach((t=>{const e=t.lock;if(e&&(0,s.instanceOfScriptWrapper)(e)&&(i.validators.ValidateScript(e.script),t.lock=e.script),t.type&&"empty"!==t.type&&"object"==typeof t.type&&(0,s.instanceOfScriptWrapper)(t.type)&&(i.validators.ValidateScript(t.type.script),t.type=t.type.script),!t.outputDataLenRange&&t.data&&"any"!==t.data){const e=(0,n.getHexStringBytes)((0,s.unwrapDataWrapper)(t.data));t.outputDataLenRange=["0x"+e.toString(16),"0x"+(e+1).toString(16)]}t.scriptLenRange||"empty"!==t.type||(t.scriptLenRange=["0x0","0x1"])}))}async getLiveCell(t,e){const o={sizeLimit:t.bufferSize,order:t.order,lastCursor:e};return await this.terminableCellFetcher.getCells((0,n.generateSearchKey)(t),void 0,o)}async count(){let t=0;for await(const e of this.collect())t++;return t}async request(t,e){const o=await(0,a.default)(t,{method:"POST",body:JSON.stringify(e),headers:{"Content-Type":"application/json"}});if(200!==o.status)throw new Error(`indexer request failed with HTTP code ${o.status}`);const r=await o.json();if(void 0!==r.error)throw new Error(`indexer request rpc failed with error: ${JSON.stringify(r.error)}`);return r}async getLiveCellWithBlockHash(t,e){if(!this.otherQueryOptions)throw new Error("CKB Rpc URL must provide");const o=await this.getLiveCell(t,e);if(0===o.objects.length)return o;const r=o.objects.map(((t,e)=>({id:e,jsonrpc:"2.0",method:"get_block_hash",params:[t.blockNumber]}))),i=await this.request(this.otherQueryOptions.ckbRpcUrl,r);return o.objects=o.objects.map(((t,e)=>{const o=i.find((t=>t.id===e));return{...t,blockHash:o&&o.result}})),o}async*collect(){const t=new Set;for(const r of this.queries)for await(const i of this.collectBySingleQuery(r)){var e,o;const r=`${null===(e=i.outPoint)||void 0===e?void 0:e.txHash}-${null===(o=i.outPoint)||void 0===o?void 0:o.index}`;t.has(r)||(t.add(r),yield i)}}async*collectBySingleQuery(t){const e=this.otherQueryOptions&&"withBlockHash"in this.otherQueryOptions&&this.otherQueryOptions.withBlockHash;let o;const getCellWithCursor=async()=>{const r=await(e?this.getLiveCellWithBlockHash(t,o):this.getLiveCell(t,o));return o=r.lastCursor,r.objects};let r=await getCellWithCursor();if(r=(0,s.filterByLumosQueryOptions)(r,t),0===r.length)return;let i=getCellWithCursor(),n=0,a=0;for(;;)if(t.skip&&a<t.skip?a++:yield r[n],n++,n===r.length){if(n=0,r=await i,0===r.length)break;i=getCellWithCursor()}}}},12406:(t,e,o)=>{"use strict";Object.defineProperty(e,"We",{enumerable:!0,get:function(){return r.CKBCellCollector}}),Object.defineProperty(e,"HI",{enumerable:!0,get:function(){return i.TerminableCellAdapter}});var r=o(239397),i=o(823737),n=o(891730),a=o(129021)},823737:(t,e,o)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.TerminableCellAdapter=e.CkbIndexer=void 0;var r=o(140993),i=o(821824),n=o(239397),a=o(450046),s=o(533060),c=o(739609),l=o(129021),u=o(436115),p=o(750458),d=o(438341);const DefaultTerminator=()=>({stop:!1,push:!0});function defaultLogger(t,e){console.log(`[${t}] ${e}`)}e.CkbIndexer=class CkbIndexer{static version="0.4.1";medianTimeEmitters=[];emitters=[];isSubscribeRunning=!1;constructor(t,e){this.ckbIndexerUrl=t,this.ckbRpcUrl=e,this.uri=e||t,this.ckbIndexerUri=t}getCkbRpc(){return new u.CKBRPC(this.uri)}getIndexerRpc(){if(this.uri===this.ckbIndexerUri){const t=this.getCkbRpc();return{...t,getTip:t.getIndexerTip}}return new l.RPC(this.ckbIndexerUri)}async tip(){return await this.getIndexerRpc().getTip()}asyncSleep(t){return new Promise((e=>setTimeout(e,t)))}async waitForSync(t=0){const e=parseInt((await this.getCkbRpc().getTipHeader()).number,16);for(;;){if(parseInt((await this.tip()).blockNumber,16)+t>=e)return;await this.asyncSleep(1e3)}}collector(t,e){return new n.CKBCellCollector(this,t,e)}async getCells(t,e=DefaultTerminator,o={}){return new TerminableCellAdapter(this.getIndexerRpc()).getCells(t,e,o)}async getTransactions(t,e={}){let o=[],r=e.lastCursor;const i=e.sizeLimit||100,n=e.order||"asc";for(;;){const e=await this.getIndexerRpc().getTransactions(t,n,`0x${i.toString(16)}`,r),a=e.objects;if(r=e.lastCursor,o=o.concat(a),a.length<=i)break}return{objects:o,lastCursor:r}}running(){return!0}start(){defaultLogger("warn","deprecated: no need to start the ckb-indexer manually")}startForever(){defaultLogger("warn","deprecated: no need to startForever the ckb-indexer manually")}stop(){defaultLogger("warn","deprecated: no need to stop the ckb-indexer manually")}subscribe(t){if(this.isSubscribeRunning=!0,this.scheduleLoop(),t.lock&&t.type)throw new Error("The notification machanism only supports you subscribing for one script once so far!");null===t.toBlock&&null===t.skip||defaultLogger("warn","The passing fields such as toBlock and skip are ignored in subscribe() method.");const e=new s.IndexerEmitter;if(e.argsLen=t.argsLen,e.outputData=t.data&&(0,d.unwrapDataWrapper)(t.data),t.fromBlock&&r.utils.assertHexadecimal("fromBlock",t.fromBlock),e.fromBlock=t.fromBlock?c.BI.from(t.fromBlock):c.BI.from(0),t.lock)p.validators.ValidateScript(t.lock),e.lock=t.lock;else{if(!t.type||"empty"===t.type)throw new Error("Either lock or type script must be provided!");p.validators.ValidateScript(t.type),e.type=t.type}return this.emitters.push(e),e}loop(){this.isSubscribeRunning&&this.poll().then((t=>{this.scheduleLoop(t)})).catch((t=>{defaultLogger("error",`Error occurs: ${t} ${t.stack}, stopping indexer!`),this.isSubscribeRunning=!1}))}scheduleLoop(t=1){setTimeout((()=>{this.loop()}),t)}async poll(){let t=1;const e=await this.tip(),{blockNumber:o,blockHash:r}=e;if("0x0"===o){const t=await this.getCkbRpc().getBlockByNumber(o);await this.publishAppendBlockEvents(t)}const i=c.BI.from(o).add(1),n=await this.getCkbRpc().getBlockByNumber(`0x${i.toString(16)}`);if(n)if(n.header.parentHash===r)await this.publishAppendBlockEvents(n);else{const t=await this.getCkbRpc().getBlockByNumber(o);await this.publishAppendBlockEvents(t)}else{const e=await this.getCkbRpc().getBlockByNumber(o);await this.publishAppendBlockEvents(e),t=3e3}return t}async publishAppendBlockEvents(t){for(const[e,o]of t.transactions.entries()){const r=t.header.number;if(e>0){const t=o.inputs.map((t=>t.previousOutput.txHash));(await(0,i.requestBatchTransactionWithStatus)(this.uri,t).then((t=>t.map(((t,e)=>{const r=o.inputs[e].previousOutput.index;return{output:t.transaction.outputs[parseInt(r)],outputData:t.transaction.outputsData[parseInt(r)]}}))))).forEach((({output:t,outputData:e})=>{this.filterEvents(t,r,e)}))}for(const[t,e]of o.outputs.entries()){const i=o.outputsData[t];this.filterEvents(e,r,i)}}await this.emitMedianTimeEvents()}filterEvents(t,e,o){for(const r of this.emitters)void 0!==r.lock&&this.checkFilterOptions(r,e,o,r.lock,t.lock)&&r.emit("changed");if(null!==t.type)for(const r of this.emitters)void 0!==r.type&&this.checkFilterOptions(r,e,o,r.type,t.type)&&r.emit("changed")}checkFilterOptions(t,e,o,r,i){const n=!t.fromBlock||c.BI.from(t.fromBlock).lte(e),a="any"===t.outputData||!t.outputData||t.outputData===o,s=!i||r.codeHash===i.codeHash&&r.hashType===i.hashType&&this.checkArgs(t.argsLen,r.args,i.args);return n&&a&&s}checkArgs(t,e,o){return-1===t||!t&&0!==t?e===o:("number"==typeof t&&o.length===2*t+2||"any"===t)&&o.substring(0,e.length)===e}async emitMedianTimeEvents(){if(0===this.medianTimeEmitters.length)return;const t=(await this.getCkbRpc().getBlockchainInfo()).medianTime;for(const e of this.medianTimeEmitters)e.emit("changed",t)}subscribeMedianTime(){this.isSubscribeRunning=!0,this.scheduleLoop();const t=new a.EventEmitter;return this.medianTimeEmitters.push(t),t}};class TerminableCellAdapter{constructor(t){this.getCellsableRpc=t}async getCells(t,e=DefaultTerminator,o={}){const r=[];let i=o.lastCursor;const n=o.sizeLimit||100,a=o.order||"asc";for(;;){const o=await this.getCellsableRpc.getCells(t,a,`0x${n.toString(16)}`,i),s=o.objects;i=o.lastCursor;for(const t of s){const o={cellOutput:t.output,data:t.outputData,outPoint:t.outPoint?t.outPoint:void 0,blockNumber:t.blockNumber},{stop:n,push:a}=e(0,o);if(a&&r.push(o),n)return{objects:r,lastCursor:i}}if(s.length<=n)break}return{objects:r,lastCursor:i}}}e.TerminableCellAdapter=TerminableCellAdapter},823550:(t,e)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.toSearchKey=e.toSearchFilter=e.toScript=e.toGetTransactionsSearchKey=e.toGetCellsSearchKey=void 0;const toScript=t=>({code_hash:t.codeHash,hash_type:t.hashType,args:t.args});e.toScript=toScript;const toSearchFilter=t=>({script:t.script?toScript(t.script):t.script,output_data_len_range:t.outputDataLenRange,output_capacity_range:t.outputCapacityRange,block_range:t.blockRange,script_len_range:t.scriptLenRange});e.toSearchFilter=toSearchFilter;const toSearchKey=t=>({script:toScript(t.script),script_type:t.scriptType,filter:t.filter?toSearchFilter(t.filter):t.filter,script_search_mode:t.scriptSearchMode?t.scriptSearchMode:"prefix"});e.toSearchKey=toSearchKey;e.toGetCellsSearchKey=t=>({...toSearchKey(t),with_data:t.withData});e.toGetTransactionsSearchKey=t=>({...toSearchKey(t),group_by_transaction:t.groupByTransaction})},66087:(t,e)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.toTip=e.toSearchKey=e.toSearchFilter=e.toScript=e.toOutPoint=e.toCellOutPut=void 0;e.toTip=t=>({blockHash:t.block_hash,blockNumber:t.block_number});const toScript=t=>({codeHash:t.code_hash,hashType:t.hash_type,args:t.args});e.toScript=toScript;e.toOutPoint=t=>({txHash:t.tx_hash,index:t.index});e.toCellOutPut=t=>({...t,lock:toScript(t.lock),type:t.type?toScript(t.type):void 0});const toSearchFilter=t=>({script:t.script?toScript(t.script):t.script,outputDataLenRange:t.output_data_len_range,outputCapacityRange:t.output_capacity_range,scriptLenRange:t.script_len_range,blockRange:t.block_range});e.toSearchFilter=toSearchFilter;e.toSearchKey=t=>({script:toScript(t.script),scriptType:t.script_type,filter:t.filter?toSearchFilter(t.filter):t.filter,scriptSearchMode:t.script_search_mode})},129021:(t,e,o)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.RPC=void 0;var r=o(140993),i=function _interopRequireDefault(t){return t&&t.__esModule?t:{default:t}}(o(410288)),n=o(823550);e.RPC=class RPC{constructor(t){this.uri=t}async getTip(){return r.utils.deepCamel(await request(this.uri,"get_tip"))}async getCells(t,e,o,i){const a=[(0,n.toGetCellsSearchKey)(t),e,o,i];return r.utils.deepCamel(await request(this.uri,"get_cells",a))}async getTransactions(t,e,o,i){const a=[(0,n.toGetTransactionsSearchKey)(t),e,o,i];return r.utils.deepCamel(await request(this.uri,"get_transactions",a))}async getIndexerInfo(){return r.utils.deepCamel(await request(this.uri,"get_indexer_info"))}};const request=async(t,e,o)=>{const r=await(0,i.default)(t,{method:"POST",body:JSON.stringify({id:0,jsonrpc:"2.0",method:e,params:o}),headers:{"Content-Type":"application/json"}});if(200!==r.status)throw new Error(`indexer request failed with HTTP code ${r.status}`);const n=await r.json();if(void 0!==n.error)throw new Error(`indexer request rpc failed with error: ${JSON.stringify(n.error)}`);return n.result}},821824:(t,e,o)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.getHexStringBytes=e.generateSearchKey=void 0,e.requestBatch=requestBatch,e.requestBatchTransactionWithStatus=async function requestBatchTransactionWithStatus(t,e){if(0===e.length)return[];const o=e.map(((t,e)=>({id:e,jsonrpc:"2.0",method:"get_transaction",params:[t]})));return(await requestBatch(t,o)).map((t=>l.ResultFormatter.toTransactionWithStatus(t.result)))};var r=o(140993),i=function _interopRequireDefault(t){return t&&t.__esModule?t:{default:t}}(o(410288)),n=o(739609),a=o(823550),s=o(66087),c=o(438341),l=o(436115);e.generateSearchKey=t=>{let e;const o={};let r,i="prefix";if(t.lock){const i=(0,c.unwrapScriptWrapper)(t.lock);if(e=(0,a.toScript)(i),r="lock",t.type&&"string"!=typeof t.type){const e=(0,c.unwrapScriptWrapper)(t.type);o.script=(0,a.toScript)(e)}}else if(t.type&&"string"!=typeof t.type){const o=(0,c.unwrapScriptWrapper)(t.type);e=(0,a.toScript)(o),r="type"}let l=null;if(t.fromBlock&&t.toBlock&&(l=[t.fromBlock,`0x${n.BI.from(t.toBlock).add(1).toString(16)}`]),l&&(o.block_range=l),t.outputDataLenRange&&(o.output_data_len_range=t.outputDataLenRange),t.outputCapacityRange&&(o.output_capacity_range=t.outputCapacityRange),t.scriptLenRange&&(o.script_len_range=t.scriptLenRange),t.scriptSearchMode&&(i=t.scriptSearchMode),!e)throw new Error("Either lock or type script must be provided!");if(!r)throw new Error("script_type must be provided");return(0,s.toSearchKey)({script:e,script_type:r,filter:o,script_search_mode:i})};e.getHexStringBytes=t=>(r.utils.assertHexString("",t),Math.ceil(t.substr(2).length/2));let u=0;async function requestBatch(t,e){if(!e.length)return[];const o=await(0,i.default)(t,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(e.map((t=>({id:u++,...t}))))});if(200!==o.status)throw new Error(`Indexer request failed with HTTP code ${o.status}`);const r=await o.json();if(void 0!==r.error)throw new Error(`indexer request rpc failed with error: ${JSON.stringify(r.error)}`);return r}},891730:(t,e,o)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.CKBIndexerTransactionCollector=void 0;var r=o(140993),i=o(438341),n=function _interopRequireWildcard(t,e){if(!e&&t&&t.__esModule)return t;if(null===t||"object"!=typeof t&&"function"!=typeof t)return{default:t};var o=_getRequireWildcardCache(e);if(o&&o.has(t))return o.get(t);var r={__proto__:null},i=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var n in t)if("default"!==n&&{}.hasOwnProperty.call(t,n)){var a=i?Object.getOwnPropertyDescriptor(t,n):null;a&&(a.get||a.set)?Object.defineProperty(r,n,a):r[n]=t[n]}return r.default=t,o&&o.set(t,r),r}(o(821824));function _getRequireWildcardCache(t){if("function"!=typeof WeakMap)return null;var e=new WeakMap,o=new WeakMap;return(_getRequireWildcardCache=function(t){return t?o:e})(t)}class CKBIndexerTransactionCollector extends r.indexer.TransactionCollector{constructor(t,e,o,r){super(t,e,r),this.indexer=t,this.queries=e,this.CKBRpcUrl=o,this.options=r;this.filterOptions={skipMissing:!1,includeStatus:!0,...this.options}}static asBaseTransactionCollector(t){return class extends r.indexer.TransactionCollector{constructor(e,o,r){return super(e,o,r),new CKBIndexerTransactionCollector(e,o,t,r)}}}async fetchIndexerTransaction(t,e){const o={sizeLimit:t.bufferSize,order:t.order};e&&(o.lastCursor=e);let r={objects:[],lastCursor:""};return(0,i.instanceOfScriptWrapper)(t.lock)&&(0,i.instanceOfScriptWrapper)(t.type)?(r=await this.getTransactionByLockAndTypeIndependent(o),e=r.lastCursor):(r=await this.indexer.getTransactions(n.generateSearchKey(t),o),e=r.lastCursor),r.objects=this.filterByTypeIoTypeAndLockIoType(r.objects,t),r}getResolvedTransactionRequestPayload(t,e){const o=[];return t.forEach(((t,r)=>{const i=e.objects[r];if("input"===i.ioType){const e=t.transaction.inputs[Number(i.ioIndex)].previousOutput;o.push(e.txHash)}})),o}getResolvedCell(t,e,o){if("input"!==o.ioType)return t.transaction.outputs[Number(o.ioIndex)];{const r=t.transaction.inputs[Number(o.ioIndex)].previousOutput,i=e.find((t=>t.transaction.hash===r.txHash));if(!i)throw new Error("Impossible: can NOT find resolved transaction!");return i.transaction.outputs[Number(r.index)]}}filterTransaction(t,e,o){return t.filter(((t,r)=>{const i=this.getResolvedCell(t,e,o.objects[r]);return this.isCellScriptArgsValid(i)})).map((t=>({transaction:t.transaction,txStatus:t.txStatus,cycles:t.cycles,timeAddedToPool:t.timeAddedToPool,minReplaceFee:t.minReplaceFee,fee:t.fee})))}async getTransactions(t){const e=await this.fetchIndexerTransaction(this.queries,t);if(t=e.lastCursor,0===e.objects.length)return{objects:[],lastCursor:t};const o=await this.getTransactionListFromRpc(e),r=this.getResolvedTransactionRequestPayload(o,e),i=await n.requestBatchTransactionWithStatus(this.CKBRpcUrl,r);return{objects:this.filterTransaction(o,i,e),lastCursor:t}}async getTransactionByLockAndTypeIndependent(t){const e={...t},o={...t};if(t.lastCursor){const[r,i]=t.lastCursor.split("-");o.lastCursor=r,e.lastCursor=i}const r={...this.queries,type:void 0},i=await this.indexer.getTransactions(n.generateSearchKey(r),e),a={...this.queries,lock:void 0},s=await this.indexer.getTransactions(n.generateSearchKey(a),o);return{objects:((t,e)=>{const o=[];return t.forEach((t=>{const r=e.find((e=>e.txHash===t.txHash));if(r){const e="output"===t.ioType?t:r;o.push({...e,ioType:"both"})}})),o})(s.objects,i.objects),lastCursor:i.lastCursor+"-"+s.lastCursor}}getTransactionListFromRpc=async t=>{const e=t.objects.map((t=>t.txHash));return await n.requestBatchTransactionWithStatus(this.CKBRpcUrl,e).then((e=>e.map(((e,o)=>{if(!this.filterOptions.skipMissing&&!e.transaction)throw new Error(`Transaction ${t.objects[o].txHash} is missing!`);return e}))))};isLockArgsLenMatched=(t,e)=>!e||("any"===e||(-1===e||n.getHexStringBytes(t)===e));isCellScriptArgsValid=t=>{if(this.queries.lock){const e=(0,i.instanceOfScriptWrapper)(this.queries.lock)?this.queries.lock.argsLen:this.queries.argsLen;if(!this.isLockArgsLenMatched(t.lock.args,e))return!1}if(this.queries.type&&"empty"!==this.queries.type){var e;const o=(0,i.instanceOfScriptWrapper)(this.queries.type)?this.queries.type.argsLen:this.queries.argsLen;if(!this.isLockArgsLenMatched(null===(e=t.type)||void 0===e?void 0:e.args,o))return!1}return!this.queries.type||"empty"!==this.queries.type||!t.type};filterByIoType=(t,e)=>"both"===e?t:"input"===e||"output"===e?t.filter((t=>t.ioType===e||"both"===t.ioType)):t;filterByTypeIoTypeAndLockIoType=(t,e)=>{let o=t;return(0,i.instanceOfScriptWrapper)(e.lock)&&e.lock.ioType&&(o=this.filterByIoType(o,e.lock.ioType)),(0,i.instanceOfScriptWrapper)(e.type)&&e.type.ioType&&(o=this.filterByIoType(o,e.type.ioType)),o};async count(){let t;const getTxWithCursor=async()=>{const e=await this.getTransactions(t);return t=e.lastCursor,e.objects};let e=0,o=await getTxWithCursor();if(0===o.length)return 0;let r=getTxWithCursor(),i=0,n=0;for(;;)if(this.queries.skip&&n<this.queries.skip?n++:e+=1,i++,i===o.length){if(i=0,o=await r,0===o.length)break;r=getTxWithCursor()}return e}async getTransactionHashes(){let t;const getTxWithCursor=async()=>{const e=await this.getTransactions(t);return t=e.lastCursor,e.objects},e=[];let o=await getTxWithCursor();if(0===o.length)return[];let r=getTxWithCursor(),i=0,n=0;for(;;)if(this.queries.skip&&n<this.queries.skip?n++:o[i].transaction.hash&&e.push(o[i].transaction.hash),i++,i===o.length){if(i=0,o=await r,0===o.length)break;r=getTxWithCursor()}return e}async*collect(){let t;const getTxWithCursor=async()=>{const e=await this.getTransactions(t);return t=e.lastCursor,e.objects};let e=await getTxWithCursor();if(0===e.length)return;let o=getTxWithCursor(),r=0,i=0;for(;;)if(this.queries.skip&&i<this.queries.skip?i++:this.filterOptions.includeStatus?yield e[r]:yield e[r].transaction,r++,r===e.length){if(r=0,e=await o,0===e.length)break;o=getTxWithCursor()}}}e.CKBIndexerTransactionCollector=CKBIndexerTransactionCollector},533060:(t,e,o)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.IndexerEmitter=void 0;var r=o(450046);class IndexerEmitter extends r.EventEmitter{}e.IndexerEmitter=IndexerEmitter},518042:(t,e,o)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.WitnessArgs=e.BytesVec=e.BytesOpt=e.Bytes=e.Byte32Vec=e.Byte32=void 0,e.WitnessArgsOf=WitnessArgsOf,e.createFixedHexBytesCodec=createFixedHexBytesCodec;var r=o(220941),i=o(542069),n=o(640035);function createFixedHexBytesCodec(t){return(0,r.createFixedBytesCodec)({byteLength:t,pack:t=>(0,i.bytify)(t),unpack:t=>(0,i.hexify)(t)})}const a=e.Bytes=(0,n.byteVecOf)({pack:i.bytify,unpack:i.hexify}),s=(e.BytesOpt=(0,n.option)(a),e.BytesVec=(0,n.vector)(a),e.Byte32=createFixedHexBytesCodec(32));e.Byte32Vec=(0,n.vector)(s);function WitnessArgsOf(t){return(0,n.table)({lock:(0,n.option)((0,n.byteVecOf)(t.lock)),input_type:(0,n.option)((0,n.byteVecOf)(t.input_type)),output_type:(0,n.option)((0,n.byteVecOf)(t.output_type))},["lock","input_type","output_type"])}const c=(0,r.createBytesCodec)({pack:i.bytify,unpack:i.hexify});e.WitnessArgs=WitnessArgsOf({lock:c,input_type:c,output_type:c})},911584:(t,e,o)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.CellCollector=void 0,e.checkLimit=checkLimit,e.default=void 0,e.injectCapacity=injectCapacity,e.prepareSigningEntries=prepareSigningEntries,e.setupInputCell=setupInputCell,e.setupOutputCell=setupOutputCell,e.withdraw=withdraw;var r=o(140993),i=o(852966),n=o(519808),a=o(893597),s=o(706081),c=o(739609),l=o(446037),u=o(555258),p=o(77922);const{ScriptValue:d}=r.values,{CKBHasher:f,ckbHash:h}=r.utils,g=e.CellCollector=class CellCollector{constructor(t,e,{config:o,queryOptions:r={}}={}){if(!e)throw new Error("Cell provider is missing!");o=o||(0,n.getConfig)(),this.fromScript=(0,l.parseFromInfo)(t,{config:o}).fromScript,this.config=o,r={...r,lock:this.fromScript,type:r.type||"empty"},this.cellCollector=e.collector(r)}async*collect(){if((0,u.isAcpScript)(this.fromScript,this.config))for await(const t of this.cellCollector.collect())yield t}};async function setupInputCell(t,e,o,{config:a,defaultWitness:s="0x",since:c}={}){a=a||(0,n.getConfig)();const l=e.cellOutput.lock;if(!(0,u.isAcpScript)(l,a))throw new Error("Not anyone-can-pay input!");t=t.update("inputs",(t=>t.push(e))),c&&(t=t.update("inputSinces",(e=>e.set(t.get("inputs").size-1,c)))),t=t.update("witnesses",(t=>t.push(s)));const p={cellOutput:{capacity:e.cellOutput.capacity,lock:e.cellOutput.lock,type:e.cellOutput.type},data:e.data};t=(t=t.update("outputs",(t=>t.push(p)))).update("fixedEntries",(e=>e.push({field:"outputs",index:t.get("outputs").size-1})));const f=a.SCRIPTS.ANYONE_CAN_PAY;if(!f)throw new Error("ANYONE_CAN_PAY script not defined in config!");const h={txHash:f.TX_HASH,index:f.INDEX},g=(t=(0,u.addCellDep)(t,{outPoint:h,depType:f.DEP_TYPE})).get("inputs").findIndex((t=>new d(t.cellOutput.lock,{validate:!1}).equals(new d(l,{validate:!1}))));if(-1!==g){for(;g>=t.get("witnesses").size;)t=t.update("witnesses",(t=>t.push("0x")));let e=t.get("witnesses").get(g);const o={lock:u.SECP_SIGNATURE_PLACEHOLDER};if("0x"!==e){const t=r.blockchain.WitnessArgs.unpack(i.bytes.bytify(e)),n=t.lock;if(n&&o.lock&&!i.bytes.equal(n,o.lock))throw new Error("Lock field in first witness is set aside for signature!");const a=t.inputType;a&&(o.inputType=a);const s=t.outputType;s&&(o.outputType=s)}e=i.bytes.hexify(r.blockchain.WitnessArgs.pack(o)),t=t.update("witnesses",(t=>t.set(g,e)))}return t}function checkLimit(t,e){const o=c.BI.from(e);let r,i;if(t.length>=46&&(r=c.BI.from(10).pow("0x"+t.slice(44,46))),t.length>=44){const e=c.BI.from(10).pow("0x"+t.slice(42,44)),o=c.BI.from(10).pow(8);i=e.mul(o)}if(i&&r){if(o.lt(i))throw new Error(`capacity(${e}) less than toAddress minimal capacity limit(${i}), and amount less then toAddress minimal amount limit(${r})! If you want to transfer sudt, maybe sudt.transfer can help you.`)}else if(i&&o.lt(i))throw new Error(`capacity(${e}) less than toAddress minimal capacity limit(${i})!`)}async function setupOutputCell(t,e,{config:o}={}){o=o||(0,n.getConfig)();const r=e.cellOutput.lock,i=c.BI.from(e.cellOutput.capacity);checkLimit(r.args,i.toString());const s=t.get("cellProvider");if(!s)throw new Error("Cell Provider is missing!");const l=(0,a.generateAddress)(r,{config:o}),p=new g(l,s,{config:o}),d=(await p.collect().next()).value;let f=i;if(d&&(f=i.add(d.cellOutput.capacity),t=(t=t.update("inputs",(t=>t.push(d)))).update("witnesses",(t=>t.push("0x")))),e.cellOutput.capacity="0x"+f.toString(16),t=t.update("outputs",(t=>t.push(e))),d){const e=o.SCRIPTS.ANYONE_CAN_PAY;if(!e)throw new Error("ANYONE_CAN_PAY script not defined in config!");const r={txHash:e.TX_HASH,index:e.INDEX};t=(0,u.addCellDep)(t,{outPoint:r,depType:e.DEP_TYPE})}return t}async function injectCapacity(t,e,o,r,{config:i}={}){if(i=i||(0,n.getConfig)(),o>=e.get("outputs").size)throw new Error("Invalid output index!");let l=c.BI.from(r);if(!i.SCRIPTS.ANYONE_CAN_PAY)throw new Error("Provided config does not have ANYONE_CAN_PAY script setup!");const u=t.fromScript,p=e.get("fixedEntries").filter((({field:t})=>"outputs"===t)).maxBy((({index:t})=>t));let f=p?p.index+1:0;for(;f<e.get("outputs").size&&l.gt(0);f++){const t=e.get("outputs").get(f);if(new d(t.cellOutput.lock,{validate:!1}).equals(new d(u,{validate:!1}))){const e=c.BI.from(t.cellOutput.capacity),o=e.sub((0,a.minimalCellCapacityCompatible)(t)),r=l.gte(o)?o:l;l=l.sub(r),t.cellOutput.capacity="0x"+e.sub(r).toString(16)}}e=e.update("outputs",(t=>t.filter((t=>!c.BI.from(t.cellOutput.capacity).eq(0)))));const getInputKey=t=>`${t.outPoint.txHash}_${t.outPoint.index}`;if(l.gt(0)){const o={cellOutput:{capacity:"0x0",lock:u,type:void 0},data:"0x",outPoint:void 0,blockHash:void 0};let r=c.BI.from(0);const n=c.BI.from((0,a.minimalCellCapacityCompatible)(o));let p=(0,s.Set)();for(const t of e.get("inputs"))p=p.add(getInputKey(t));for await(const a of t.collect()){if(p.has(getInputKey(a)))continue;const t=(e=await setupInputCell(e,a,0,{config:i})).get("outputs").size-1,s=(e=e.update("outputs",(e=>e.remove(t)))).get("fixedEntries").findIndex((e=>"outputs"===e.field&&e.index===t));s>=0&&(e=e.update("fixedEntries",(t=>t.remove(s))));const u=c.BI.from(a.cellOutput.capacity);let d=u;if(d.gt(l)&&(d=l),l=l.sub(d),r=r.add(u.sub(d)),l.eq(0)&&r.gte(n))break;o.cellOutput.capacity="0x"+r.toString(16),e=e.update("outputs",(t=>t.push(o)))}if(l.gt(0)||r<n)throw new Error("Not enough capacity in from address!");o.cellOutput.capacity="0x"+r.toString(16),e=e.update("outputs",(t=>t.push(o)))}return e}function prepareSigningEntries(t,{config:e}={}){const o="ANYONE_CAN_PAY",i=(e=e||(0,n.getConfig)()).SCRIPTS[o];if(!i)throw new Error(`Provided config does not have ${o} script setup!`);let l=(0,s.Set)();const g=(0,a.createTransactionFromSkeleton)(t),y=h(r.blockchain.RawTransaction.pack(g)),m=t.get("inputs"),b=t.get("witnesses");let C=t.get("signingEntries");for(let e=0;e<m.size;e++){const o=m.get(e);if(i.CODE_HASH===o.cellOutput.lock.codeHash&&i.HASH_TYPE===o.cellOutput.lock.hashType&&!l.has(o.cellOutput.lock.args)){l=l.add(o.cellOutput.lock.args);const i=t.get("outputs").filter((t=>new d(t.cellOutput.lock,{validate:!1}).equals(new d(o.cellOutput.lock,{validate:!1})))),n=i.map((t=>c.BI.from(t.cellOutput.capacity))).reduce(((t,e)=>t.add(e)),c.BI.from(0)),a=i.filter((t=>"0x"!==t.data)).map((t=>(0,p.unpackAmount)(t.data))).reduce(((t,e)=>t.add(e)),c.BI.from(0)),s=m.filter((t=>new d(t.cellOutput.lock,{validate:!1}).equals(new d(o.cellOutput.lock,{validate:!1})))),h=s.map((t=>c.BI.from(t.cellOutput.capacity))).reduce(((t,e)=>t.add(e)),c.BI.from(0)),g=s.filter((t=>"0x"!==t.data)).map((t=>c.BI.from((0,p.unpackAmount)(t.data)))).reduce(((t,e)=>t.add(e)),c.BI.from(0));if(h.lte(n)&&g.lte(a))continue;const S=new r.values.ScriptValue(o.cellOutput.lock,{validate:!1}),_=new f;if(_.update(y),e>=b.size)throw new Error(`The first witness in the script group starting at input index ${e} does not exist, maybe some other part has invalidly tampered the transaction?`);(0,u.hashWitness)(_,b.get(e));for(let t=e+1;t<m.size&&t<b.size;t++){const e=m.get(t);S.equals(new r.values.ScriptValue(e.cellOutput.lock,{validate:!1}))&&(0,u.hashWitness)(_,b.get(t))}for(let t=m.size;t<b.size;t++)(0,u.hashWitness)(_,b.get(t));const k={type:"witness_args_lock",index:e,message:_.digestHex()};C=C.push(k)}}return t=t.set("signingEntries",C)}async function withdraw(t,e,o,r,{config:i}={}){if(i=i||(0,n.getConfig)(),!(0,u.isAcpScript)(e.cellOutput.lock,i))throw new Error("fromInput is not a ANYONE_CAN_PAY cell!");const s=c.BI.from(r),l=c.BI.from(e.cellOutput.capacity),p=c.BI.from((0,a.minimalCellCapacityCompatible)(e));if(!(s.gte(0)&&s.lte(l.sub(p))||s.eq(l)))throw new Error(`capacity must be in [0, ${l.sub(p)}] or ${l} !`);const d=(0,a.parseAddress)(o,{config:i}),f={cellOutput:{capacity:"0x"+r.toString(16),lock:d,type:void 0},data:"0x",outPoint:void 0,blockHash:void 0};if((0,u.isAcpScript)(d,i)){checkLimit(d.args,r);const e=t.get("cellProvider");if(!e)throw new Error("Cell Provider is missing!");const n=new g(o,e,{config:i}),a=(await n.collect().next()).value;if(!a)throw new Error("toAddress ANYONE_CAN_PAY input not found!");const c=s.add(a.cellOutput.capacity);f.cellOutput.capacity="0x"+c.toString(16),t=(t=t.update("inputs",(t=>t.push(a)))).update("witnesses",(t=>t.push("0x")))}t=t.update("outputs",(t=>t.push(f)));const h=(t=await setupInputCell(t,e,(0,a.generateAddress)(e.cellOutput.lock,{config:i}),{config:i})).get("outputs").size-1,y=(t=t.update("outputs",(t=>t.remove(h)))).get("fixedEntries").findIndex((t=>"outputs"===t.field&&t.index===h));return y>=0&&(t=t.update("fixedEntries",(t=>t.remove(y)))),s.eq(l)||(t=t.update("outputs",(t=>t.push({cellOutput:{capacity:"0x"+l.sub(r).toString(16),lock:e.cellOutput.lock,type:e.cellOutput.type},data:e.data})))),t}e.default={CellCollector:g,setupInputCell,setupOutputCell,injectCapacity,prepareSigningEntries,withdraw}},974247:(t,e,o)=>{"use strict";var r=o(901048).Buffer;Object.defineProperty(e,"__esModule",{value:!0}),e.default=void 0,e.injectCapacity=injectCapacity,e.payFee=payFee,e.payFeeByFeeRate=payFeeByFeeRate,e.prepareSigningEntries=prepareSigningEntries,e.registerCustomLockScriptInfos=registerCustomLockScriptInfos,e.setupInputCell=setupInputCell,e.transfer=transfer;var i=o(893597),n=_interopRequireDefault(o(342202)),a=o(446037),s=_interopRequireDefault(o(574393)),c=o(519808),l=function _interopRequireWildcard(t,e){if(!e&&t&&t.__esModule)return t;if(null===t||"object"!=typeof t&&"function"!=typeof t)return{default:t};var o=_getRequireWildcardCache(e);if(o&&o.has(t))return o.get(t);var r={__proto__:null},i=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var n in t)if("default"!==n&&{}.hasOwnProperty.call(t,n)){var a=i?Object.getOwnPropertyDescriptor(t,n):null;a&&(a.get||a.set)?Object.defineProperty(r,n,a):r[n]=t[n]}return r.default=t,o&&o.set(t,r),r}(o(474233)),u=o(140993),p=_interopRequireDefault(o(911584)),d=o(706081),f=o(555258),h=o(739609),g=_interopRequireDefault(o(478988));function _getRequireWildcardCache(t){if("function"!=typeof WeakMap)return null;var e=new WeakMap,o=new WeakMap;return(_getRequireWildcardCache=function(t){return t?o:e})(t)}function _interopRequireDefault(t){return t&&t.__esModule?t:{default:t}}const{ScriptValue:y}=u.values;function defaultLogger(t,e){console.log(`[${t}] ${e}`)}const m={configHashCode:0,_predefinedInfos:[],_customInfos:[],get infos(){return[...this._predefinedInfos,...this._customInfos]}};function registerCustomLockScriptInfos(t){m._customInfos=t}function generateLockScriptInfos({config:t}={}){t=t||(0,c.getConfig)();const getPredefinedInfos=()=>{var e,o,r,i;const a=null===(e=t)||void 0===e?void 0:e.SCRIPTS.SECP256K1_BLAKE160,c=null===(o=t)||void 0===o?void 0:o.SCRIPTS.SECP256K1_BLAKE160_MULTISIG,l=null===(r=t)||void 0===r?void 0:r.SCRIPTS.ANYONE_CAN_PAY,u=null===(i=t)||void 0===i?void 0:i.SCRIPTS.OMNILOCK,d=[];return a?d.push({codeHash:a.CODE_HASH,hashType:a.HASH_TYPE,lockScriptInfo:s.default}):defaultLogger("warn","SECP256K1_BLAKE160 script info not found in config!"),c?d.push({codeHash:c.CODE_HASH,hashType:c.HASH_TYPE,lockScriptInfo:n.default}):defaultLogger("warn","SECP256K1_BLAKE160_MULTISIG script info not found in config!"),l?d.push({codeHash:l.CODE_HASH,hashType:l.HASH_TYPE,lockScriptInfo:p.default}):defaultLogger("warn","ANYONE_CAN_PAY script info not found in config!"),u?d.push({codeHash:u.CODE_HASH,hashType:u.HASH_TYPE,lockScriptInfo:g.default}):defaultLogger("warn","OMNILOCK script info not found in config!"),d},e=u.utils.hashCode(r.from(JSON.stringify(t)));0===m.infos.length?(m._predefinedInfos=getPredefinedInfos(),m.configHashCode=e):e!==m.configHashCode&&(defaultLogger("warn","`config` changed, regenerate lockScriptInfos!"),m._predefinedInfos=getPredefinedInfos(),m.configHashCode=e)}async function transfer(t,e,o,r,n,a,{config:s,useLocktimeCellsFirst:u=!0,LocktimePoolCellCollector:p=l.CellCollector}={}){var d;s=s||(0,c.getConfig)();const f=h.BI.from(r);if(!o)throw new Error("You must provide a to address!");const g=(0,i.parseAddress)(o,{config:s}),y={cellOutput:{capacity:"0x"+f.toString(16),lock:g,type:void 0},data:"0x"};generateLockScriptInfos({config:s});const b=m.infos.find((t=>t.codeHash===g.codeHash&&t.hashType===g.hashType));return t=b&&null!==(d=b.lockScriptInfo)&&void 0!==d&&d.setupOutputCell?await b.lockScriptInfo.setupOutputCell(t,y,{config:s}):t.update("outputs",(t=>t.push(y))),t=await injectCapacity(t,e,f.toString(),n,a,{config:s,useLocktimeCellsFirst:u,LocktimePoolCellCollector:p})}async function injectCapacity(t,e,o,r,n,{config:s,useLocktimeCellsFirst:u=!0,LocktimePoolCellCollector:p=l.CellCollector,enableDeductCapacity:d=!0}={}){s=s||(0,c.getConfig)();let f=h.BI.from(o);if(0===e.length)throw new Error("No from info provided!");const g={cellOutput:{capacity:"0x0",lock:(0,a.parseFromInfo)(r||e[0],{config:s}).fromScript,type:void 0},data:"0x"},y=h.BI.from((0,i.minimalCellCapacityCompatible)(g));let m=h.BI.from(0);if(u){if(n){const o=await l.default.injectCapacityWithoutChangeCompatible(t,e,f.toString(),n,y.toString(),{config:s,LocktimeCellCollector:p,enableDeductCapacity:d});t=o.txSkeleton,f=h.BI.from(o.capacity),m=h.BI.from(o.changeCapacity)}if(f.gt(0)){const o=await _commonTransferCompatible(t,e,f,y,{config:s,enableDeductCapacity:d});t=o.txSkeleton,f=o.capacity,m=o.changeCapacity}else if(f.eq(0)&&m.gt(0)&&m.lt(y)){const o=await _commonTransferCompatible(t,e,y.sub(m),h.BI.from(0),{config:s,enableDeductCapacity:d});t=o.txSkeleton,f=o.capacity,m=o.changeCapacity}}else{const o=await _commonTransferCompatible(t,e,f,y,{config:s,enableDeductCapacity:d});if(t=o.txSkeleton,f=o.capacity,m=o.changeCapacity,n)if(f.gt(0)){const o=await l.default.injectCapacityWithoutChangeCompatible(t,e,f.toString(),n,y.toString(),{config:s,LocktimeCellCollector:p,enableDeductCapacity:d});t=o.txSkeleton,f=h.BI.from(o.capacity),m=h.BI.from(o.changeCapacity)}else if(f.eq(0)&&m.gt(0)&&m.lt(y)){const o=await l.default.injectCapacityWithoutChangeCompatible(t,e,y.sub(m).toString(),n,0,{config:s,LocktimeCellCollector:p,enableDeductCapacity:d});t=o.txSkeleton,f=h.BI.from(o.capacity),m=h.BI.from(o.changeCapacity)}}if(f.gt(0))throw new Error("Not enough capacity in from infos!");if(m.gt(0)&&m.lt(y))throw new Error("Not enough capacity in from infos for change!");return m.gt(0)&&(g.cellOutput.capacity="0x"+m.toString(16),t=t.update("outputs",(t=>t.push(g)))),t}async function payFee(t,e,o,r,{config:i,useLocktimeCellsFirst:n=!0,enableDeductCapacity:a=!0}={}){return injectCapacity(t,e,o,void 0,r,{config:i,useLocktimeCellsFirst:n,enableDeductCapacity:a})}function prepareSigningEntries(t,{config:e}={}){generateLockScriptInfos({config:e=e||(0,c.getConfig)()});for(const o of m.infos)t=o.lockScriptInfo.prepareSigningEntries(t,{config:e});return t}async function _commonTransferCompatible(t,e,o,r,{config:i,enableDeductCapacity:n=!0}={}){i=i||(0,c.getConfig)();let s=h.BI.from(o);const l=t.get("cellProvider");if(!l)throw new Error("Cell Provider is missing!");const getInputKey=t=>{var e,o;return`${null===(e=t.outPoint)||void 0===e?void 0:e.txHash}_${null===(o=t.outPoint)||void 0===o?void 0:o.index}`};let u=(0,d.Set)();for(const e of t.get("inputs"))u=u.add(getInputKey(e));const p=e.map((t=>(0,a.parseFromInfo)(t,{config:i}).fromScript));for(const e of p)n&&s.gt(0)&&([t,s]=_deductCapacityCompatible(t,e,s));generateLockScriptInfos({config:i});let f=h.BI.from(0);if(s.gt(0))t:for(const o of e){const e=m.infos.map((t=>new t.lockScriptInfo.CellCollector(o,l,{config:i})));for(const n of e)for await(const e of n.collect()){const n=getInputKey(e);if(u.has(n))continue;u=u.add(n);const a=await collectInputCompatible(t,e,o,{config:i,needCapacity:s});t=a.txSkeleton;const c=h.BI.from(a.availableCapacity);let l=c;if(l.gt(s)&&(l=s),s=s.sub(l),f=f.add(c.sub(l)),s.eq(0)&&(f.eq(0)||f.gt(r)))break t}}return{txSkeleton:t,capacity:s,changeCapacity:f}}function _deductCapacityCompatible(t,e,o){let r=h.BI.from(o);const n=t.get("fixedEntries").filter((({field:t})=>"outputs"===t)).maxBy((({index:t})=>t));let a=n?n.index+1:0;for(;a<t.get("outputs").size&&r.gt(0);a++){const n=t.get("outputs").get(a);if(n&&new y(n.cellOutput.lock,{validate:!1}).equals(new y(e,{validate:!1}))){const e=JSON.parse(JSON.stringify(n)),s=h.BI.from(e.cellOutput.capacity),c=s;let l;r.gte(c)?l=c:(l=s.sub((0,i.minimalCellCapacityCompatible)(e)),l.gt(o)&&(l=o)),r=r.sub(l),e.cellOutput.capacity="0x"+s.sub(l).toString(16),t=t.update("outputs",(t=>t.update(a,(()=>e))))}}return[t=t.update("outputs",(t=>t.filter((t=>h.BI.from(t.cellOutput.capacity).toString()!==h.BI.from(0).toString())))),r]}async function collectInputCompatible(t,e,o,{config:r,since:n,defaultWitness:a="0x",needCapacity:s}={}){r=r||(0,c.getConfig)();const l=(t=await setupInputCell(t,e,o,{config:r,since:n,defaultWitness:a})).get("outputs").size-1,u=t.get("outputs").get(l);if(!u)throw new Error("Impossible: can not find last output");const p=h.BI.from(u.cellOutput.capacity),d=t.get("fixedEntries").findIndex((t=>"outputs"===t.field&&t.index===l)),g=e.cellOutput.lock;let y=h.BI.from(0);if(r.SCRIPTS.ANYONE_CAN_PAY&&(0,f.isAcpScript)(g,r)){const e=!!(o&&"object"==typeof o&&"destroyable"in o&&o.destroyable),r=s?h.BI.from(s):p;if(e)y=p,t=t.update("outputs",(t=>t.remove(l))),d>=0&&(t=t.update("fixedEntries",(t=>t.remove(d))));else{const e=h.BI.from((0,i.minimalCellCapacityCompatible)(u)),o=p.sub(e),n=JSON.parse(JSON.stringify(u));let a=e;y=o,r.lt(o)&&(a=p.sub(r),y=r),n.cellOutput.capacity="0x"+a.toString(16),t=t.update("outputs",(t=>t.update(l,(()=>n))))}}else{var m;if(d<0)y=h.BI.from(null===(m=t.get("outputs").get(l))||void 0===m?void 0:m.cellOutput.capacity),t=t.update("outputs",(t=>t.remove(l)))}return{txSkeleton:t,availableCapacity:y}}async function setupInputCell(t,e,o,{config:r,since:i,defaultWitness:n}={}){generateLockScriptInfos({config:r=r||(0,c.getConfig)()});const a=e.cellOutput.lock,s=m.infos.find((t=>t.codeHash===a.codeHash&&t.hashType===a.hashType));if(!s)throw new Error("No LockScriptInfo found for setupInputCell!");return s.lockScriptInfo.setupInputCell(t,e,o,{config:r,since:i,defaultWitness:n})}async function payFeeByFeeRate(t,e,o,r,{config:i,useLocktimeCellsFirst:n=!0,enableDeductCapacity:a=!0}={}){let s=0,c=t,l=getTransactionSize(c);for(;l>s;){s=l;const u=calculateFeeCompatible(s,o);c=await payFee(t,e,u,r,{config:i,useLocktimeCellsFirst:n,enableDeductCapacity:a}),l=getTransactionSize(c)}return c}function calculateFeeCompatible(t,e){const o=h.BI.from(1e3),r=h.BI.from(t).mul(e),i=r.div(o);return i.mul(o).lt(r)?i.add(1):h.BI.from(i)}function getTransactionSize(t){return getTransactionSizeByTx((0,i.createTransactionFromSkeleton)(t))}function getTransactionSizeByTx(t){return u.blockchain.Transaction.pack(t).byteLength+4}e.default={transfer,payFee,prepareSigningEntries,injectCapacity,setupInputCell,registerCustomLockScriptInfos,payFeeByFeeRate,__tests__:{_commonTransfer:async function _commonTransfer(t,e,o,r,{config:i,enableDeductCapacity:n=!0}={}){const a=await _commonTransferCompatible(t,e,o,r,{config:i,enableDeductCapacity:n});return{txSkeleton:a.txSkeleton,capacity:BigInt(a.capacity.toString()),changeCapacity:BigInt(a.changeCapacity.toString())}},resetLockScriptInfos:function resetLockScriptInfos(){m.configHashCode=0,m._predefinedInfos=[],m._customInfos=[]},getLockScriptInfos:function getLockScriptInfos(){return m},generateLockScriptInfos,getTransactionSizeByTx,getTransactionSize,calculateFee:function calculateFee(t,e){const o=calculateFeeCompatible(t,e);return BigInt(o.toString())},calculateFeeCompatible}}},855292:(t,e,o)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.CellCollector=void 0,e.calculateDaoEarliestSince=calculateDaoEarliestSince,e.calculateDaoEarliestSinceCompatible=calculateDaoEarliestSinceCompatible,e.calculateMaximumWithdraw=calculateMaximumWithdraw,e.calculateMaximumWithdrawCompatible=calculateMaximumWithdrawCompatible,e.default=void 0,e.deposit=deposit,e.extractDaoDataCompatible=extractDaoDataCompatible,e.listDaoCells=listDaoCells,e.unlock=unlock;var r=o(893597),i=o(140993),n=o(852966),a=o(519808),s=_interopRequireDefault(o(574393)),c=_interopRequireDefault(o(342202)),l=o(446037),u=o(555258),p=o(739609),d=o(436115),f=_interopRequireDefault(o(974247));function _interopRequireDefault(t){return t&&t.__esModule?t:{default:t}}const{parseSince:h}=i.since,g="0x0000000000000000",y=p.BI.from(180);class CellCollector{constructor(t,e,o,{config:r}={}){if(!e)throw new Error("Cell Provider is missing!");r=r||(0,a.getConfig)();const i=(0,l.parseFromInfo)(t,{config:r}).fromScript,n=(0,u.generateDaoScript)(r),s="deposit"===o?g:"any";this.cellType=o,this.cellCollector=e.collector({lock:i,type:n,data:s})}async*collect(){for await(const t of this.cellCollector.collect())"withdraw"===this.cellType&&t.data===g||(yield t)}}async function*listDaoCells(t,e,o,{config:r}={}){const i=new CellCollector(e,t,o,{config:r});for await(const t of i.collect())yield t}async function deposit(t,e,o,i,{config:d,enableNonSystemScript:y=!1}={}){const m=(d=d||(0,a.getConfig)()).SCRIPTS.DAO;if(!m)throw new Error("Provided config does not have DAO script setup!");if(function _checkFromInfoSince(t,e){let o;if("string"==typeof t){const i=(0,r.parseAddress)(t,{config:e}).args;58===i.length&&(o=n.number.Uint64LE.unpack("0x"+i.slice(42)).toHexString())}else"R"in t&&(o=t.since);if(null!=o){const{relative:t,type:e}=h(o);if(t||"epochNumber"!==e)throw new Error("Can't deposit a dao cell with multisig locktime which not using absolute-epoch-number format!")}}(e,d),t=_addDaoCellDep(t,d),!o)throw new Error("You must provide a to address!");const b=(0,r.parseAddress)(o,{config:d}),C={codeHash:m.CODE_HASH,hashType:m.HASH_TYPE,args:"0x"},S=(t=t.update("outputs",(t=>t.push({cellOutput:{capacity:"0x"+p.BI.from(i).toString(16),lock:b,type:C},data:g,outPoint:void 0,blockHash:void 0})))).get("outputs").size-1;if(t=t.update("fixedEntries",(t=>t.push({field:"outputs",index:S}))),"string"==typeof e){const o=(0,r.parseAddress)(e,{config:d});(0,u.isSecp256k1Blake160Script)(o,d)?t=await s.default.injectCapacity(t,S,e,{config:d}):(0,u.isSecp256k1Blake160MultisigScript)(o,d)?t=await c.default.injectCapacity(t,S,e,{config:d}):y&&(t=await f.default.injectCapacity(t,[e],i,(0,r.encodeToAddress)((0,l.parseFromInfo)(e).fromScript,{config:d}),void 0,{config:d}))}else e&&((0,l.isMultisigFromInfo)(e)?t=await c.default.injectCapacity(t,S,e,{config:d}):y&&(t=await f.default.injectCapacity(t,[e],i,(0,r.encodeToAddress)((0,l.parseFromInfo)(e).fromScript,{config:d}),void 0,{config:d})));return t}function parseEpochCompatible(t){const e=p.BI.from(t);return{length:e.shr(40).and(4095),index:e.shr(24).and(4095),number:e.and(16777215)}}function epochSinceCompatible({length:t,index:e,number:o}){const r=p.BI.from(t),i=p.BI.from(e),n=p.BI.from(o);return p.BI.from(32).shl(56).add(r.shl(40)).add(i.shl(24)).add(n)}async function unlock(t,e,o,l,f,{config:h,RpcClient:m=d.RPC}={}){if(_checkDaoScript(h=h||(0,a.getConfig)()),t=_addDaoCellDep(t,h),!h.SCRIPTS.DAO)throw new Error("Provided config does not have DAO script setup!");const b=t.get("cellProvider");if(!b)throw new Error("Cell provider is missing!");const C=new m(b.uri),S=e.cellOutput.type,_=h.SCRIPTS.DAO;if(!S||S.codeHash!==_.CODE_HASH||S.hashType!==_.HASH_TYPE||e.data!==g)throw new Error("depositInput is not a DAO deposit cell.");const k=o.cellOutput.type;if(!k||k.codeHash!==_.CODE_HASH||k.hashType!==_.HASH_TYPE||o.data===g)throw new Error("withdrawInput is not a DAO withdraw cell.");const w=await C.getHeader(e.blockHash),x=parseEpochCompatible(w.epoch),E=await C.getHeader(o.blockHash),I=parseEpochCompatible(E.epoch),O=I.index.mul(x.length),v=x.index.mul(I.length);let T=I.number.sub(x.number);O.gt(v)&&(T=T.add(1));const P=T.add(y).sub(1).div(y).mul(y),B=epochSinceCompatible({number:p.BI.from(x.number.add(P)),index:p.BI.from(x.index),length:p.BI.from(x.length)}),A="0x"+calculateMaximumWithdrawCompatible(o,w.dao,E.dao).toString(16),H=(0,r.parseAddress)(l,{config:h});t=t.update("outputs",(t=>t.push({cellOutput:{capacity:A,lock:H,type:void 0},data:"0x",outPoint:void 0,blockHash:void 0})));const D="0x"+B.toString(16);for(;t.get("witnesses").size<t.get("inputs").size-1;)t=t.update("witnesses",(t=>t.push("0x")));const R=(t=t.update("headerDeps",(t=>t.push(e.blockHash,o.blockHash)))).get("headerDeps").size-2,L={inputType:n.bytes.hexify(n.number.Uint64LE.pack(R))},M=n.bytes.hexify(i.blockchain.WitnessArgs.pack(L)),F=o.cellOutput.lock;(0,u.isSecp256k1Blake160Script)(F,h)?t=await s.default.setupInputCell(t,o,void 0,{config:h,since:D,defaultWitness:M}):(0,u.isSecp256k1Blake160MultisigScript)(F,h)&&(t=await c.default.setupInputCell(t,o,f||(0,r.generateAddress)(F,{config:h}),{config:h,since:D,defaultWitness:M}));const N=t.get("outputs").size-1;return t=(t=t.update("outputs",(t=>t.remove(N)))).update("fixedEntries",(e=>e.push({field:"inputs",index:t.get("inputs").size-1},{field:"outputs",index:t.get("outputs").size-1},{field:"witnesses",index:t.get("witnesses").size-1},{field:"headerDeps",index:t.get("headerDeps").size-2})))}function calculateDaoEarliestSince(t,e){const o=calculateDaoEarliestSinceCompatible(t,e);return BigInt(o.toString())}function calculateDaoEarliestSinceCompatible(t,e){const o=parseEpochCompatible(t),r=parseEpochCompatible(e),i=r.index.mul(o.length),n=o.index.mul(r.length);let a=r.number.sub(o.number);i.gt(n)&&(a=a.add(1));const s=a.add(y).sub(1).div(y).mul(y);return epochSinceCompatible({number:p.BI.from(o.number.add(s)),index:p.BI.from(o.index),length:p.BI.from(o.length)})}function _checkDaoScript(t){if(!t.SCRIPTS.DAO)throw new Error("Provided config does not have DAO script setup!")}function _addDaoCellDep(t,e){const o=e.SCRIPTS.DAO;return(0,u.addCellDep)(t,{outPoint:{txHash:o.TX_HASH,index:o.INDEX},depType:o.DEP_TYPE})}function extractDaoDataCompatible(t){if(!/^(0x)?([0-9a-fA-F]){64}$/.test(t))throw new Error("Invalid dao format!");const e=t.startsWith("0x")?t.slice(2):t;return["c","ar","s","u"].map(((t,o)=>({[t]:n.number.Uint64LE.unpack("0x"+e.slice(16*o,16*(o+1)))}))).reduce(((t,e)=>({...t,...e})),{})}function calculateMaximumWithdraw(t,e,o){return calculateMaximumWithdrawCompatible(t,e,o).toBigInt()}function calculateMaximumWithdrawCompatible(t,e,o){const i=p.BI.from(extractDaoDataCompatible(e).ar),n=p.BI.from(extractDaoDataCompatible(o).ar),a=p.BI.from((0,r.minimalCellCapacityCompatible)(t));return p.BI.from(t.cellOutput.capacity).sub(a).mul(n).div(i).add(a)}e.CellCollector=CellCollector;e.default={deposit,withdraw:async function withdraw(t,e,o,{config:i,enableNonSystemScript:l=!1}={}){if(_checkDaoScript(i=i||(0,a.getConfig)()),(t=_addDaoCellDep(t,i)).get("inputs").size!==t.get("outputs").size)throw new Error("Input size must equals to output size in txSkeleton!");if(!i.SCRIPTS.DAO)throw new Error("Provided config does not have DAO script setup!");if(!t.get("cellProvider"))throw new Error("Cell provider is missing!");const p=e.cellOutput.type,d=i.SCRIPTS.DAO;if(!p||p.codeHash!==d.CODE_HASH||p.hashType!==d.HASH_TYPE||e.data!==g)throw new Error("fromInput is not a DAO deposit cell.");const h=e.cellOutput.lock;(0,u.isSecp256k1Blake160Script)(h,i)?t=await s.default.setupInputCell(t,e,void 0,{config:i}):(0,u.isSecp256k1Blake160MultisigScript)(h,i)?t=await c.default.setupInputCell(t,e,o||(0,r.generateAddress)(h,{config:i}),{config:i}):l&&(t=await f.default.setupInputCell(t,e,o||(0,r.encodeToAddress)(h,{config:i}),{config:i}));const y=t.get("outputs").size-1,m=t.get("outputs").get(y),b=JSON.parse(JSON.stringify(m));if(!e.blockNumber)throw new Error("fromInput has no blockNumber!");return b.data=n.bytes.hexify(n.number.Uint64.pack(e.blockNumber)),t=(t=(t=t.update("outputs",(t=>t.update(y,(()=>b))))).update("headerDeps",(t=>t.push(e.blockHash)))).update("fixedEntries",(e=>e.push({field:"inputs",index:t.get("inputs").size-1},{field:"outputs",index:t.get("outputs").size-1})))},unlock,calculateMaximumWithdraw,calculateMaximumWithdrawCompatible,calculateDaoEarliestSince,calculateDaoEarliestSinceCompatible,CellCollector,listDaoCells}},789877:(t,e,o)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.compareScriptBinaryWithOnChainData=compareScriptBinaryWithOnChainData,e.default=void 0,e.generateDeployWithDataTx=generateDeployWithDataTx,e.generateDeployWithTypeIdTx=generateDeployWithTypeIdTx,e.generateUpgradeTypeIdDataTx=generateUpgradeTypeIdDataTx;var r=o(140993),i=o(852966),n=o(519808),a=o(893597),s=o(706081),c=o(446037),l=o(739609);const{ScriptValue:u}=r.values;function bytesToHex(t){let e="0x";for(let o=0;o<t.length;o++)e+=t[o].toString(16).padStart(2,"0");return e}function updateOutputs(t,e){const o=(0,a.minimalCellCapacityCompatible)(e);return e.cellOutput.capacity=`0x${o.toString(16)}`,t=t.update("outputs",(t=>t.push(e)))}function updateCellDeps(t,e){t=t.update("cellDeps",(t=>t.clear()));const o=(e=e||(0,n.getConfig)()).SCRIPTS.SECP256K1_BLAKE160,r=e.SCRIPTS.SECP256K1_BLAKE160_MULTISIG;if(!o||!r)throw new Error("Provided config does not have SECP256K1_BLAKE160 or SECP256K1_BLAKE160_MULTISIG script setup!");return t=t.update("cellDeps",(t=>t.push({outPoint:{txHash:o.TX_HASH,index:o.INDEX},depType:o.DEP_TYPE},{outPoint:{txHash:r.TX_HASH,index:r.INDEX},depType:r.DEP_TYPE})))}async function completeTx(t,e,o,p){const d=t.get("inputs").map((t=>l.BI.from(t.cellOutput.capacity))).reduce(((t,e)=>t.add(e)),l.BI.from(0)),f=t.get("outputs").map((t=>l.BI.from(t.cellOutput.capacity))).reduce(((t,e)=>t.add(e)),l.BI.from(0)).sub(d);return t=await async function injectCapacity(t,e,o,{config:p,feeRate:d}){p=p||(0,n.getConfig)();const f=d||1e3;let h=l.BI.from(o);const{fromScript:g,multisigScript:y}=(0,c.parseFromInfo)(e,{config:p});h=h.add(l.BI.from(10).pow(8));let m=l.BI.from(10).pow(8);const b={cellOutput:{capacity:"0x0",lock:g,type:void 0},data:"0x"},C=l.BI.from((0,a.minimalCellCapacityCompatible)(b)).add(l.BI.from(10).pow(8));h.lt(0)&&(m=m.sub(h),h=l.BI.from(0));if(h.gt(0)||m.lt(C)){const e=t.get("cellProvider");if(!e)throw new Error("Cell provider is missing!");const o=e.collector({lock:g,type:"empty",data:"0x"});let r=(0,s.Set)();for(const e of t.get("inputs"))r=r.add(`${e.outPoint.txHash}_${e.outPoint.index}`);for await(const e of o.collect()){if(r.has(`${e.outPoint.txHash}_${e.outPoint.index}`))continue;t=(t=t.update("inputs",(t=>t.push(e)))).update("witnesses",(t=>t.push("0x")));const o=l.BI.from(e.cellOutput.capacity);let i=o;if(i.gt(h)&&(i=h),h=h.sub(i),m=m.add(o).sub(i),h.eq(0)&&(m.eq(0)||m.gte(C)))break}}m.gt(0)&&(b.cellOutput.capacity="0x"+m.toString(16),t=t.update("outputs",(t=>t.push(b))));if(h.gt(0)||m.lt(C))throw new Error("Not enough capacity in from address!");const S=t.get("inputs").findIndex((t=>new u(t.cellOutput.lock,{validate:!1}).equals(new u(g,{validate:!1}))));if(-1!==S){for(;S>=t.get("witnesses").size;)t=t.update("witnesses",(t=>t.push("0x")));let o,n=t.get("witnesses").get(S);const a="0x0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";if(o="string"!=typeof e?{lock:"0x"+y.slice(2)+a.slice(2).repeat(e.M)}:{lock:a},"0x"!==n){const t=r.blockchain.WitnessArgs.unpack(i.bytes.bytify(n)),e=t.lock;if(e&&o.lock&&!i.bytes.equal(e,o.lock))throw new Error("Lock field in first witness is set aside for signature!");const a=t.inputType;a&&(o.inputType=a);const s=t.outputType;s&&(o.outputType=s)}n=i.bytes.hexify(r.blockchain.WitnessArgs.pack(o)),t=t.update("witnesses",(t=>t.set(S,n)))}const _=calculateTxFee(t,f);m=m.sub(_),t=t.update("outputs",(t=>t.pop())),m.gt(0)&&(b.cellOutput.capacity="0x"+m.toString(16),t=t.update("outputs",(t=>t.push(b))));return t}(t,e,l.BI.from(f),{config:o,feeRate:p}),t}function getTransactionSize(t){return function getTransactionSizeByTx(t){const e=r.blockchain.Transaction.pack(t);return e.byteLength+4}((0,a.createTransactionFromSkeleton)(t))}function calculateTxFee(t,e){const o=getTransactionSize(t);return l.BI.from(function calculateFee(t,e){const o=l.BI.from(1e3),r=l.BI.from(t).mul(e),i=r.div(o);return i.mul(o).lt(r)?i.add(1):l.BI.from(i)}(o,e))}function calculateTxHash(t){const e=(0,a.createTransactionFromSkeleton)(t);return r.utils.ckbHash(r.blockchain.RawTransaction.pack(e))}function getScriptConfig(t,e){const o=t.outputs.get(e);if(null==o)throw new Error("Invalid txSkeleton or outputIndex");return void 0!==o.cellOutput.type?function getScriptConfigByTypeHash(t,e){const o=t.outputs.get(e).cellOutput.type;return{CODE_HASH:r.utils.computeScriptHash(o),HASH_TYPE:"type",TX_HASH:calculateTxHash(t),INDEX:"0x0",DEP_TYPE:"code"}}(t,e):function getScriptConfigByDataHash(t,e){const o=t.outputs.get(e).data;return{CODE_HASH:r.utils.ckbHash(i.bytes.bytify(o)),HASH_TYPE:"data2",TX_HASH:calculateTxHash(t),INDEX:"0x0",DEP_TYPE:"code"}}(t,e)}function verifyFromInfo(t,{config:e}={}){if(e=e||(0,n.getConfig)(),"string"==typeof t){if("SECP256K1_BLAKE160"!==n.helpers.nameOfScript((0,a.parseAddress)(t,{config:e}),e.SCRIPTS))throw new Error("only SECP256K1_BLAKE160 or SECP256K1_MULTISIG is supported")}else if(!function isMultisigFromInfo(t){return"object"==typeof t&&"M"in t&&"R"in t&&Array.isArray(t.publicKeyHashes)}(t))throw new Error("only SECP256K1_BLAKE160 or SECP256K1_MULTISIG is supported")}async function generateDeployWithDataTx(t){verifyFromInfo(t.fromInfo,{config:t.config});let e=(0,a.TransactionSkeleton)({cellProvider:t.cellProvider});const{fromScript:o}=(0,c.parseFromInfo)(t.fromInfo,{config:t.config});e=updateOutputs(e,{cellOutput:{capacity:"0x0",lock:o},data:bytesToHex(t.scriptBinary)}),e=updateCellDeps(e,t.config),e=await completeTx(e,t.fromInfo,t.config,t.feeRate);return{txSkeleton:e,scriptConfig:getScriptConfig(e,0)}}async function generateDeployWithTypeIdTx(t){verifyFromInfo(t.fromInfo,{config:t.config});let e=(0,a.TransactionSkeleton)({cellProvider:t.cellProvider});const{fromScript:o}=(0,c.parseFromInfo)(t.fromInfo,{config:t.config}),[i]=await async function findCellsByLock(t,e){const o=e.collector({lock:t,type:"empty",data:"0x"}),r=[];for await(const t of o.collect())r.push(t);return r}(o,t.cellProvider);if(!i)throw new Error("fromAddress has no live ckb");const n=r.utils.generateTypeIdScript({previousOutput:i.outPoint,since:"0x0"},"0x0");e=updateOutputs(e,{cellOutput:{capacity:"0x0",lock:o,type:n},data:bytesToHex(t.scriptBinary)}),e=updateCellDeps(e,t.config),e=await completeTx(e,t.fromInfo,t.config,t.feeRate);return{txSkeleton:e,scriptConfig:getScriptConfig(e,0),typeId:n}}async function generateUpgradeTypeIdDataTx(t){verifyFromInfo(t.fromInfo,{config:t.config});let e=(0,a.TransactionSkeleton)({cellProvider:t.cellProvider});const{fromScript:o}=(0,c.parseFromInfo)(t.fromInfo,{config:t.config}),r=t.cellProvider.collector({type:t.typeId}),i=[];for await(const t of r.collect())i.push(t);if(1!==i.length)throw new Error("the typeid maybe wrong");const n=i[0];e=e.update("inputs",(t=>t.push(n)));e=updateOutputs(e,{cellOutput:{capacity:"0x0",lock:o,type:t.typeId},data:bytesToHex(t.scriptBinary)}),e=updateCellDeps(e,t.config),e=await completeTx(e,t.fromInfo,t.config,t.feeRate);return{txSkeleton:e,scriptConfig:getScriptConfig(e,0)}}async function compareScriptBinaryWithOnChainData(t,e,o){const n=function calculateCodeHashByBin(t){const e=t.valueOf();return(new r.utils.CKBHasher).update(e.buffer.slice(e.byteOffset,e.byteLength+e.byteOffset)).digestHex()}(t),a=await async function getDataHash(t,e){const o=t.txHash,n=parseInt(t.index,10),a=await e.getTransaction(o);if(!a)throw new Error(`TxHash(${o}) is not found`);const s=a.transaction.outputsData[n];if(!s)throw new Error("cannot find output data");return(new r.utils.CKBHasher).update(i.bytes.bytify(s)).digestHex()}(e,o);return n===a}e.default={generateDeployWithDataTx,generateDeployWithTypeIdTx,generateUpgradeTypeIdDataTx,compareScriptBinaryWithOnChainData,__tests__:{calculateTxFee}}},446037:(t,e,o)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.isMultisigFromInfo=function isMultisigFromInfo(t){if(!t||"object"!=typeof t)return!1;const e=t;return"number"==typeof(null==e?void 0:e.R)&&"number"==typeof(null==e?void 0:e.M)&&Array.isArray(null==e?void 0:e.publicKeyHashes)},e.multisigArgs=multisigArgs,e.parseFromInfo=function parseFromInfo(t,{config:e}={}){let o,r,a,s;if(e=e||(0,n.getConfig)(),"string"==typeof t)o=(0,i.parseAddress)(t,{config:e});else if("R"in t){const i=e.SCRIPTS.SECP256K1_BLAKE160_MULTISIG;if(!i)throw new Error("Provided config does not have SECP256K1_BLAKE16_MULTISIG script setup!");r=serializeMultisigScript(t);const n=multisigArgs(r,t.since);o={codeHash:i.CODE_HASH,hashType:i.HASH_TYPE,args:n}}else if("address"in t){const r=e.SCRIPTS.ANYONE_CAN_PAY;if(!r)throw new Error("Provided config does not have ANYONE_CAN_PAY script setup!");const n=t.address;if(o=(0,i.parseAddress)(n,{config:e}),a=t.destroyable,o.codeHash!==r.CODE_HASH||o.hashType!==r.HASH_TYPE)throw new Error("fromInfo.address is not ANYONE_CAN_PAY address!")}else{if(!("script"in t))throw new Error("Invalid fromInfo format!");o=t.script,s=t.customData}return{fromScript:o,multisigScript:r,destroyable:a,customData:s}},e.serializeMultisigScript=serializeMultisigScript;var r=o(140993),i=o(893597),n=o(519808),a=o(852966);const{CKBHasher:s}=r.utils;function serializeMultisigScript({R:t,M:e,publicKeyHashes:o}){if(t<0||t>255)throw new Error("`R` should be less than 256!");if(e<0||e>255)throw new Error("`M` should be less than 256!");return"0x00"+("00"+t.toString(16)).slice(-2)+("00"+e.toString(16)).slice(-2)+("00"+o.length.toString(16)).slice(-2)+o.map((t=>t.slice(2))).join("")}function multisigArgs(t,e){let o="0x";return null!=e&&(o=a.bytes.hexify(a.number.Uint64LE.pack(e))),(new s).update(t).digestHex().slice(0,42)+o.slice(2)}},555258:(t,e,o)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.SECP_SIGNATURE_PLACEHOLDER=void 0,e.addCellDep=addCellDep,e.default=void 0,e.ensureScript=ensureScript,e.generateDaoScript=generateDaoScript,e.hashWitness=hashWitness,e.isAcpAddress=isAcpAddress,e.isAcpScript=isAcpScript,e.isDaoScript=isDaoScript,e.isOmnilockAddress=function isOmnilockAddress(t,e){return isOmnilockScript((0,i.parseAddress)(t,{config:e}),e)},e.isOmnilockScript=isOmnilockScript,e.isSecp256k1Blake160Address=isSecp256k1Blake160Address,e.isSecp256k1Blake160MultisigAddress=isSecp256k1Blake160MultisigAddress,e.isSecp256k1Blake160MultisigScript=isSecp256k1Blake160MultisigScript,e.isSecp256k1Blake160Script=isSecp256k1Blake160Script,e.isSudtScript=isSudtScript,e.prepareSigningEntries=prepareSigningEntries;var r=o(706081),i=o(893597),n=o(852966),a=o(140993),s=o(608338);const{CKBHasher:c,ckbHash:l}=a.utils;function addCellDep(t,e){return t.get("cellDeps").find((t=>t.depType===e.depType&&new a.values.OutPointValue(t.outPoint,{validate:!1}).equals(new a.values.OutPointValue(e.outPoint,{validate:!1}))))||(t=t.update("cellDeps",(t=>t.push({outPoint:e.outPoint,depType:e.depType})))),t}function generateDaoScript(t){const e=t.SCRIPTS.DAO;return{codeHash:e.CODE_HASH,hashType:e.HASH_TYPE,args:"0x"}}function isSecp256k1Blake160Script(t,e){const o=e.SCRIPTS.SECP256K1_BLAKE160;return t.codeHash===o.CODE_HASH&&t.hashType===o.HASH_TYPE}function isSecp256k1Blake160Address(t,e){return isSecp256k1Blake160Script((0,i.parseAddress)(t,{config:e}),e)}function isOmnilockScript(t,e){const o=e.SCRIPTS.OMNILOCK;return t.codeHash===o.CODE_HASH&&t.hashType===o.HASH_TYPE}function isSecp256k1Blake160MultisigScript(t,e){const o=e.SCRIPTS.SECP256K1_BLAKE160_MULTISIG;return t.codeHash===o.CODE_HASH&&t.hashType===o.HASH_TYPE}function isSecp256k1Blake160MultisigAddress(t,e){return isSecp256k1Blake160MultisigScript((0,i.parseAddress)(t,{config:e}),e)}function isDaoScript(t,e){const o=e.SCRIPTS.DAO;return!!t&&t.codeHash===o.CODE_HASH&&t.hashType===o.HASH_TYPE}function isSudtScript(t,e){const o=e.SCRIPTS.SUDT;if(!o)throw new Error("SUDT script not defined in config!");return!!t&&t.codeHash===o.CODE_HASH&&t.hashType===o.HASH_TYPE}function isAcpScript(t,e){const o=e.SCRIPTS.ANYONE_CAN_PAY;if(!o)throw new Error("ANYONE_CAN_PAY script not defined in config!");return!!t&&t.codeHash===o.CODE_HASH&&t.hashType===o.HASH_TYPE}function isAcpAddress(t,e){return isAcpScript((0,i.parseAddress)(t,{config:e}),e)}function hashWitness(t,e){const o=n.bytes.hexify(s.Uint64.pack(n.bytes.bytify(e).length));t.update(o),t.update(e)}function prepareSigningEntries(t,e,o){const n=e.SCRIPTS[o];if(!n)throw new Error(`Provided config does not have ${o} script setup!`);let s=(0,r.Set)();const u=(0,i.createTransactionFromSkeleton)(t),p=l(a.blockchain.RawTransaction.pack(u)),d=t.get("inputs"),f=t.get("witnesses");let h=t.get("signingEntries");for(let t=0;t<d.size;t++){const e=d.get(t);if(n.CODE_HASH===e.cellOutput.lock.codeHash&&n.HASH_TYPE===e.cellOutput.lock.hashType&&!s.has(e.cellOutput.lock.args)){s=s.add(e.cellOutput.lock.args);const o=new a.values.ScriptValue(e.cellOutput.lock,{validate:!1}),r=new c;if(r.update(p),t>=f.size)throw new Error(`The first witness in the script group starting at input index ${t} does not exist, maybe some other part has invalidly tampered the transaction?`);hashWitness(r,f.get(t));for(let e=t+1;e<d.size&&e<f.size;e++){const t=d.get(e);o.equals(new a.values.ScriptValue(t.cellOutput.lock,{validate:!1}))&&hashWitness(r,f.get(e))}for(let t=d.size;t<f.size;t++)hashWitness(r,f.get(t));const i={type:"witness_args_lock",index:t,message:r.digestHex()};h=h.push(i)}}return t=t.set("signingEntries",h)}function ensureScript(t,e,o){const r=e.SCRIPTS[o];if(!r)throw new Error(`Provided config does not have ${o} script setup!`);if(r.CODE_HASH!==t.codeHash||r.HASH_TYPE!==t.hashType)throw new Error(`Provided script is not ${o} script!`)}e.SECP_SIGNATURE_PLACEHOLDER="0x0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";e.default={addCellDep,generateDaoScript,isSecp256k1Blake160Script,isSecp256k1Blake160MultisigScript,isDaoScript,isSudtScript,prepareSigningEntries,isSecp256k1Blake160Address,isSecp256k1Blake160MultisigAddress,ensureScript,isAcpScript,isAcpAddress}},297516:(t,e,o)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),Object.defineProperty(e,"anyoneCanPay",{enumerable:!0,get:function(){return u.default}}),Object.defineProperty(e,"common",{enumerable:!0,get:function(){return c.default}}),Object.defineProperty(e,"createP2PKHMessageGroup",{enumerable:!0,get:function(){return p.createP2PKHMessageGroup}}),Object.defineProperty(e,"dao",{enumerable:!0,get:function(){return a.default}}),e.default=void 0,Object.defineProperty(e,"deploy",{enumerable:!0,get:function(){return d.default}}),Object.defineProperty(e,"locktimePool",{enumerable:!0,get:function(){return s.default}}),Object.defineProperty(e,"omnilock",{enumerable:!0,get:function(){return f.default}}),Object.defineProperty(e,"parseFromInfo",{enumerable:!0,get:function(){return n.parseFromInfo}}),Object.defineProperty(e,"secp256k1Blake160",{enumerable:!0,get:function(){return r.default}}),Object.defineProperty(e,"secp256k1Blake160Multisig",{enumerable:!0,get:function(){return i.default}}),Object.defineProperty(e,"sudt",{enumerable:!0,get:function(){return l.default}});var r=_interopRequireDefault(o(574393)),i=_interopRequireDefault(o(342202)),n=o(446037),a=_interopRequireDefault(o(855292)),s=_interopRequireDefault(o(474233)),c=_interopRequireDefault(o(974247)),l=_interopRequireDefault(o(77922)),u=_interopRequireDefault(o(911584)),p=o(878765),d=_interopRequireDefault(o(789877)),f=_interopRequireDefault(o(478988));function _interopRequireDefault(t){return t&&t.__esModule?t:{default:t}}e.default={secp256k1Blake160:r.default,secp256k1Blake160Multisig:i.default,dao:a.default,locktimePool:s.default,common:c.default,sudt:l.default,anyoneCanPay:u.default}},474233:(t,e,o)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.default=e.CellCollector=void 0,e.injectCapacity=injectCapacity,e.payFee=payFee,e.prepareSigningEntries=prepareSigningEntries,e.setupInputCell=setupInputCell,e.transfer=transfer,e.transferCompatible=transferCompatible;var r=o(893597),i=o(852966),n=o(446037),a=function _interopRequireDefault(t){return t&&t.__esModule?t:{default:t}}(o(574393)),s=o(855292),c=o(140993),l=o(555258),u=o(706081),p=o(519808),d=o(297516),f=o(591363),h=o(739609),g=o(436115);const{ScriptValue:y}=c.values,{parseEpoch:m,maximumAbsoluteEpochSince:b,generateAbsoluteEpochSince:C,validateSince:S}=c.since,_=e.CellCollector=class CellCollector{constructor(t,e,{config:o,queryOptions:r={},tipHeader:i,NodeRPC:a=g.RPC}={}){if(!e)throw new Error("Cell provider is missing!");o=o||(0,p.getConfig)();const s=(0,n.parseFromInfo)(t,{config:o}),c=s.fromScript;this.multisigScript=s.multisigScript,this.fromScript=c,this.config=o,this.tipHeader=i,i&&(this.tipSinceValidationInfo={blockNumber:i.number,epoch:i.epoch,median_timestamp:""}),this.rpc=new a(e.uri),r={...r,lock:this.fromScript};let d=(0,u.List)([]);if((0,l.isSecp256k1Blake160MultisigScript)(c,o)){const t={codeHash:c.codeHash,hashType:c.hashType,args:c.args.slice(0,42)};d=d.push(e.collector({lock:t,argsLen:r.argsLen||28,type:r.type||"empty",data:r.data||"0x"})),r.type||r.data&&"any"!==r.data||(d=d.push(e.collector({lock:t,type:(0,l.generateDaoScript)(o),data:"any"})),d=d.push(e.collector({lock:t,argsLen:28,type:(0,l.generateDaoScript)(o),data:"any"})))}else(0,l.isSecp256k1Blake160Script)(c,o)&&(r.type||r.data&&"any"!==r.data||(d=d.push(e.collector({lock:c,type:(0,l.generateDaoScript)(o),data:"any"}))));this.cellCollectors=d}async*collect(){for(const t of this.cellCollectors)for await(const e of t.collect()){const t=e.cellOutput.lock;let o,r,i,n,a;if(58===t.args.length){const r=await this.rpc.getHeader(e.blockHash);o="0x"+_parseMultisigArgsSinceCompatible(t.args).toString(16),a={epoch:r.epoch,blockNumber:r.number,median_timestamp:""}}if((0,l.isDaoScript)(e.cellOutput.type,this.config)){if("0x0000000000000000"===e.data)continue;const t=await this.rpc.getTransaction(e.outPoint.txHash);n=t.txStatus.blockHash;const a=t.transaction.inputs[+e.outPoint.index].previousOutput;i=(await this.rpc.getTransaction(a.txHash)).txStatus.blockHash;const c=await this.rpc.getHeader(i),l=await this.rpc.getHeader(n);let u="0x"+(0,s.calculateDaoEarliestSinceCompatible)(c.epoch,l.epoch).toString(16);r=(0,s.calculateMaximumWithdrawCompatible)(e,c.dao,l.dao);const p=m(l.epoch),d={number:p.number+4,length:p.length,index:p.index};if(u=b(u,C(d)),o){const t=(0,f.parseSinceCompatible)(o);if(!1!==t.relative||"epochNumber"!==t.type)continue;try{o=b(u,o)}catch{o=u}}else o=u}if("blockTimestamp"===(0,f.parseSinceCompatible)(o).type||this.tipHeader&&!S(o,this.tipSinceValidationInfo,a))continue;const c={...e,since:o,depositBlockHash:i,withdrawBlockHash:n,sinceValidationInfo:a};c.cellOutput.capacity="0x"+(r||h.BI.from(e.cellOutput.capacity)).toString(16),yield c}}};async function transfer(t,e,o,r,i,{config:n,requireToAddress:a=!0,assertAmountEnough:s=!0,LocktimeCellCollector:c=_}={}){const l=await transferCompatible(t,e,o,r,i,{config:n,requireToAddress:a,assertAmountEnough:s,LocktimeCellCollector:c});let u,p;return l instanceof Array?(u=l[0],p=BigInt(l[1].toString()),[u,p]):(u=l,u)}async function transferCompatible(t,e,o,r,i,{config:n,requireToAddress:a=!0,assertAmountEnough:s=!0,LocktimeCellCollector:c=_}={}){let l=h.BI.from(r);for(const[r,u]of e.entries()){const e=await _transferCompatible(t,u,0===r?o:void 0,l,i,{config:n,requireToAddress:0===r&&a,assertAmountEnough:!1,LocktimeCellCollector:c});if(t=e[0],l=e[1],l.eq(0))return s?t:[t,h.BI.from(l)]}if(s)throw new Error("Not enough capacity in from addresses!");return[t,h.BI.from(l)]}async function _transferCompatible(t,e,o,a,s,{config:d,requireToAddress:f=!0,assertAmountEnough:g=!0,LocktimeCellCollector:m=_,changeAddress:b}){d=d||(0,p.getConfig)();const{fromScript:C}=(0,n.parseFromInfo)(e,{config:d});if(!(0,l.isSecp256k1Blake160MultisigScript)(C,d)&&!(0,l.isSecp256k1Blake160Script)(C,d))throw new Error("fromInfo not supported!");if(f&&!o)throw new Error("You must provide a to address!");let S=h.BI.from(a||0);if(o){const e=(0,r.parseAddress)(o,{config:d});t=t.update("outputs",(t=>t.push({cellOutput:{capacity:"0x"+S.toString(16),lock:e,type:void 0},data:"0x",outPoint:void 0,blockHash:void 0})))}const k=t.get("fixedEntries").filter((({field:t})=>"outputs"===t)).maxBy((({index:t})=>t));let w=k?k.index+1:0;for(;w<t.get("outputs").size&&S.gt(0);++w){const e=t.get("outputs").get(w);if(new y(e.cellOutput.lock,{validate:!1}).equals(new y(C,{validate:!1}))){const o=h.BI.from(e.cellOutput.capacity);let i;S.gte(o)?i=o:(i=o.sub((0,r.minimalCellCapacityCompatible)(e)),i.gt(S)&&(i=S)),S=S.sub(i);const n=JSON.parse(JSON.stringify(e));n.cellOutput.capacity="0x"+o.sub(i).toString(16),t=t.update("outputs",(t=>t.update(w,(()=>n))))}}if(t=t.update("outputs",(t=>t.filter((t=>!h.BI.from(t.cellOutput.capacity).eq(0))))),S.gt(0)){const o=t.get("cellProvider");if(!o)throw new Error("cell provider is missing!");const n={cellOutput:{capacity:"0x0",lock:b?(0,r.parseAddress)(b,{config:d}):C,type:void 0},data:"0x",outPoint:void 0,blockHash:void 0};let a=h.BI.from(0),p=(0,u.Set)();for(const e of t.get("inputs"))p=p.add(`${e.outPoint.txHash}_${e.outPoint.index}`);const f=new m(e,o,{config:d,tipHeader:s});for await(const o of f.collect()){const s=o;if(p.has(`${s.outPoint.txHash}_${s.outPoint.index}`))continue;let u;if((0,l.isSecp256k1Blake160MultisigScript)(C,d)){const t=s.cellOutput.lock.args;u=58===t.length?h.BI.from(_parseMultisigArgsSinceCompatible(t)):void 0}let f="0x";if((0,l.isDaoScript)(s.cellOutput.type,d)){const e=d.SCRIPTS.DAO,o=(t=(t=(0,l.addCellDep)(t,{depType:e.DEP_TYPE,outPoint:{txHash:e.TX_HASH,index:e.INDEX}})).update("headerDeps",(t=>t.push(s.depositBlockHash,s.withdrawBlockHash)))).get("headerDeps").size-2,r={inputType:i.bytes.hexify(i.number.Uint64.pack(o))};f=i.bytes.hexify(c.blockchain.WitnessArgs.pack(r))}t=await collectInput(t,s,(0,l.isSecp256k1Blake160MultisigScript)(C,d)?Object.assign({},e,{since:u}):e,{config:d,defaultWitness:f,since:s.since});const g=h.BI.from(s.cellOutput.capacity);let y=g;if(y.gt(S)&&(y=S),S=S.sub(y),a=a.add(g).sub(y),(0,l.isDaoScript)(s.cellOutput.type,d)&&(t=t.update("fixedEntries",(e=>e.push({field:"inputs",index:t.get("inputs").size-1},{field:"witnesses",index:t.get("witnesses").size-1},{field:"headerDeps",index:t.get("headerDeps").size-2})))),S.eq(0)&&(a.eq(0)||a.gt((0,r.minimalCellCapacityCompatible)(n))))break}a.gt(0)&&(n.cellOutput.capacity="0x"+a.toString(16),t=t.update("outputs",(t=>t.push(n))))}if(!g)return[t,S];if(S.gt(0))throw new Error("Not enough capacity in from address!");return t}async function injectCapacityWithoutChangeCompatible(t,e,o,a,s,{config:d,LocktimeCellCollector:f=_,enableDeductCapacity:g=!0}){d=d||(0,p.getConfig)();let m=h.BI.from(o);const b=h.BI.from(s);if(g)for(const o of e){const e=(0,n.parseFromInfo)(o,{config:d}).fromScript;if(!(0,l.isSecp256k1Blake160MultisigScript)(e,d)&&!(0,l.isSecp256k1Blake160Script)(e,d))continue;const i=t.get("fixedEntries").filter((({field:t})=>"outputs"===t)).maxBy((({index:t})=>t));let a=i?i.index+1:0;for(;a<t.get("outputs").size&&m.gt(0);++a){const o=t.get("outputs").get(a);if(new y(o.cellOutput.lock,{validate:!1}).equals(new y(e,{validate:!1}))){const e=JSON.parse(JSON.stringify(o)),i=h.BI.from(e.cellOutput.capacity);let n;m.gte(i)?n=i:(n=i.sub((0,r.minimalCellCapacityCompatible)(e)),n.gt(m)&&(n=m)),m=m.sub(n),e.cellOutput.capacity="0x"+i.sub(n).toString(16),t=t.update("outputs",(t=>t.update(a,(()=>e))))}}t=t.update("outputs",(t=>t.filter((t=>!h.BI.from(t.cellOutput.capacity).eq(0)))))}let C=h.BI.from(0);if(m.gt(0)){const o=t.get("cellProvider");if(!o)throw new Error("cell provider is missing!");const getInputKey=t=>`${t.outPoint.txHash}_${t.outPoint.index}`;let r=(0,u.Set)();for(const e of t.get("inputs"))r=r.add(getInputKey(e));for(const s of e){const e=(0,n.parseFromInfo)(s,{config:d}).fromScript,u=new f(s,o,{config:d,tipHeader:a});for await(const o of u.collect()){const n=o;if(r.has(getInputKey(n)))continue;let a,u="0x";if((0,l.isDaoScript)(n.cellOutput.type,d)){const e=d.SCRIPTS.DAO,o=(t=(t=(0,l.addCellDep)(t,{depType:e.DEP_TYPE,outPoint:{txHash:e.TX_HASH,index:e.INDEX}})).update("headerDeps",(t=>t.push(n.depositBlockHash,n.withdrawBlockHash)))).get("headerDeps").size-2,r={inputType:i.bytes.hexify(i.number.Uint64.pack(o))};u=i.bytes.hexify(c.blockchain.WitnessArgs.pack(r))}if((0,l.isSecp256k1Blake160MultisigScript)(e,d)){const t=n.cellOutput.lock.args;a=58===t.length?h.BI.from(_parseMultisigArgsSinceCompatible(t)):void 0}t=await collectInput(t,n,Object.assign({},s,{since:a}),{config:d,defaultWitness:u,since:n.since});const p=h.BI.from(n.cellOutput.capacity);let f=p;if(f.gt(m)&&(f=m),m=m.sub(f),C=C.add(p).sub(f),(0,l.isDaoScript)(n.cellOutput.type,d)&&(t=t.update("fixedEntries",(e=>e.push({field:"inputs",index:t.get("inputs").size-1},{field:"witnesses",index:t.get("witnesses").size-1},{field:"headerDeps",index:t.get("headerDeps").size-2})))),m.eq(0)&&(C.eq(0)||C.gt(b)))break}}}return{txSkeleton:t,capacity:h.BI.from(m.toString()),changeCapacity:h.BI.from(C.toString())}}async function payFee(t,e,o,r,{config:i,LocktimeCellCollector:n=_}={}){return transferCompatible(t,e,void 0,o,r,{config:i,requireToAddress:!1,LocktimeCellCollector:n})}function prepareSigningEntries(t,{config:e}={}){return e=e||(0,p.getConfig)(),t=(0,l.prepareSigningEntries)(t,e,"SECP256K1_BLAKE160"),t=(0,l.prepareSigningEntries)(t,e,"SECP256K1_BLAKE160_MULTISIG")}async function injectCapacity(t,e,o,r,{config:i,LocktimeCellCollector:n=_}={}){if(i=i||(0,p.getConfig)(),e>=t.get("outputs").size)throw new Error("Invalid output index!");const a=h.BI.from(t.get("outputs").get(e).cellOutput.capacity);return transferCompatible(t,o,void 0,h.BI.from(a),r,{config:i,requireToAddress:!1,LocktimeCellCollector:n})}async function collectInput(t,e,o,{config:r,since:i,defaultWitness:n="0x"}={}){return r=r||(0,p.getConfig)(),t=(t=await setupInputCell(t,e,o,{config:r,since:i,defaultWitness:n})).update("outputs",(t=>t.remove(t.size-1)))}async function setupInputCell(t,e,o,{config:r,since:i,defaultWitness:n="0x"}={}){r=r||(0,p.getConfig)();const s=e.cellOutput.lock;if((0,l.isSecp256k1Blake160Script)(s,r))return a.default.setupInputCell(t,e,o,{config:r,defaultWitness:n,since:i});if((0,l.isSecp256k1Blake160MultisigScript)(s,r))return d.secp256k1Blake160Multisig.setupInputCell(t,e,o,{config:r,defaultWitness:n,since:i});throw new Error("Not supported input lock!")}function _parseMultisigArgsSinceCompatible(t){if(58!==t.length)throw new Error("Invalid multisig with since args!");return i.number.Uint64LE.unpack("0x"+t.slice(42))}e.default={CellCollector:_,transfer,transferCompatible,payFee,prepareSigningEntries,injectCapacity,setupInputCell,injectCapacityWithoutChange:async function injectCapacityWithoutChange(t,e,o,r,i,{config:n,LocktimeCellCollector:a=_,enableDeductCapacity:s=!0}){const c=await injectCapacityWithoutChangeCompatible(t,e,o,r,i,{config:n,LocktimeCellCollector:a,enableDeductCapacity:s});return{txSkeleton:c.txSkeleton,capacity:c.capacity.toBigInt(),changeCapacity:c.changeCapacity.toBigInt()}},injectCapacityWithoutChangeCompatible}},318215:(t,e,o)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.decodeAddress=function decodeAddress(t){try{if(t.startsWith("bc1q"))return i.bech32.fromWords(i.bech32.decode(t).words.slice(1));if(t.startsWith("1"))return n.default.decode(t).slice(1,21);if(t.startsWith("3"))return n.default.decode(t).slice(1,21)}catch{if(t.startsWith("bc1p"))throw new Error("Taproot address is not supported yet.")}throw new Error(`Unsupported bitcoin address ${t}, only 1...(P2PKH) 3...(P2SH), and bc1...(Bech32) are supported.`)},e.signMessage=async function signMessage(t,e,o){const i=(()=>{if(o)return o;if("undefined"!=typeof window){if("unisat"in window)return window.unisat;if("okxwallet"in window&&"bitcoin"in window.okxwallet)return window.okxwallet.bitcoin}throw new Error("No provider found, make sure you have installed UniSat Wallet")})(),n=await i.requestAccounts(),s=r.bytes.hexify(t).slice(2),c=await i.signMessage(`${a}${s}`,e),l=r.bytes.bytify(function base64ToHex(t){const e=atob(t);let o="";for(let t=0;t<e.length;t++){const r=e.charCodeAt(t).toString(16);o+=2===r.length?r:"0"+r}return"0x"+o}(c)),u=n[0];if(u.startsWith("bc1q"))l[0]=39+(l[0]-27)%4;else if(u.startsWith("3"))l[0]=35+(l[0]-27)%4;else{if(!u.startsWith("1"))throw new Error(`Unsupported bitcoin address ${u}, only 1...(P2PKH) 3...(P2SH), and bc1...(Bech32) are supported.`);l[0]=31+(l[0]-27)%4}return r.bytes.hexify(l)};var r=o(852966),i=o(146586),n=function _interopRequireDefault(t){return t&&t.__esModule?t:{default:t}}(o(185218));const a="CKB (Bitcoin Layer) transaction: 0x"},649961:(t,e,o)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.signMessage=async function signMessage(t,e){const o=(()=>{if(e)return e;if("undefined"!=typeof window&&"phantom"in window&&window.phantom&&"solana"in window.phantom)return window.phantom.solana;throw new Error("No provider found, make sure you have installed Phantom or other Solana wallet")})(),n=r.bytes.hexify(t).slice(2),a=await o.signMessage((new TextEncoder).encode(`${i}${n}`));return r.bytes.hexify(r.bytes.concat(a.signature,a.publicKey.toBytes()))};var r=o(852966);const i="CKB transaction: 0x"},478988:(t,e,o)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.bitcoin=e.OmnilockWitnessLock=e.CellCollector=void 0,e.createOmnilockScript=createOmnilockScript,e.default=void 0,e.prepareSigningEntries=prepareSigningEntries,e.setupInputCell=setupInputCell,e.solana=void 0;var r=o(852966),i=o(140993),n=o(519808),a=o(555258),s=o(446037),c=o(640035),l=o(518042),u=o(542069),p=_interopRequireWildcard(o(318215));e.bitcoin=p;var d=_interopRequireWildcard(o(649961));e.solana=d;var f=o(185218),h=o(102572);function _getRequireWildcardCache(t){if("function"!=typeof WeakMap)return null;var e=new WeakMap,o=new WeakMap;return(_getRequireWildcardCache=function(t){return t?o:e})(t)}function _interopRequireWildcard(t,e){if(!e&&t&&t.__esModule)return t;if(null===t||"object"!=typeof t&&"function"!=typeof t)return{default:t};var o=_getRequireWildcardCache(e);if(o&&o.has(t))return o.get(t);var r={__proto__:null},i=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var n in t)if("default"!==n&&{}.hasOwnProperty.call(t,n)){var a=i?Object.getOwnPropertyDescriptor(t,n):null;a&&(a.get||a.set)?Object.defineProperty(r,n,a):r[n]=t[n]}return r.default=t,o&&o.set(t,r),r}const{ScriptValue:g}=i.values;var y=function(t){return t[t.IdentityFlagsCkb=0]="IdentityFlagsCkb",t[t.IdentityFlagsEthereum=1]="IdentityFlagsEthereum",t[t.IdentityFlagsEos=2]="IdentityFlagsEos",t[t.IdentityFlagsTron=3]="IdentityFlagsTron",t[t.IdentityFlagsBitcoin=4]="IdentityFlagsBitcoin",t[t.IdentityFlagsDogecoin=5]="IdentityFlagsDogecoin",t[t.IdentityCkbMultisig=6]="IdentityCkbMultisig",t[t.IdentityFlagsEthereumDisplaying=18]="IdentityFlagsEthereumDisplaying",t[t.IdentityFlagsSolana=19]="IdentityFlagsSolana",t[t.IdentityFlagsOwnerLock=252]="IdentityFlagsOwnerLock",t[t.IdentityFlagsExec=253]="IdentityFlagsExec",t[t.IdentityFlagsDl=254]="IdentityFlagsDl",t}(y||{});const m=20,b=65,C=96;function createOmnilockScript(t,e){const o=((null==e?void 0:e.config)||(0,n.getConfig)()).SCRIPTS.OMNILOCK;if(!o)throw new Error("OMNILOCK script config not found.");const i=[0],a=(()=>{const e=t.auth.flag;switch(e){case"ETHEREUM":return r.bytes.hexify(r.bytes.concat([y.IdentityFlagsEthereum],t.auth.content,i));case"SECP256K1_BLAKE160":return r.bytes.hexify(r.bytes.concat([y.IdentityFlagsCkb],t.auth.content,i));case"BITCOIN":return r.bytes.hexify(r.bytes.concat([y.IdentityFlagsBitcoin],p.decodeAddress(t.auth.content),i));case"SOLANA":{const e=r.bytes.bytify((0,h.ckbHash)((0,f.decode)(t.auth.content))).slice(0,m);return r.bytes.hexify(r.bytes.concat([y.IdentityFlagsSolana],e,i))}default:throw new Error(`Not supported flag: ${e}.`)}})();return{codeHash:o.CODE_HASH,hashType:o.HASH_TYPE,args:a}}const S={pack:u.bytify,unpack:u.hexify},_=(0,l.createFixedHexBytesCodec)(21),k=(0,c.byteVecOf)(S),w=(0,c.table)({mask:(0,c.byteOf)(S),proof:k},["mask","proof"]),x=(0,c.vector)(w),E=(0,c.table)({identity:_,proofs:x},["identity","proofs"]),I=(0,c.option)(E),O=e.OmnilockWitnessLock=(0,c.table)({signature:l.BytesOpt,omni_identity:I,preimage:l.BytesOpt},["signature","omni_identity","preimage"]),v=e.CellCollector=class CellCollector{constructor(t,e,{config:o,queryOptions:r={}}={}){if(!e)throw new Error("Cell provider is missing!");o=o||(0,n.getConfig)(),this.fromScript=(0,s.parseFromInfo)(t,{config:o}).fromScript,this.config=o,r={...r,lock:this.fromScript,type:r.type||"empty"},this.cellCollector=e.collector(r)}async*collect(){if((0,a.isOmnilockScript)(this.fromScript,this.config))for await(const t of this.cellCollector.collect())yield t}};async function setupInputCell(t,e,o,{config:s,defaultWitness:c="0x",since:l}={}){s=s||(0,n.getConfig)();const u=e.cellOutput.lock;if(!(0,a.isOmnilockScript)(u,s))throw new Error("Not OMNILOCK input!");t=t.update("inputs",(t=>t.push(e)));const p={cellOutput:{capacity:e.cellOutput.capacity,lock:e.cellOutput.lock,type:e.cellOutput.type},data:e.data};t=t.update("outputs",(t=>t.push(p))),l&&(t=t.update("inputSinces",(e=>e.set(t.get("inputs").size-1,l)))),t=t.update("witnesses",(t=>t.push(c)));const d=s.SCRIPTS.OMNILOCK,f=s.SCRIPTS.SECP256K1_BLAKE160;if(!d)throw new Error("OMNILOCK script not defined in config!");if(!f)throw new Error("SECP256K1_BLAKE160 script not defined in config!");const h={txHash:d.TX_HASH,index:d.INDEX},m={txHash:f.TX_HASH,index:f.INDEX};t=(0,a.addCellDep)(t,{outPoint:h,depType:d.DEP_TYPE});const S=(t=(0,a.addCellDep)(t,{outPoint:m,depType:f.DEP_TYPE})).get("inputs").findIndex((t=>new g(t.cellOutput.lock,{validate:!1}).equals(new g(u,{validate:!1}))));if(-1!==S){for(;S>=t.get("witnesses").size;)t=t.update("witnesses",(t=>t.push("0x")));let o=t.get("witnesses").get(S);const n={lock:createWitnessLockPlaceholder((()=>{const t=r.bytes.bytify(e.cellOutput.lock.args)[0];switch(t){case y.IdentityFlagsSolana:return C;case y.IdentityFlagsCkb:case y.IdentityFlagsEthereum:case y.IdentityFlagsBitcoin:return b;default:throw new Error(`Unsupported flag: ${t}, please check if the script.args is expected`)}})())};o=r.bytes.hexify(i.blockchain.WitnessArgs.pack(n)),t=t.update("witnesses",(t=>t.set(S,o)))}return t}function createWitnessLockPlaceholder(t){const e=O.pack({signature:new Uint8Array(t)}).byteLength;return r.bytes.hexify(new Uint8Array(e))}function prepareSigningEntries(t,{config:e}={}){return e=e||(0,n.getConfig)(),(0,a.prepareSigningEntries)(t,e,"OMNILOCK")}e.default={prepareSigningEntries,setupInputCell,CellCollector:v,OmnilockWitnessLock:O,createOmnilockScript}},878765:(t,e,o)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.createP2PKHMessageGroup=function createP2PKHMessageGroup(t,e,{hasher:o=defaultCkbHasher}={}){const s=function groupInputs(t,e){const o=new Set;for(const t of e){const e=r.utils.ckbHash(r.blockchain.Script.pack(t));o.add(e)}const i=new Map;for(let e=0;e<t.length;e++){const n=r.utils.ckbHash(r.blockchain.Script.pack(t[e].cellOutput.lock));o.has(n)&&(void 0===i.get(n)&&i.set(n,[]),i.get(n).push(e))}return i}(t.inputs.toArray(),e),c=function calcRawTxHash(t){const e=(0,i.createTransactionFromSkeleton)(t),o={cellDeps:e.cellDeps,headerDeps:e.headerDeps,inputs:e.inputs,outputs:e.outputs,outputsData:e.outputsData,version:e.version};return r.utils.ckbHash(r.blockchain.RawTransaction.pack(o))}(t);if(e.length>1&&!(o instanceof Function))throw new Error("Must provide hasher producer when you have multiple locks to group.");const l=[];for(const e of s.keys()){const r=resolveThunk(o),i=s.get(e),u=i[0],p=t.witnesses.get(u);if(void 0===p)throw new Error("Please fill witnesses with 0 first!");r.update(n.bytes.bytify(c));const d=new ArrayBuffer(8),f=new DataView(d),h=a.BI.from(n.bytes.bytify(p).length).toString(16);h.length<=8&&(f.setUint32(0,Number("0x"+h),!0),f.setUint32(4,Number("0x00000000"),!0)),h.length>8&&h.length<=16&&(f.setUint32(0,Number("0x"+h.slice(-8)),!0),f.setUint32(4,Number("0x"+h.slice(0,-8)),!0)),r.update(new Uint8Array(d)),r.update(n.bytes.bytify(p));for(let e=1;e<i.length;e++){const o=t.witnesses.get(i[e]);r.update(new Uint8Array(d)),r.update(n.bytes.bytify(o))}for(let e=t.inputs.toArray().length;e<t.witnesses.toArray().length;e++){const o=t.witnesses.get(e);r.update(new Uint8Array(d)),r.update(n.bytes.bytify(o))}const g=r.digest(),y={index:u,lock:t.inputs.get(u).cellOutput.lock,message:"0x"+Array.prototype.map.call(g,(t=>("00"+t.toString(16)).slice(-2))).join("")};l.push(y)}return l};var r=o(140993),i=o(893597),n=o(852966),a=o(739609);const defaultCkbHasher=()=>{const t=new r.utils.CKBHasher;return{update:e=>t.update(e.buffer),digest:()=>n.bytes.bytify(t.digestHex())}};function resolveThunk(t){return t instanceof Function?t():t}},574393:(t,e,o)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.default=e.CellCollector=void 0,e.injectCapacity=injectCapacity,e.payFee=payFee,e.prepareSigningEntries=prepareSigningEntries,e.setupInputCell=setupInputCell,e.transfer=transfer,e.transferCompatible=transferCompatible;var r=o(706081),i=o(893597),n=o(852966),a=o(140993),s=o(519808),c=o(555258),l=o(446037),u=o(739609);const{ScriptValue:p}=a.values,d=e.CellCollector=class CellCollector{constructor(t,e,{config:o,queryOptions:r={}}={}){if(!e)throw new Error("Cell provider is missing!");o=o||(0,s.getConfig)(),this.fromScript=(0,l.parseFromInfo)(t,{config:o}).fromScript,this.config=o,r={...r,lock:this.fromScript,type:r.type||"empty"},this.cellCollector=e.collector(r)}async*collect(){if((0,c.isSecp256k1Blake160Script)(this.fromScript,this.config))for await(const t of this.cellCollector.collect())yield t}};async function setupInputCell(t,e,o,{config:r,defaultWitness:i="0x",since:l}={}){r=r||(0,s.getConfig)();const u=e.cellOutput.lock;if(!(0,c.isSecp256k1Blake160Script)(u,r))throw new Error("Not SECP256K1_BLAKE160 input!");t=t.update("inputs",(t=>t.push(e)));const d={cellOutput:{capacity:e.cellOutput.capacity,lock:e.cellOutput.lock,type:e.cellOutput.type},data:e.data};t=t.update("outputs",(t=>t.push(d))),l&&(t=t.update("inputSinces",(e=>e.set(t.get("inputs").size-1,l)))),t=t.update("witnesses",(t=>t.push(i)));const f=r.SCRIPTS.SECP256K1_BLAKE160;if(!f)throw new Error("SECP256K1_BLAKE160 script not defined in config!");const h={txHash:f.TX_HASH,index:f.INDEX},g=(t=(0,c.addCellDep)(t,{outPoint:h,depType:f.DEP_TYPE})).get("inputs").findIndex((t=>new p(t.cellOutput.lock,{validate:!1}).equals(new p(u,{validate:!1}))));if(-1!==g){for(;g>=t.get("witnesses").size;)t=t.update("witnesses",(t=>t.push("0x")));let e=t.get("witnesses").get(g);const o={lock:c.SECP_SIGNATURE_PLACEHOLDER};if("0x"!==e){const t=a.blockchain.WitnessArgs.unpack(n.bytes.bytify(e)),r=t.lock;if(r&&o.lock&&!n.bytes.equal(r,o.lock))throw new Error("Lock field in first witness is set aside for signature!");const i=t.inputType;i&&(o.inputType=i);const s=t.outputType;s&&(o.outputType=s)}e=n.bytes.hexify(a.blockchain.WitnessArgs.pack(o)),t=t.update("witnesses",(t=>t.set(g,e)))}return t}async function transfer(t,e,o,r,{config:i,requireToAddress:n=!0,assertAmountEnough:a=!0}={}){const s=await transferCompatible(t,e,o,r,{config:i,requireToAddress:n,assertAmountEnough:a});let c,l;return s instanceof Array?(c=s[0],l=BigInt(s[1].toString()),[c,l]):(c=s,c)}async function transferCompatible(t,e,o,l,{config:d,requireToAddress:f=!0,assertAmountEnough:h=!0}={}){const g=(d=d||(0,s.getConfig)()).SCRIPTS.SECP256K1_BLAKE160;if(!g)throw new Error("Provided config does not have SECP256K1_BLAKE160 script setup!");const y={txHash:g.TX_HASH,index:g.INDEX};t=(0,c.addCellDep)(t,{outPoint:y,depType:g.DEP_TYPE});const m=(0,i.parseAddress)(e,{config:d});if((0,c.ensureScript)(m,d,"SECP256K1_BLAKE160"),f&&!o)throw new Error("You must provide a to address!");let b=u.BI.from(l);if(o){const e=(0,i.parseAddress)(o,{config:d});t=t.update("outputs",(t=>t.push({cellOutput:{capacity:"0x"+b.toString(16),lock:e,type:void 0},data:"0x",outPoint:void 0,blockHash:void 0})))}const C=t.get("fixedEntries").filter((({field:t})=>"outputs"===t)).maxBy((({index:t})=>t));let S=C?C.index+1:0;for(;S<t.get("outputs").size&&b.gt(0);S++){const e=t.get("outputs").get(S);if(new p(e.cellOutput.lock,{validate:!1}).equals(new p(m,{validate:!1}))){const t=u.BI.from(e.cellOutput.capacity);let o;b.gte(t)?o=t:(o=t.sub((0,i.minimalCellCapacityCompatible)(e)),o.gt(b)&&(o=b)),b=b.sub(o),e.cellOutput.capacity="0x"+t.sub(o).toString(16)}}if(t=t.update("outputs",(t=>t.filter((t=>!u.BI.from(t.cellOutput.capacity).eq(0))))),b.gt(0)){const e=t.get("cellProvider");if(!e)throw new Error("Cell provider is missing!");const o=e.collector({lock:m}),n={cellOutput:{capacity:"0x0",lock:m,type:void 0},data:"0x",outPoint:void 0,blockHash:void 0};let a=u.BI.from(0),s=(0,r.Set)();for(const e of t.get("inputs"))s=s.add(`${e.outPoint.txHash}_${e.outPoint.index}`);for await(const e of o.collect()){if(s.has(`${e.outPoint.txHash}_${e.outPoint.index}`))continue;t=(t=t.update("inputs",(t=>t.push(e)))).update("witnesses",(t=>t.push("0x")));const o=u.BI.from(e.cellOutput.capacity);let r=o;if(r.gt(b)&&(r=b),b=b.sub(r),a=a.add(o).sub(r),b.eq(0)&&(a.eq(0)||a.gt((0,i.minimalCellCapacityCompatible)(n))))break}a.gt(0)&&(n.cellOutput.capacity="0x"+a.toString(16),t=t.update("outputs",(t=>t.push(n))))}if(b.gt(0)&&h)throw new Error("Not enough capacity in from address!");const _=t.get("inputs").findIndex((t=>new p(t.cellOutput.lock,{validate:!1}).equals(new p(m,{validate:!1}))));if(-1!==_){for(;_>=t.get("witnesses").size;)t=t.update("witnesses",(t=>t.push("0x")));let e=t.get("witnesses").get(_);const o={lock:c.SECP_SIGNATURE_PLACEHOLDER};if("0x"!==e){const t=a.blockchain.WitnessArgs.unpack(n.bytes.bytify(e)),r=t.lock;if(r&&o.lock&&!n.bytes.equal(r,o.lock))throw new Error("Lock field in first witness is set aside for signature!");const i=t.inputType;i&&(o.inputType=i);const s=t.outputType;s&&(o.outputType=s)}e=n.bytes.hexify(a.blockchain.WitnessArgs.pack(o)),t=t.update("witnesses",(t=>t.set(_,e)))}return h?t:[t,u.BI.from(b)]}async function payFee(t,e,o,{config:r}={}){return r=r||(0,s.getConfig)(),await transferCompatible(t,e,null,o,{config:r,requireToAddress:!1})}async function injectCapacity(t,e,o,{config:r}={}){if(r=r||(0,s.getConfig)(),e>=t.get("outputs").size)throw new Error("Invalid output index!");const i=u.BI.from(t.get("outputs").get(e).cellOutput.capacity);return await transferCompatible(t,o,null,u.BI.from(i),{config:r,requireToAddress:!1})}function prepareSigningEntries(t,{config:e}={}){return e=e||(0,s.getConfig)(),(0,c.prepareSigningEntries)(t,e,"SECP256K1_BLAKE160")}e.default={transfer,transferCompatible,payFee,prepareSigningEntries,injectCapacity,setupInputCell,CellCollector:d}},342202:(t,e,o)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.default=e.CellCollector=void 0,e.injectCapacity=injectCapacity,Object.defineProperty(e,"multisigArgs",{enumerable:!0,get:function(){return l.multisigArgs}}),e.payFee=payFee,e.prepareSigningEntries=prepareSigningEntries,Object.defineProperty(e,"serializeMultisigScript",{enumerable:!0,get:function(){return l.serializeMultisigScript}}),e.setupInputCell=setupInputCell,e.transfer=transfer,e.transferCompatible=transferCompatible;var r=o(893597),i=o(852966),n=o(140993),a=o(519808),s=o(706081),c=o(555258),l=o(446037),u=o(739609);const{ScriptValue:p}=n.values,d=e.CellCollector=class CellCollector{constructor(t,e,{config:o,queryOptions:r={}}={}){if(!e)throw new Error("Cell provider is missing!");o=o||(0,a.getConfig)();const i=(0,l.parseFromInfo)(t,{config:o});this.fromScript=i.fromScript,this.multisigScript=i.multisigScript,this.config=o,r={...r,lock:this.fromScript,type:r.type||"empty"},this.cellCollector=e.collector(r)}async*collect(){if((0,c.isSecp256k1Blake160MultisigScript)(this.fromScript,this.config))for await(const t of this.cellCollector.collect())yield t}};async function setupInputCell(t,e,o,{config:r,defaultWitness:s="0x",since:u,requireMultisigScript:d=!0}={}){if(r=r||(0,a.getConfig)(),d&&"object"!=typeof o)throw new Error("`fromInfo` must be MultisigScript format!");const f=e.cellOutput.lock;if(o){const t=(0,l.parseFromInfo)(o,{config:r}).fromScript;if(!new p(t,{validate:!1}).equals(new p(f,{validate:!1})))throw new Error("`fromInfo` not match to input lock!")}if(!(0,c.isSecp256k1Blake160MultisigScript)(f,r))throw new Error("Not SECP256K1_BLAKE160_MULTISIG input!");t=t.update("inputs",(t=>t.push(e))),u&&(t=t.update("inputSinces",(e=>e.set(t.get("inputs").size-1,u)))),t=t.update("witnesses",(t=>t.push(s)));const h={cellOutput:{capacity:e.cellOutput.capacity,lock:e.cellOutput.lock,type:e.cellOutput.type},data:e.data};t=t.update("outputs",(t=>t.push(h)));const g=r.SCRIPTS.SECP256K1_BLAKE160_MULTISIG;if(!g)throw new Error("SECP256K1_BLAKE160_MULTISIG script not defined in config!");const y={txHash:g.TX_HASH,index:g.INDEX},m=(t=(0,c.addCellDep)(t,{outPoint:y,depType:g.DEP_TYPE})).get("inputs").findIndex((t=>new p(t.cellOutput.lock,{validate:!1}).equals(new p(f,{validate:!1}))));if(-1!==m){for(;m>=t.get("witnesses").size;)t=t.update("witnesses",(t=>t.push("0x")));if("0x"===t.get("witnesses").get(m)&&"object"!=typeof o)throw new Error("`fromInfo` must be MultisigScript format!");if("object"==typeof o){const e=(0,l.parseFromInfo)(o,{config:r}).multisigScript;let a=t.get("witnesses").get(m);const s={lock:"0x"+e.slice(2)+c.SECP_SIGNATURE_PLACEHOLDER.slice(2).repeat(o.M)};if("0x"!==a){const t=n.blockchain.WitnessArgs.unpack(i.bytes.bytify(a)),e=t.lock;if(e&&s.lock&&!i.bytes.equal(e,s.lock))throw new Error("Lock field in first witness is set aside for signature!");const o=t.inputType;o&&(s.inputType=o);const r=t.outputType;r&&(s.outputType=r)}a=i.bytes.hexify(n.blockchain.WitnessArgs.pack(s)),t=t.update("witnesses",(t=>t.set(m,a)))}}return t}async function transfer(t,e,o,r,{config:i,requireToAddress:n=!0,assertAmountEnough:a=!0}={}){const s=await transferCompatible(t,e,o,r,{config:i,requireToAddress:n,assertAmountEnough:a});let c,l;return s instanceof Array?(c=s[0],l=BigInt(s[1].toString()),[c,l]):(c=s,c)}async function transferCompatible(t,e,o,d,{config:f,requireToAddress:h=!0,assertAmountEnough:g=!0}={}){const y=(f=f||(0,a.getConfig)()).SCRIPTS.SECP256K1_BLAKE160_MULTISIG;if(!y)throw new Error("Provided config does not have SECP256K1_BLAKE16_MULTISIG script setup!");const m={txHash:y.TX_HASH,index:y.INDEX};t=(0,c.addCellDep)(t,{outPoint:m,depType:y.DEP_TYPE});const{fromScript:b,multisigScript:C}=(0,l.parseFromInfo)(e,{config:f});(0,c.ensureScript)(b,f,"SECP256K1_BLAKE160_MULTISIG");const S=!t.get("inputs").find((t=>new p(t.cellOutput.lock,{validate:!1}).equals(new p(b,{validate:!1}))));if(S&&"string"===e)throw new Error("MultisigScript is required for witness!");if(h&&!o)throw new Error("You must provide a to address!");let _=d?u.BI.from(d):u.BI.from(0);if(o){const e=(0,r.parseAddress)(o,{config:f});t=t.update("outputs",(t=>t.push({cellOutput:{capacity:"0x"+_.toString(16),lock:e,type:void 0},data:"0x",outPoint:void 0,blockHash:void 0})))}const k=t.get("fixedEntries").filter((({field:t})=>"outputs"===t)).maxBy((({index:t})=>t));let w=k?k.index+1:0;for(;w<t.get("outputs").size&&_.gt(0);++w){const e=t.get("outputs").get(w);if(new p(e.cellOutput.lock,{validate:!1}).equals(new p(b,{validate:!1}))){const t=u.BI.from(e.cellOutput.capacity);let o;_.gte(t)?o=t:(o=t.sub((0,r.minimalCellCapacityCompatible)(e)),o.gt(_)&&(o=_)),_=_.sub(o),e.cellOutput.capacity="0x"+t.sub(o).toString(16)}}if(t=t.update("outputs",(t=>t.filter((t=>!u.BI.from(t.cellOutput.capacity).eq(0))))),_.gt(0)){const e=t.get("cellProvider");if(!e)throw new Error("cell provider is missing!");const o=e.collector({lock:b}),i={cellOutput:{capacity:"0x0",lock:b,type:void 0},data:"0x",outPoint:void 0,blockHash:void 0};let n=u.BI.from(0),a=(0,s.Set)();for(const e of t.get("inputs"))a=a.add(`${e.outPoint.txHash}_${e.outPoint.index}`);for await(const e of o.collect()){if(a.has(`${e.outPoint.txHash}_${e.outPoint.index}`))continue;t=(t=t.update("inputs",(t=>t.push(e)))).update("witnesses",(t=>t.push("0x")));const o=u.BI.from(e.cellOutput.capacity);let s=o;if(s.gt(_)&&(s=_),_=_.sub(s),n=n.add(o.sub(s)),_.eq(0)&&(n.eq(0)||n.gt((0,r.minimalCellCapacityCompatible)(i))))break}n.gt(0)&&(i.cellOutput.capacity="0x"+n.toString(16),t=t.update("outputs",(t=>t.push(i))))}if(_.gt(0)&&g)throw new Error("Not enough capacity in from address!");const x=t.get("inputs").findIndex((t=>new p(t.cellOutput.lock,{validate:!1}).equals(new p(b,{validate:!1}))));if(-1!==x){for(;u.BI.from(x).gte(t.get("witnesses").size);)t=t.update("witnesses",(t=>t.push("0x")));if(S||"string"!=typeof e){let o=t.get("witnesses").get(x);const r={lock:"0x"+C.slice(2)+c.SECP_SIGNATURE_PLACEHOLDER.slice(2).repeat(e.M)};if("0x"!==o){const t=n.blockchain.WitnessArgs.unpack(i.bytes.bytify(o)),e=t.lock;if(e&&r.lock&&!i.bytes.equal(e,r.lock))throw new Error("Lock field in first witness is set aside for signature!");const a=t.inputType;a&&(r.inputType=a);const s=t.outputType;s&&(r.outputType=s)}o=i.bytes.hexify(n.blockchain.WitnessArgs.pack(r)),t=t.update("witnesses",(t=>t.set(x,o)))}}return g?t:[t,u.BI.from(_)]}async function payFee(t,e,o,{config:r}={}){return transferCompatible(t,e,void 0,o,{config:r=r||(0,a.getConfig)(),requireToAddress:!1})}async function injectCapacity(t,e,o,{config:r}={}){if(r=r||(0,a.getConfig)(),e>=t.get("outputs").size)throw new Error("Invalid output index!");const i=u.BI.from(t.get("outputs").get(e).cellOutput.capacity);return transferCompatible(t,o,void 0,i,{config:r,requireToAddress:!1})}function prepareSigningEntries(t,{config:e}={}){return e=e||(0,a.getConfig)(),(0,c.prepareSigningEntries)(t,e,"SECP256K1_BLAKE160_MULTISIG")}e.default={transfer,transferCompatible,payFee,prepareSigningEntries,serializeMultisigScript:l.serializeMultisigScript,multisigArgs:l.multisigArgs,injectCapacity,setupInputCell,CellCollector:d}},77922:(t,e,o)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.default=void 0,e.issueToken=issueToken,e.ownerForSudt=ownerForSudt,e.packAmount=packAmount,e.transfer=transfer,e.unpackAmount=unpackAmount;var r=o(555258),i=o(140993),n=_interopRequireDefault(o(342202)),a=o(446037),s=_interopRequireDefault(o(974247)),c=o(893597),l=o(706081),u=o(519808),p=o(474233),d=function _interopRequireWildcard(t,e){if(!e&&t&&t.__esModule)return t;if(null===t||"object"!=typeof t&&"function"!=typeof t)return{default:t};var o=_getRequireWildcardCache(e);if(o&&o.has(t))return o.get(t);var r={__proto__:null},i=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var n in t)if("default"!==n&&{}.hasOwnProperty.call(t,n)){var a=i?Object.getOwnPropertyDescriptor(t,n):null;a&&(a.get||a.set)?Object.defineProperty(r,n,a):r[n]=t[n]}return r.default=t,o&&o.set(t,r),r}(o(911584)),f=_interopRequireDefault(o(574393)),h=o(739609),g=o(852966);function _getRequireWildcardCache(t){if("function"!=typeof WeakMap)return null;var e=new WeakMap,o=new WeakMap;return(_getRequireWildcardCache=function(t){return t?o:e})(t)}function _interopRequireDefault(t){return t&&t.__esModule?t:{default:t}}const{computeScriptHash:y}=i.utils,{ScriptValue:m}=i.values;async function issueToken(t,e,o,i,n,{config:l}={}){const p=(l=l||(0,u.getConfig)()).SCRIPTS.SUDT;if(!p)throw new Error("Provided config does not have SUDT script setup!");t=(0,r.addCellDep)(t,{outPoint:{txHash:p.TX_HASH,index:p.INDEX},depType:p.DEP_TYPE});const d=(0,a.parseFromInfo)(e,{config:l}).fromScript,f={cellOutput:{capacity:"0x0",lock:d,type:{codeHash:p.CODE_HASH,hashType:p.HASH_TYPE,args:y(d)}},data:g.bytes.hexify(g.number.Uint128LE.pack(o)),outPoint:void 0,blockHash:void 0};i||(i=(0,c.minimalCellCapacityCompatible)(f));const m=h.BI.from(i);f.cellOutput.capacity="0x"+m.toString(16);const b=(t=t.update("outputs",(t=>t.push(f)))).get("outputs").size-1;return t=t.update("fixedEntries",(t=>t.push({field:"outputs",index:b}))),t=await s.default.injectCapacity(t,[e],h.BI.from(h.BI.from(f.cellOutput.capacity)),void 0,n,{config:l})}async function transfer(t,e,o,i,y,b,C,S,{config:_,LocktimePoolCellCollector:k=p.CellCollector,splitChangeCell:w=!1}={}){_=_||(0,u.getConfig)();let x=h.BI.from(y),E=C?h.BI.from(C):void 0;const I=_.SCRIPTS.SUDT;if(!I)throw new Error("Provided config does not have SUDT script setup!");if(0===e.length)throw new Error("`fromInfos` can't be empty!");if(!i)throw new Error("You must provide a to address!");const O=(0,c.parseAddress)(i,{config:_}),v=e.map((t=>(0,a.parseFromInfo)(t,{config:_}).fromScript)),T=b?(0,c.parseAddress)(b,{config:_}):v[0];if(x.lte(0))throw new Error("amount must be greater than 0");const P=function _generateSudtScript(t,e){const o=e.SCRIPTS.SUDT;return{codeHash:o.CODE_HASH,hashType:o.HASH_TYPE,args:t}}(o,_),B=t.get("cellProvider");if(!B)throw new Error("Cell provider is missing!");let A=h.BI.from(0),H=h.BI.from(0);if((0,r.isAcpScript)(O,_)){const e=new d.CellCollector(i,B,{config:_,queryOptions:{type:P,data:"any"}}),o=(await e.collect().next()).value;if(!o)throw new Error("toAddress ANYONE_CAN_PAY input not found!");t=(t=t.update("inputs",(t=>t.push(o)))).update("witnesses",(t=>t.push("0x"))),A=h.BI.from(o.cellOutput.capacity),H=unpackAmount(o.data)}const D={cellOutput:{capacity:"0x0",lock:O,type:P},data:g.bytes.hexify(g.number.Uint128LE.pack(x)),outPoint:void 0,blockHash:void 0};(0,r.isAcpScript)(O,_)?(E||(E=h.BI.from(0)),D.cellOutput.capacity="0x"+A.add(E).toString(16),D.data=g.bytes.hexify(g.number.Uint128LE.pack(H.add(x)))):(E||(E=h.BI.from((0,c.minimalCellCapacityCompatible)(D))),D.cellOutput.capacity="0x"+E.toString(16)),t=(t=t.update("outputs",(t=>t.push(D)))).update("fixedEntries",(e=>e.push({field:"outputs",index:t.get("outputs").size-1}))),t=(0,r.addCellDep)(t,{outPoint:{txHash:I.TX_HASH,index:I.INDEX},depType:I.DEP_TYPE});const R={cellOutput:{capacity:"0x0",lock:T,type:P},data:g.bytes.hexify(g.number.Uint128LE.pack(0)),outPoint:void 0,blockHash:void 0},L={cellOutput:{capacity:"0x0",lock:T,type:void 0},data:"0x",outPoint:void 0,blockHash:void 0};let M=h.BI.from(0),F=h.BI.from(0),N=(0,l.Set)();for(const e of t.get("inputs"))N=N.add(`${e.outPoint.txHash}_${e.outPoint.index}`);let W=(0,l.List)();S&&e.forEach(((t,e)=>{const o=new k(t,B,{config:_,tipHeader:S,queryOptions:{type:P,data:"any"}});W=W.push({cellCollector:o,index:e})})),e.forEach(((t,e)=>{const o=new f.default.CellCollector(t,B,{config:_,queryOptions:{type:P,data:"any"}}),r=new n.default.CellCollector(t,B,{config:_,queryOptions:{type:P,data:"any"}}),i=new d.default.CellCollector(t,B,{config:_,queryOptions:{type:P,data:"any"}});W=W.push({cellCollector:o,index:e},{cellCollector:r,index:e},{cellCollector:i,index:e,isAnyoneCanPay:!0,destroyable:(0,a.parseFromInfo)(t,{config:_}).destroyable})})),S&&e.forEach(((t,e)=>{const o=new k(t,B,{config:_,tipHeader:S});W=W.push({cellCollector:o,index:e})})),e.forEach(((t,e)=>{const o=new f.default.CellCollector(t,B,{config:_}),r=new n.default.CellCollector(t,B,{config:_}),i=new d.default.CellCollector(t,B,{config:_});W=W.push({cellCollector:o,index:e},{cellCollector:r,index:e},{cellCollector:i,index:e,isAnyoneCanPay:!0,destroyable:(0,a.parseFromInfo)(t,{config:_}).destroyable})}));for(const{index:o,cellCollector:r,isAnyoneCanPay:i,destroyable:n}of W)for await(const a of r.collect()){const r=`${a.outPoint.txHash}_${a.outPoint.index}`;if(N.has(r))continue;N=N.add(r);const l=e[o],u=(t=await s.default.setupInputCell(t,a,l,{config:_})).get("outputs").size-1,p=(t=t.update("outputs",(t=>t.remove(u)))).get("fixedEntries").findIndex((t=>"outputs"===t.field&&t.index===u));p>=0&&(t=t.update("fixedEntries",(t=>t.remove(p))));const d=h.BI.from(a.cellOutput.capacity),f=a.cellOutput.type?unpackAmount(a.data):h.BI.from(0);let y=i&&!n?d.sub((0,c.minimalCellCapacityCompatible)(a)):d,m=f;y.gt(E)&&(y=h.BI.from(E)),E=E.sub(y);const b=d.sub(y);(!i||i&&n)&&(M=M.add(b)),m.gt(x)&&(m=x),x=x.sub(m);const C=f.sub(m);if((!i||i&&n)&&(F=F.add(C)),i&&!n){const e={cellOutput:{capacity:"0x"+b.toString(16),lock:a.cellOutput.lock,type:a.cellOutput.type},data:a.cellOutput.type?g.bytes.hexify(g.number.Uint128LE.pack(C)):"0x"};t=t.update("outputs",(t=>t.push(e))),a.cellOutput.type&&(t=t.update("fixedEntries",(e=>e.push({field:"outputs",index:t.get("outputs").size-1}))))}if(E.eq(0)&&x.eq(0)&&(M.eq(0)&&F.eq(0)||M.gt((0,c.minimalCellCapacityCompatible)(L))&&F.eq(0))){R.cellOutput.type=void 0,R.data="0x";break}if(E.eq(0)&&x.eq(0)&&M.gt((0,c.minimalCellCapacityCompatible)(L))&&F.gt(0))break}let q=-1;if((0,r.isAcpScript)(R.cellOutput.lock,_)&&-1!==(q=t.get("outputs").findIndex((t=>new m(R.cellOutput.lock,{validate:!1}).equals(new m(t.cellOutput.lock,{validate:!1}))&&(F.eq(0)&&!R.cellOutput.type&&!t.cellOutput.type||F.gte(0)&&!!R.cellOutput.type&&!!t.cellOutput.type&&new m(R.cellOutput.type,{validate:!1}).equals(new m(t.cellOutput.type,{validate:!1}))))))&&-1===t.get("fixedEntries").findIndex((t=>"output"===t.field&&t.index===q))){const e=t.get("outputs").get(q),o=JSON.parse(JSON.stringify(e));o.cellOutput.capacity="0x"+h.BI.from(e.cellOutput.capacity).add(M).toString(16),F.gt(0)&&(o.data=g.bytes.hexify(g.number.Uint128LE.pack(unpackAmount(e.data).add(F))));const r=h.BI.from((0,c.minimalCellCapacityCompatible)(R)),i=h.BI.from((0,c.minimalCellCapacityCompatible)(L));let n=!1;F.gt(0)&&w&&M.gte(r.add(i))&&(o.cellOutput.capacity=e.cellOutput.capacity,L.cellOutput.capacity="0x"+M.toString(16),n=!0),t=t.update("outputs",(t=>t.set(q,o))),n&&(t=t.update("outputs",(t=>t.push(L))))}else if(M.gte((0,c.minimalCellCapacityCompatible)(R))){R.cellOutput.capacity="0x"+M.toString(16),F.gt(0)&&(R.data=g.bytes.hexify(g.number.Uint128LE.pack(F)));const e=h.BI.from((0,c.minimalCellCapacityCompatible)(R)),o=h.BI.from((0,c.minimalCellCapacityCompatible)(L));let r=!1;F.gt(0)&&w&&M.gte(e.add(o))&&(R.cellOutput.capacity="0x"+e.toString(16),L.cellOutput.capacity="0x"+M.sub(e).toString(16),r=!0),t=t.update("outputs",(t=>t.push(R))),F.gt(0)&&(t=t.update("fixedEntries",(e=>e.push({field:"outputs",index:t.get("outputs").size-1})))),r&&(t=t.update("outputs",(t=>t.push(L))))}else if(F.gt(0)&&M.lt((0,c.minimalCellCapacityCompatible)(R)))throw new Error("Not enough capacity for change in from infos!");if(E.gt(0))throw new Error("Not enough capacity in from infos!");if(x.gt(0))throw new Error("Not enough amount in from infos!");return t}function ownerForSudt(t,{config:e}={}){e=e||(0,u.getConfig)();const{fromScript:o}=(0,a.parseFromInfo)(t,{config:e});return y(o)}function unpackAmount(t){return g.number.Uint128LE.unpack(g.bytes.bytify(t).slice(0,16))}function packAmount(t){return g.bytes.hexify(g.number.Uint128LE.pack(t))}e.default={issueToken,transfer,ownerForSudt,packAmount,unpackAmount}},464509:t=>{"use strict";t.exports=function base(t){if(t.length>=255)throw new TypeError("Alphabet too long");for(var e=new Uint8Array(256),o=0;o<e.length;o++)e[o]=255;for(var r=0;r<t.length;r++){var i=t.charAt(r),n=i.charCodeAt(0);if(255!==e[n])throw new TypeError(i+" is ambiguous");e[n]=r}var a=t.length,s=t.charAt(0),c=Math.log(a)/Math.log(256),l=Math.log(256)/Math.log(a);function decodeUnsafe(t){if("string"!=typeof t)throw new TypeError("Expected String");if(0===t.length)return new Uint8Array;for(var o=0,r=0,i=0;t[o]===s;)r++,o++;for(var n=(t.length-o)*c+1>>>0,l=new Uint8Array(n);t[o];){var u=e[t.charCodeAt(o)];if(255===u)return;for(var p=0,d=n-1;(0!==u||p<i)&&-1!==d;d--,p++)u+=a*l[d]>>>0,l[d]=u%256>>>0,u=u/256>>>0;if(0!==u)throw new Error("Non-zero carry");i=p,o++}for(var f=n-i;f!==n&&0===l[f];)f++;for(var h=new Uint8Array(r+(n-f)),g=r;f!==n;)h[g++]=l[f++];return h}return{encode:function encode(e){if(e instanceof Uint8Array||(ArrayBuffer.isView(e)?e=new Uint8Array(e.buffer,e.byteOffset,e.byteLength):Array.isArray(e)&&(e=Uint8Array.from(e))),!(e instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(0===e.length)return"";for(var o=0,r=0,i=0,n=e.length;i!==n&&0===e[i];)i++,o++;for(var c=(n-i)*l+1>>>0,u=new Uint8Array(c);i!==n;){for(var p=e[i],d=0,f=c-1;(0!==p||d<r)&&-1!==f;f--,d++)p+=256*u[f]>>>0,u[f]=p%a>>>0,p=p/a>>>0;if(0!==p)throw new Error("Non-zero carry");r=d,i++}for(var h=c-r;h!==c&&0===u[h];)h++;for(var g=s.repeat(o);h<c;++h)g+=t.charAt(u[h]);return g},decodeUnsafe,decode:function decode(t){var e=decodeUnsafe(t);if(e)return e;throw new Error("Non-base"+a+" character")}}}},185218:(t,e,o)=>{const r=o(464509);t.exports=r("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz")},426488:(t,e,o)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.default=void 0;var r=o(907823),i=function _interopRequireWildcard(t,e){if(!e&&t&&t.__esModule)return t;if(null===t||"object"!=typeof t&&"function"!=typeof t)return{default:t};var o=_getRequireWildcardCache(e);if(o&&o.has(t))return o.get(t);var r={__proto__:null},i=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var n in t)if("default"!==n&&{}.hasOwnProperty.call(t,n)){var a=i?Object.getOwnPropertyDescriptor(t,n):null;a&&(a.get||a.set)?Object.defineProperty(r,n,a):r[n]=t[n]}return r.default=t,o&&o.set(t,r),r}(o(593202));function _getRequireWildcardCache(t){if("function"!=typeof WeakMap)return null;var e=new WeakMap,o=new WeakMap;return(_getRequireWildcardCache=function(t){return t?o:e})(t)}e.default={getTipBlockNumber:{method:"get_tip_block_number",paramsFormatters:[],resultFormatters:i.toNumber},getTipHeader:{method:"get_tip_header",paramsFormatters:[],resultFormatters:i.toHeader},getCurrentEpoch:{method:"get_current_epoch",paramsFormatters:[],resultFormatters:i.toEpoch},getEpochByNumber:{method:"get_epoch_by_number",paramsFormatters:[r.formatter.toNumber],resultFormatters:i.toEpoch},getBlockHash:{method:"get_block_hash",paramsFormatters:[r.formatter.toNumber]},getBlock:{method:"get_block",paramsFormatters:[r.formatter.toHash],resultFormatters:i.toBlock},getBlockByNumber:{method:"get_block_by_number",paramsFormatters:[r.formatter.toNumber],resultFormatters:i.toBlock},getHeader:{method:"get_header",paramsFormatters:[r.formatter.toHash],resultFormatters:i.toHeader},getHeaderByNumber:{method:"get_header_by_number",paramsFormatters:[r.formatter.toNumber],resultFormatters:i.toHeader},getLiveCell:{method:"get_live_cell",paramsFormatters:[r.formatter.toOutPoint],resultFormatters:i.toLiveCellWithStatus},getTransaction:{method:"get_transaction",paramsFormatters:[r.formatter.toHash],resultFormatters:i.toTransactionWithStatus},getCellbaseOutputCapacityDetails:{method:"get_cellbase_output_capacity_details",paramsFormatters:[r.formatter.toHash],resultFormatters:i.toCellbaseOutputCapacityDetails},getBlockEconomicState:{method:"get_block_economic_state",paramsFormatters:[r.formatter.toHash],resultFormatters:i.toBlockEconomicState},getTransactionProof:{method:"get_transaction_proof",paramsFormatters:[r.formatter.toArray(r.formatter.toHash),r.formatter.toOptional(r.formatter.toHash)],resultFormatters:i.toTransactionProof},verifyTransactionProof:{method:"verify_transaction_proof",paramsFormatters:[r.formatter.toTransactionProof]},getConsensus:{method:"get_consensus",paramsFormatters:[],resultFormatters:i.toConsensus}}},821323:(t,e,o)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.default=void 0;var r=o(907823);e.default={dryRunTransaction:{method:"dry_run_transaction",paramsFormatters:[r.formatter.toRawTransaction]},calculateDaoMaximumWithdraw:{method:"calculate_dao_maximum_withdraw",paramsFormatters:[r.formatter.toOutPoint,r.formatter.toHash]}}},167837:(t,e,o)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.rpcProperties=e.Base=void 0;var r=_interopRequireDefault(o(426488)),i=_interopRequireDefault(o(821323)),n=_interopRequireDefault(o(309154)),a=_interopRequireDefault(o(600027)),s=_interopRequireDefault(o(829862)),c=_interopRequireDefault(o(511766));function _interopRequireDefault(t){return t&&t.__esModule?t:{default:t}}const l=e.rpcProperties={...r.default,...i.default,...c.default,...n.default,...a.default,...s.default};e.Base=class Base{#t=l;get rpcProperties(){return this.#t}}},511766:(t,e,o)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.default=void 0;var r=o(907823),i=function _interopRequireWildcard(t,e){if(!e&&t&&t.__esModule)return t;if(null===t||"object"!=typeof t&&"function"!=typeof t)return{default:t};var o=_getRequireWildcardCache(e);if(o&&o.has(t))return o.get(t);var r={__proto__:null},i=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var n in t)if("default"!==n&&{}.hasOwnProperty.call(t,n)){var a=i?Object.getOwnPropertyDescriptor(t,n):null;a&&(a.get||a.set)?Object.defineProperty(r,n,a):r[n]=t[n]}return r.default=t,o&&o.set(t,r),r}(o(593202));function _getRequireWildcardCache(t){if("function"!=typeof WeakMap)return null;var e=new WeakMap,o=new WeakMap;return(_getRequireWildcardCache=function(t){return t?o:e})(t)}const n={getIndexerTip:{method:"get_indexer_tip",paramsFormatters:[],resultFormatters:i.toTip},getCells:{method:"get_cells",paramsFormatters:[r.formatter.toGetCellsSearchKey,r.formatter.toOrder,r.formatter.toNumber,r.formatter.toOptional(r.formatter.toHash)],resultFormatters:i.toGetCellsResult},getTransactions:{method:"get_transactions",paramsFormatters:[r.formatter.toGetTransactionsSearchKey,r.formatter.toOrder,r.formatter.toNumber,r.formatter.toOptional(r.formatter.toHash)],resultFormatters:i.toGetTransactionsResult},getCellsCapacity:{method:"get_cells_capacity",paramsFormatters:[r.formatter.toSearchKey],resultFormatters:i.toCellsCapacity},getBlockFilter:{method:"get_block_filter",paramsFormatters:[r.formatter.toHash],resultFormatters:i.toNullable(i.toBlockFilter)},getTransactionAndWitnessProof:{method:"get_transaction_and_witness_proof",paramsFormatters:[r.formatter.toArray(r.formatter.toHash),r.formatter.toOptional(r.formatter.toHash)],resultFormatters:i.toTransactionAndWitnessProof},verifyTransactionAndWitnessProof:{method:"verify_transaction_and_witness_proof",paramsFormatters:[r.formatter.toTransactionAndWitnessProof],resultFormatters:i.toArray(i.toHash)},getForkBlock:{method:"get_fork_block",paramsFormatters:[r.formatter.toHash,r.formatter.toOptional(r.formatter.toNumber)],resultFormatters:i.toNullable(i.toForkBlockResult)},getBlockMedianTime:{method:"get_block_median_time",paramsFormatters:[r.formatter.toHash],resultFormatters:i.toNullable(i.toNumber)},estimateCycles:{method:"estimate_cycles",paramsFormatters:[r.formatter.toRawTransaction],resultFormatters:i.toEstimateCycles},getFeeRateStatistics:{method:"get_fee_rate_statistics",paramsFormatters:[r.formatter.toOptional(r.formatter.toNumber)],resultFormatters:i.toNullable(i.toFeeRateStatistics)},getFeeRateStatics:{method:"get_fee_rate_statics",paramsFormatters:[r.formatter.toOptional(r.formatter.toNumber)],resultFormatters:i.toNullable(i.toFeeRateStatistics)}};e.default=n},309154:(t,e,o)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.default=void 0;var r=o(907823),i=function _interopRequireWildcard(t,e){if(!e&&t&&t.__esModule)return t;if(null===t||"object"!=typeof t&&"function"!=typeof t)return{default:t};var o=_getRequireWildcardCache(e);if(o&&o.has(t))return o.get(t);var r={__proto__:null},i=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var n in t)if("default"!==n&&{}.hasOwnProperty.call(t,n)){var a=i?Object.getOwnPropertyDescriptor(t,n):null;a&&(a.get||a.set)?Object.defineProperty(r,n,a):r[n]=t[n]}return r.default=t,o&&o.set(t,r),r}(o(593202));function _getRequireWildcardCache(t){if("function"!=typeof WeakMap)return null;var e=new WeakMap,o=new WeakMap;return(_getRequireWildcardCache=function(t){return t?o:e})(t)}e.default={localNodeInfo:{method:"local_node_info",paramsFormatters:[],resultFormatters:i.toLocalNodeInfo},getPeers:{method:"get_peers",paramsFormatters:[],resultFormatters:i.toPeers},getBannedAddresses:{method:"get_banned_addresses",paramsFormatters:[],resultFormatters:i.toBannedAddresses},clearBannedAddresses:{method:"clear_banned_addresses",paramsFormatters:[]},setBan:{method:"set_ban",paramsFormatters:[]},syncState:{method:"sync_state",paramsFormatters:[],resultFormatters:i.toSyncState},setNetworkActive:{method:"set_network_active",paramsFormatters:[r.formatter.toBoolean]},addNode:{method:"add_node",paramsFormatters:[]},removeNode:{method:"remove_node",paramsFormatters:[]},pingPeers:{method:"ping_peers",paramsFormatters:[]}}},600027:(t,e,o)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.default=void 0;var r=o(907823),i=function _interopRequireWildcard(t,e){if(!e&&t&&t.__esModule)return t;if(null===t||"object"!=typeof t&&"function"!=typeof t)return{default:t};var o=_getRequireWildcardCache(e);if(o&&o.has(t))return o.get(t);var r={__proto__:null},i=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var n in t)if("default"!==n&&{}.hasOwnProperty.call(t,n)){var a=i?Object.getOwnPropertyDescriptor(t,n):null;a&&(a.get||a.set)?Object.defineProperty(r,n,a):r[n]=t[n]}return r.default=t,o&&o.set(t,r),r}(o(593202));function _getRequireWildcardCache(t){if("function"!=typeof WeakMap)return null;var e=new WeakMap,o=new WeakMap;return(_getRequireWildcardCache=function(t){return t?o:e})(t)}e.default={sendTransaction:{method:"send_transaction",paramsFormatters:[r.formatter.toRawTransaction,r.formatter.toOutputsValidator],resultFormatters:i.toHash},txPoolInfo:{method:"tx_pool_info",paramsFormatters:[],resultFormatters:i.toTxPoolInfo},clearTxPool:{method:"clear_tx_pool",paramsFormatters:[]},getRawTxPool:{method:"get_raw_tx_pool",paramsFormatters:[],resultFormatters:i.toRawTxPool}}},829862:(t,e,o)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.default=void 0;var r=function _interopRequireWildcard(t,e){if(!e&&t&&t.__esModule)return t;if(null===t||"object"!=typeof t&&"function"!=typeof t)return{default:t};var o=_getRequireWildcardCache(e);if(o&&o.has(t))return o.get(t);var r={__proto__:null},i=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var n in t)if("default"!==n&&{}.hasOwnProperty.call(t,n)){var a=i?Object.getOwnPropertyDescriptor(t,n):null;a&&(a.get||a.set)?Object.defineProperty(r,n,a):r[n]=t[n]}return r.default=t,o&&o.set(t,r),r}(o(593202));function _getRequireWildcardCache(t){if("function"!=typeof WeakMap)return null;var e=new WeakMap,o=new WeakMap;return(_getRequireWildcardCache=function(t){return t?o:e})(t)}e.default={getBlockchainInfo:{method:"get_blockchain_info",paramsFormatters:[],resultFormatters:r.toBlockchainInfo},getDeploymentsInfo:{method:"get_deployments_info",paramsFormatters:[],resultFormatters:r.toDeploymentsInfo}}},50725:(t,e)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.default=e.ErrorCode=void 0;let o=e.ErrorCode=function(t){return t[t.ParameterInvalid=101]="ParameterInvalid",t[t.IdNotMatch=201]="IdNotMatch",t[t.MethodNotFound=202]="MethodNotFound",t[t.PayloadMessage=203]="PayloadMessage",t[t.ResponseMessage=204]="ResponseMessage",t}({});e.default=o},377478:(t,e,o)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.default=e.PayloadInBatchException=e.MethodInBatchNotFoundException=e.IdNotMatchedInBatchException=void 0;var r=function _interopRequireDefault(t){return t&&t.__esModule?t:{default:t}}(o(50725)),i=o(323729);const n="Batch Request";class MethodInBatchNotFoundException extends Error{code=r.default.MethodNotFound;constructor(t){super(`[${n}]: Method ${t} is not found`)}}e.MethodInBatchNotFoundException=MethodInBatchNotFoundException;class PayloadInBatchException extends Error{code=r.default.PayloadMessage;constructor(t,e){super(`[${n} ${t}]: ${e}`),this.index=t}}e.PayloadInBatchException=PayloadInBatchException;class IdNotMatchedInBatchException extends i.IdNotMatchException{constructor(t,e,o){super(e,o),this.message=`[${n} ${t}]: ${this.message}`,this.index=t}}e.IdNotMatchedInBatchException=IdNotMatchedInBatchException;e.default={MethodInBatchNotFoundException,PayloadInBatchException,IdNotMatchedInBatchException}},803380:(t,e,o)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.default=e.StringHashTypeException=e.PageSizeTooSmallException=e.PageSizeTooLargeException=e.OutputsValidatorTypeException=e.HexStringWithout0xException=e.BigintOrHexStringTypeException=void 0;var r=function _interopRequireDefault(t){return t&&t.__esModule?t:{default:t}}(o(50725));class PageSizeTooLargeException extends RangeError{code=r.default.ParameterInvalid;constructor(t,e){super(`Expect page size to be at most ${e}, but ${t} received`)}}e.PageSizeTooLargeException=PageSizeTooLargeException;class PageSizeTooSmallException extends RangeError{code=r.default.ParameterInvalid;constructor(t,e){super(`Expect page size to be at least ${e}, but ${t} received`)}}e.PageSizeTooSmallException=PageSizeTooSmallException;class OutputsValidatorTypeException extends TypeError{code=r.default.ParameterInvalid;constructor(){super("Expect outputs validator to be 'default' or 'passthrough'")}}e.OutputsValidatorTypeException=OutputsValidatorTypeException;class BigintOrHexStringTypeException extends TypeError{code=r.default.ParameterInvalid;constructor(t){super(`Expect number to be bigint or hex string, but ${t} received`)}}e.BigintOrHexStringTypeException=BigintOrHexStringTypeException;class StringHashTypeException extends TypeError{code=r.default.ParameterInvalid;constructor(t){super(`Expect hash to be string, but ${t} received`)}}e.StringHashTypeException=StringHashTypeException;class HexStringWithout0xException extends Error{code=r.default.ParameterInvalid;constructor(t){super(`Hex string ${t} should start with 0x`)}}e.HexStringWithout0xException=HexStringWithout0xException;e.default={PageSizeTooLargeException,PageSizeTooSmallException,OutputsValidatorTypeException,BigintOrHexStringTypeException,StringHashTypeException,HexStringWithout0xException}},409314:(t,e,o)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0});var r=o(803380);Object.keys(r).forEach((function(t){"default"!==t&&"__esModule"!==t&&(t in e&&e[t]===r[t]||Object.defineProperty(e,t,{enumerable:!0,get:function(){return r[t]}}))}));var i=o(323729);Object.keys(i).forEach((function(t){"default"!==t&&"__esModule"!==t&&(t in e&&e[t]===i[t]||Object.defineProperty(e,t,{enumerable:!0,get:function(){return i[t]}}))}));var n=o(377478);Object.keys(n).forEach((function(t){"default"!==t&&"__esModule"!==t&&(t in e&&e[t]===n[t]||Object.defineProperty(e,t,{enumerable:!0,get:function(){return n[t]}}))}))},323729:(t,e,o)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.default=e.ResponseException=e.IdNotMatchException=void 0;var r=function _interopRequireDefault(t){return t&&t.__esModule?t:{default:t}}(o(50725));class IdNotMatchException extends Error{code=r.default.IdNotMatch;constructor(t,e){super(`Expect json rpc id to be ${t}, but ${e} received`)}}e.IdNotMatchException=IdNotMatchException;class ResponseException extends Error{code=r.default.ResponseMessage}e.ResponseException=ResponseException;e.default={IdNotMatchException,ResponseException}},436115:(t,e,o)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.ResultFormatter=e.RPC=e.ParamsFormatter=e.DEFAULT_RPC_TIMEOUT=e.CKBRPC=void 0;var r=o(167837),i=o(686466),n=o(907823),a=function _interopRequireWildcard(t,e){if(!e&&t&&t.__esModule)return t;if(null===t||"object"!=typeof t&&"function"!=typeof t)return{default:t};var o=_getRequireWildcardCache(e);if(o&&o.has(t))return o.get(t);var r={__proto__:null},i=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var n in t)if("default"!==n&&{}.hasOwnProperty.call(t,n)){var a=i?Object.getOwnPropertyDescriptor(t,n):null;a&&(a.get||a.set)?Object.defineProperty(r,n,a):r[n]=t[n]}return r.default=t,o&&o.set(t,r),r}(o(593202)),s=o(409314),c=_interopRequireDefault(o(410288)),l=_interopRequireDefault(o(167083));function _interopRequireDefault(t){return t&&t.__esModule?t:{default:t}}function _getRequireWildcardCache(t){if("function"!=typeof WeakMap)return null;var e=new WeakMap,o=new WeakMap;return(_getRequireWildcardCache=function(t){return t?o:e})(t)}e.ParamsFormatter=n.formatter,e.ResultFormatter=a;const u=e.DEFAULT_RPC_TIMEOUT=3e4;class CKBRPC extends r.Base{#e;#o={url:""};get node(){return this.#o}#r=n.formatter;get paramsFormatter(){return this.#r}#i=a;get resultFormatter(){return this.#i}constructor(t,e={}){super(),this.setNode({url:t});const{timeout:o=u,fetch:r=c.default}=e;this.#e={timeout:o,fetch:r},Object.defineProperties(this,{addMethod:{value:this.addMethod,enumerable:!1,writable:!1,configurable:!1},setNode:{value:this.setNode,enumerable:!1,writable:!1,configurable:!1}}),Object.keys(this.rpcProperties).forEach((t=>{this.addMethod({name:t,...this.rpcProperties[t]},this.#e)}))}setNode(t){return Object.assign(this.node,t),this.node}addMethod=(t,e)=>{const o=new i.Method(this.node,t,e);Object.defineProperty(this,t.name,{value:o.call,enumerable:!0})};createBatchRequest=(t=[])=>{const e=this,o=new Proxy([],{set(...t){const o=Object.keys(e);if("length"!==t[1]){var r;const e=null==t||null===(r=t[2])||void 0===r?void 0:r[0];if(-1===o.indexOf(e))throw new s.MethodInBatchNotFoundException(e)}return Reflect.set(...t)}});return Object.defineProperties(o,{add:{value(...t){return this.push(t),this}},remove:{value(t){return this.splice(t,1),this}},exec:{async value(){const t=o.map((([t,...o],r)=>{try{return new i.Method(e.node,{...e.rpcProperties[t],name:t}).getPayload(...o)}catch(t){throw new s.PayloadInBatchException(r,t.message)}})),r=new l.default,n=r.signal,a=setTimeout((()=>r.abort()),e.#e.timeout),c=await e.#e.fetch(e.#o.url,{method:"POST",headers:{"content-type":"application/json"},body:JSON.stringify(t),signal:n}).then((t=>t.json()));return clearTimeout(a),c.map(((r,i)=>{var n,a,c;return r.id!==t[i].id?new s.IdNotMatchedInBatchException(i,t[i].id,r.id):null!==(n=null===(a=(c=e.rpcProperties[o[i][0]]).resultFormatters)||void 0===a?void 0:a.call(c,r.result))&&void 0!==n?n:r.result}))}}}),t.forEach((t=>o.push(t))),o}}e.RPC=e.CKBRPC=CKBRPC},686466:(t,e,o)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.Method=void 0;var r=o(409314),i=o(436115),n=_interopRequireDefault(o(167083)),a=_interopRequireDefault(o(410288));function _interopRequireDefault(t){return t&&t.__esModule?t:{default:t}}e.Method=class Method{#n;#e;get name(){return this.#n}#a={name:"",method:"",paramsFormatters:[],resultFormatters:void 0};#o;constructor(t,e,o={}){this.#o=t,this.#a=e,this.#n=e.name;const{timeout:r=i.DEFAULT_RPC_TIMEOUT,fetch:n=a.default}=o;this.#e={timeout:r,fetch:n},Object.defineProperty(this.call,"name",{value:e.name,configurable:!1,writable:!1})}call=async(...t)=>{const e=this.getPayload(...t),o=new n.default,i=o.signal,a=setTimeout((()=>o.abort()),this.#e.timeout),s=await this.#e.fetch(this.#o.url,{method:"POST",headers:{"content-type":"application/json"},body:JSON.stringify(e),signal:i}).then((t=>t.json())).then((t=>{var o,i,n;if(t.id!==e.id)throw new r.IdNotMatchException(e.id,t.id);if(t.error)throw new r.ResponseException(JSON.stringify(t.error));return null!==(o=null===(i=(n=this.#a).resultFormatters)||void 0===i?void 0:i.call(n,t.result))&&void 0!==o?o:t.result}));return clearTimeout(a),s};getPayload=(...t)=>{const e=t.map(((t,e)=>this.#a.paramsFormatters[e]&&this.#a.paramsFormatters[e](t)||t));return{id:Math.round(1e4*Math.random()),method:this.#a.method,params:e,jsonrpc:"2.0"}}}},907823:(t,e,o)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.formatter=void 0;var r=o(409314),i=o(739609);const n=e.formatter={toOptional:t=>e=>t&&null!=e?t(e):e,toArray:t=>e=>"function"==typeof t&&Array.isArray(e)?e.map(t):e,toHash:t=>{if("string"!=typeof t)throw new r.StringHashTypeException(t);return t.startsWith("0x")?t:`0x${t}`},toNumber:t=>{if("bigint"==typeof t)return`0x${t.toString(16)}`;if("string"!=typeof t)throw new r.BigintOrHexStringTypeException(t);if(!t.startsWith("0x"))throw new r.HexStringWithout0xException(t);return t},toScript:t=>{const{codeHash:e,hashType:o,...r}=t;return{code_hash:n.toHash(e),hash_type:o,...r}},toOutPoint:t=>{const{txHash:e,index:o,...r}=t;return{tx_hash:n.toHash(e),index:n.toNumber(o),...r}},toInput:t=>{if(!t)return t;const{previousOutput:e,since:o,...r}=t;return{previous_output:n.toOutPoint(e),since:n.toNumber(o),...r}},toOutput:t=>{if(!t)return t;const{capacity:e,lock:o,type:r,...i}=t;return{capacity:n.toNumber(e),lock:n.toScript(o),type:r?n.toScript(r):r,...i}},toDepType:t=>"depGroup"===t?"dep_group":t,toOrder:t=>t,toCellDep:t=>{if(!t)return t;const{outPoint:e,depType:o="code",...r}=t;return{out_point:n.toOutPoint(e),dep_type:n.toDepType(o),...r}},toRawTransaction:t=>{if(!t)return t;const{version:e,cellDeps:o=[],inputs:r=[],outputs:i=[],outputsData:a=[],headerDeps:s=[],...c}=t,l=r.map((t=>n.toInput(t))),u=i.map((t=>n.toOutput(t))),p=o.map((t=>n.toCellDep(t)));return{version:n.toNumber(e),cell_deps:p,inputs:l,outputs:u,outputs_data:a,header_deps:s,...c}},toPageNumber:(t="0x1")=>n.toNumber(t),toPageSize:(t="0x32")=>{const e=i.BI.from(t);if(i.BI.from(e).gt(50))throw new r.PageSizeTooLargeException(t,50);if(i.BI.from(e).lt(0))throw new r.PageSizeTooSmallException(t,0);return n.toNumber(`0x${e.toString(16)}`)},toReverseOrder:(t=!1)=>!!t,toOutputsValidator:t=>{if(!t)return;if(["default","passthrough"].indexOf(t)>-1)return t;throw new r.OutputsValidatorTypeException},toBoolean:t=>!!t,toTransactionProof:t=>{if(!t)return t;const{blockHash:e,witnessesRoot:o,...r}=t;return{block_hash:e,witnesses_root:o,...r}},toTransactionAndWitnessProof:t=>({block_hash:t.blockHash,witnesses_proof:t.witnessesProof,transactions_proof:t.transactionsProof}),toSearchFilter:t=>t?{script:t.script?n.toScript(t.script):t.script,output_data_len_range:t.outputDataLenRange,output_capacity_range:t.outputCapacityRange,block_range:t.blockRange,script_len_range:t.scriptLenRange}:t,toSearchKey:t=>t?{script:n.toScript(t.script),script_type:t.scriptType,filter:t.filter?n.toSearchFilter(t.filter):t.filter,script_search_mode:t.scriptSearchMode?t.scriptSearchMode:"prefix"}:t,toGetCellsSearchKey:t=>t?{...n.toSearchKey(t),with_data:t.withData}:t,toGetTransactionsSearchKey:t=>t?{...n.toSearchKey(t),group_by_transaction:t.groupByTransaction}:t}},593202:(t,e)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.toBannedAddresses=e.toBannedAddress=e.toArray=e.toAlertMessage=void 0,e.toBlock=function toBlock(t){if(!t)return t;if("string"==typeof t)return t;if("block"in t&&"cycles"in t)return{cycles:t.cycles,block:toBlock(t.block)};const{header:e,uncles:o=[],transactions:r=[],...i}=t;return{header:toHeader(e),uncles:o.map(toUncleBlock),transactions:r.map(toTransaction),...i}},e.toHash=e.toGetTransactionsResult=e.toGetCellsResult=e.toForkBlockResult=e.toFeeRateStatistics=e.toFeeRate=e.toEstimateCycles=e.toEpoch=e.toDeploymentsInfo=e.toDeploymentInfo=e.toDeployment=e.toDeployState=e.toDepType=e.toConsensus=e.toCellsIncludingOutPoint=e.toCellsCapacity=e.toCells=e.toCellbaseOutputCapacityDetails=e.toCellIncludingOutPoint=e.toCellDep=e.toCell=e.toCapacityByLockHash=e.toBlockchainInfo=e.toBlockFilter=e.toBlockEconomicState=void 0,e.toHeader=toHeader,e.toTip=e.toSyncState=e.toScript=e.toRemoteNodeInfo=e.toRawTxPool=e.toPeers=e.toOutput=e.toOutPoint=e.toNumber=e.toNullable=e.toLockHashIndexStates=e.toLockHashIndexState=e.toLocalNodeInfo=e.toLiveCellsByLockHash=e.toLiveCellWithStatus=e.toLiveCell=e.toInput=void 0,e.toTransaction=toTransaction,e.toUncleBlock=e.toTxPoolInfo=e.toTransactionsByLockHash=e.toTransactionWithStatus=e.toTransactionProof=e.toTransactionPoint=e.toTransactionAndWitnessProof=void 0;e.toArray=t=>e=>"function"==typeof t&&Array.isArray(e)?e.map(t):e;e.toNullable=t=>e=>t&&null!==e?t(e):e;e.toNumber=t=>t.toString();function toHeader(t){if("string"==typeof t)return t;if(!t)return t;const{compact_target:e,transactions_root:o,proposals_hash:r,extra_hash:i,parent_hash:n,...a}=t;return{compactTarget:e,parentHash:n,transactionsRoot:o,proposalsHash:r,extraHash:i,...a}}e.toHash=t=>t;const toScript=t=>{if(!t)return t;const{code_hash:e,hash_type:o,...r}=t;return{codeHash:e,hashType:o,...r}};e.toScript=toScript;const toInput=t=>{if(!t)return t;const{previous_output:e,...o}=t;return{previousOutput:e?toOutPoint(e):e,...o}};e.toInput=toInput;const toOutput=t=>{if(!t)return t;const{lock:e,type:o,...r}=t;return{lock:toScript(e),type:o?toScript(o):o,...r}};e.toOutput=toOutput;const toOutPoint=t=>{const{tx_hash:e,...o}=t;return{txHash:e,...o}};e.toOutPoint=toOutPoint;const toDepType=t=>"dep_group"===t?"depGroup":t;e.toDepType=toDepType;const toCellDep=t=>{if(!t)return t;const{out_point:e,dep_type:o="code",...r}=t;return{outPoint:toOutPoint(e),depType:toDepType(o),...r}};function toTransaction(t){if(!t||"object"!=typeof t)return t;const{cell_deps:e=[],inputs:o=[],outputs:r=[],outputs_data:i=[],header_deps:n=[],...a}=t;return{cellDeps:e.map(toCellDep),inputs:o.map(toInput),outputs:r.map(toOutput),outputsData:i,headerDeps:n,...a}}e.toCellDep=toCellDep;const toUncleBlock=t=>{if(!t)return t;const{header:e,...o}=t;return{header:toHeader(e),...o}};e.toUncleBlock=toUncleBlock;e.toTip=t=>({blockHash:t.block_hash,blockNumber:t.block_number});const toAlertMessage=t=>{if(!t)return t;const{notice_until:e,...o}=t;return{noticeUntil:e,...o}};e.toAlertMessage=toAlertMessage;e.toBlockchainInfo=t=>{if(!t)return t;const{is_initial_block_download:e,median_time:o,alerts:r,...i}=t;return{isInitialBlockDownload:e,medianTime:o,alerts:r.map(toAlertMessage),...i}};e.toLocalNodeInfo=t=>{if(!t)return t;const{node_id:e,protocols:o,...r}=t;return{nodeId:e,protocols:o.map((({id:t,name:e,support_versions:o})=>({id:t,name:e,supportVersions:o}))),...r}};const toRemoteNodeInfo=t=>{if(!t)return t;const{node_id:e,connected_duration:o,is_outbound:r,last_ping_duration:i,sync_state:n,...a}=t;return{nodeId:e,connectedDuration:o,isOutbound:r,lastPingDuration:i,syncState:{bestKnownHeaderHash:n.best_known_header_hash,bestKnownHeaderNumber:n.best_known_header_number,canFetchCount:n.can_fetch_count,inflightCount:n.inflight_count,lastCommonHeaderHash:n.last_common_header_hash,lastCommonHeaderNumber:n.last_common_header_number,unknownHeaderListSize:n.unknown_header_list_size},...a}};e.toRemoteNodeInfo=toRemoteNodeInfo;e.toTxPoolInfo=t=>{if(!t)return t;const{last_txs_updated_at:e,tip_hash:o,tip_number:r,total_tx_cycles:i,total_tx_size:n,min_fee_rate:a,min_rbf_rate:s,tx_size_limit:c,max_tx_pool_size:l,...u}=t;return{lastTxsUpdatedAt:e,tipHash:o,tipNumber:r,totalTxCycles:i,totalTxSize:n,minFeeRate:a,minRbfRate:s,txSizeLimit:c,maxTxPoolSize:l,...u}};e.toPeers=t=>Array.isArray(t)?t.map(toRemoteNodeInfo):[];const toCell=t=>{if(!t)return t;const{lock:e,type:o,...r}=t;return{lock:toScript(e),type:o?toScript(o):void 0,...r}};e.toCell=toCell;const toLiveCell=t=>{if(!t)return t;const{data:e,output:o,...r}=t;return{data:e,output:toOutput(o),...r}};e.toLiveCell=toLiveCell;e.toLiveCellWithStatus=t=>{if(!t)return t;const{cell:e,...o}=t;return{cell:toLiveCell(e),...o}};e.toCells=t=>Array.isArray(t)?t.map(toCell):[];const toCellIncludingOutPoint=t=>{if(!t)return t;const{lock:e,block_hash:o,out_point:r,output_data_len:i,...n}=t;return{blockHash:o,lock:toScript(e),outPoint:toOutPoint(r),outputDataLen:i,...n}};e.toCellIncludingOutPoint=toCellIncludingOutPoint;e.toCellsIncludingOutPoint=t=>Array.isArray(t)?t.map(toCellIncludingOutPoint):[];e.toTransactionWithStatus=t=>{if(!t)return t;const{transaction:e,tx_status:{block_hash:o,status:r},time_added_to_pool:i,min_replace_fee:n,fee:a,...s}=t;return{transaction:toTransaction(e),txStatus:{blockHash:o,status:r,..."reason"in t.tx_status?{reason:t.tx_status.reason}:{}},timeAddedToPool:i,minReplaceFee:n,fee:a,...s}};e.toEpoch=t=>{if(!t)return t;const{start_number:e,compact_target:o,...r}=t;return{compactTarget:o,startNumber:e,...r}};const toTransactionPoint=t=>{if(!t)return t;const{block_number:e,tx_hash:o,...r}=t;return{blockNumber:e,txHash:o,...r}};e.toTransactionPoint=toTransactionPoint;e.toTransactionsByLockHash=t=>t?t.map((t=>({consumedBy:t.consumed_by?toTransactionPoint(t.consumed_by):t.consumed_by,createdBy:toTransactionPoint(t.created_by)}))):t;e.toLiveCellsByLockHash=t=>t?t.map((t=>({cellOutput:toCell(t.cell_output),createdBy:toTransactionPoint(t.created_by),cellbase:t.cellbase,outputDataLen:t.output_data_len}))):t;const toLockHashIndexState=t=>{if(!t)return t;const{block_hash:e,block_number:o,lock_hash:r,...i}=t;return{blockHash:e,blockNumber:o,lockHash:r,...i}};e.toLockHashIndexState=toLockHashIndexState;e.toLockHashIndexStates=t=>t?t.map(toLockHashIndexState):t;const toBannedAddress=t=>{if(!t)return t;const{ban_reason:e,ban_until:o,created_at:r,...i}=t;return{banReason:e,banUntil:o,createdAt:r,...i}};e.toBannedAddress=toBannedAddress;e.toBannedAddresses=t=>t?t.map((t=>toBannedAddress(t))):t;e.toCellbaseOutputCapacityDetails=t=>{if(!t)return t;const{proposal_reward:e,tx_fee:o,...r}=t;return{proposalReward:e,txFee:o,...r}};e.toFeeRate=t=>{if(!t)return t;const{fee_rate:e,...o}=t;return{feeRate:e,...o}};e.toCapacityByLockHash=t=>{if(!t)return t;const{cells_count:e,block_number:o,capacity:r,...i}=t;return{blockNumber:o,capacity:r,cellsCount:e,...i}};e.toBlockEconomicState=t=>{if(!t)return t;const{finalized_at:e,miner_reward:o,txs_fee:r,...i}=t;return{finalizedAt:e,minerReward:o,txsFee:r,...i}};e.toSyncState=t=>t?{bestKnownBlockNumber:t.best_known_block_number,bestKnownBlockTimestamp:t.best_known_block_timestamp,fastTime:t.fast_time,ibd:t.ibd,inflightBlocksCount:t.inflight_blocks_count,lowTime:t.low_time,normalTime:t.normal_time,orphanBlocksCount:t.orphan_blocks_count}:t;e.toTransactionProof=t=>{if(!t)return t;const{block_hash:e,witnesses_root:o,...r}=t;return{blockHash:e,witnessesRoot:o,...r}};const toHardforkFeature=t=>({rfc:t.rfc,epochNumber:t.epoch_number}),toDeployment=t=>({bit:t.bit,start:t.start,timeout:t.timeout,minActivationEpoch:t.min_activation_epoch,period:t.period,threshold:t.threshold});e.toDeployment=toDeployment;const toSoftFork=t=>"rfc0043"in t?{status:t.status,rfc0043:toDeployment(t.rfc0043)}:t;e.toConsensus=t=>{if(!t)return t;const e=t.hardfork_features,o=t.softforks,r=o.light_client&&toSoftFork(o.light_client),i=o.testdummy&&toSoftFork(o.testdummy);return{blockVersion:t.block_version,cellbaseMaturity:t.cellbase_maturity,daoTypeHash:t.dao_type_hash,epochDurationTarget:t.epoch_duration_target,genesisHash:t.genesis_hash,id:t.id,initialPrimaryEpochReward:t.initial_primary_epoch_reward,maxBlockBytes:t.max_block_bytes,maxBlockCycles:t.max_block_cycles,maxBlockProposalsLimit:t.max_block_proposals_limit,maxUnclesNum:t.max_uncles_num,medianTimeBlockCount:t.median_time_block_count,orphanRateTarget:t.orphan_rate_target,permanentDifficultyInDummy:t.permanent_difficulty_in_dummy,primaryEpochRewardHalvingInterval:t.primary_epoch_reward_halving_interval,proposerRewardRatio:t.proposer_reward_ratio,secondaryEpochReward:t.secondary_epoch_reward,secp256k1Blake160MultisigAllTypeHash:t.secp256k1_blake160_multisig_all_type_hash,secp256k1Blake160SighashAllTypeHash:t.secp256k1_blake160_sighash_all_type_hash,txProposalWindow:t.tx_proposal_window,txVersion:t.tx_version,typeIdCodeHash:t.type_id_code_hash,hardforkFeatures:e.map(toHardforkFeature),softforks:{...r&&{lightClient:r},...i&&{testdummy:i}}}};e.toRawTxPool=t=>{if(!t)return t;if((t=>Array.isArray(t.pending))(t))return t;const toTxVerbosity=({ancestors_count:t,ancestors_cycles:e,ancestors_size:o,...r})=>({ancestorsCount:t,ancestorsCycles:e,ancestorsSize:o,...r}),e={},o={};return Object.keys(t.proposed).forEach((o=>{e[o]=toTxVerbosity(t.proposed[o])})),Object.keys(t.pending).forEach((e=>{o[e]=toTxVerbosity(t.pending[e])})),{proposed:e,pending:o}};e.toGetCellsResult=t=>({lastCursor:t.last_cursor,objects:t.objects.map((t=>{return(e=t)?{blockNumber:e.block_number,outPoint:toOutPoint(e.out_point),output:toOutput(e.output),outputData:e.output_data,txIndex:e.tx_index}:e;var e}))});e.toGetTransactionsResult=t=>t?{lastCursor:t.last_cursor,objects:t.objects.map((t=>{return(e=t)?e.cells?{txHash:e.tx_hash,txIndex:e.tx_index,blockNumber:e.block_number,cells:e.cells}:{txHash:e.tx_hash,blockNumber:e.block_number,ioIndex:e.io_index,ioType:e.io_type,txIndex:e.tx_index}:e;var e}))}:t;e.toCellsCapacity=t=>t?{capacity:t.capacity,blockHash:t.block_hash,blockNumber:t.block_number}:t;e.toBlockFilter=t=>({hash:t.hash,data:t.data});e.toTransactionAndWitnessProof=t=>({blockHash:t.block_hash,transactionsProof:t.transactions_proof,witnessesProof:t.witnesses_proof});e.toFeeRateStatistics=t=>({mean:t.mean,median:t.median});e.toForkBlockResult=t=>"string"==typeof t?t:{header:toHeader(t.header),uncles:t.uncles.map(toUncleBlock),transactions:t.transactions.map(toTransaction),proposals:t.proposals,extension:t.extension};e.toEstimateCycles=t=>({cycles:t.cycles});const toDeployState=t=>"locked_in"===t?"lockedIn":t;e.toDeployState=toDeployState;const toDeploymentInfo=t=>({bit:t.bit,start:t.start,timeout:t.timeout,minActivationEpoch:t.min_activation_epoch,period:t.period,threshold:t.threshold,since:t.since,state:toDeployState(t.state)});e.toDeploymentInfo=toDeploymentInfo;e.toDeploymentsInfo=t=>{const{light_client:e,testdummy:o}=t.deployments;return{hash:t.hash,epoch:t.epoch,deployments:{...e?{lightClient:toDeploymentInfo(e)}:{},...o?{testdummy:toDeploymentInfo(o)}:{}}}}},167083:t=>{"use strict";const{AbortController:e,AbortSignal:o}="undefined"!=typeof self?self:"undefined"!=typeof window?window:void 0;t.exports=e,t.exports.AbortSignal=o,t.exports.default=e}}]);