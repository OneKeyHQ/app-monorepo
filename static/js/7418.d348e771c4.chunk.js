"use strict";(self.webpackChunkweb=self.webpackChunkweb||[]).push([[7418],{207418:(e,n,t)=>{t.r(n),t.d(n,{code:()=>he,decode:()=>src_decode,encode:()=>src_encode,name:()=>le});const r=["string","number","bigint","symbol"],o=["Function","Generator","AsyncGenerator","GeneratorFunction","AsyncGeneratorFunction","AsyncFunction","Observable","Array","Buffer","Object","RegExp","Date","Error","Map","Set","WeakMap","WeakSet","ArrayBuffer","SharedArrayBuffer","DataView","Promise","URL","HTMLElement","Int8Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","BigInt64Array","BigUint64Array"];function is(e){if(null===e)return"null";if(void 0===e)return"undefined";if(!0===e||!1===e)return"boolean";const n=typeof e;if(r.includes(n))return n;if("function"===n)return"Function";if(Array.isArray(e))return"Array";if(function isBuffer(e){return e&&e.constructor&&e.constructor.isBuffer&&e.constructor.isBuffer.call(null,e)}(e))return"Buffer";const t=function getObjectType(e){const n=Object.prototype.toString.call(e).slice(8,-1);if(o.includes(n))return n;return}(e);return t||"Object"}class Type{constructor(e,n,t){this.major=e,this.majorEncoded=e<<5,this.name=n,this.terminal=t}toString(){return`Type[${this.major}].${this.name}`}compare(e){return this.major<e.major?-1:this.major>e.major?1:0}}Type.uint=new Type(0,"uint",!0),Type.negint=new Type(1,"negint",!0),Type.bytes=new Type(2,"bytes",!0),Type.string=new Type(3,"string",!0),Type.array=new Type(4,"array",!1),Type.map=new Type(5,"map",!1),Type.tag=new Type(6,"tag",!1),Type.float=new Type(7,"float",!0),Type.false=new Type(7,"false",!0),Type.true=new Type(7,"true",!0),Type.null=new Type(7,"null",!0),Type.undefined=new Type(7,"undefined",!0),Type.break=new Type(7,"break",!0);class Token{constructor(e,n,t){this.type=e,this.value=n,this.encodedLength=t,this.encodedBytes=void 0,this.byteValue=void 0}toString(){return`Token[${this.type}].${this.value}`}}const i=globalThis.process&&!globalThis.process.browser&&globalThis.Buffer&&"function"==typeof globalThis.Buffer.isBuffer,a=new TextDecoder,s=new TextEncoder;function byte_utils_isBuffer(e){return i&&globalThis.Buffer.isBuffer(e)}function asU8A(e){return e instanceof Uint8Array?byte_utils_isBuffer(e)?new Uint8Array(e.buffer,e.byteOffset,e.byteLength):e:Uint8Array.from(e)}const c=i?(e,n,t)=>t-n>64?globalThis.Buffer.from(e.subarray(n,t)).toString("utf8"):utf8Slice(e,n,t):(e,n,t)=>t-n>64?a.decode(e.subarray(n,t)):utf8Slice(e,n,t),u=i?e=>e.length>64?globalThis.Buffer.from(e):utf8ToBytes(e):e=>e.length>64?s.encode(e):utf8ToBytes(e),fromArray=e=>Uint8Array.from(e),d=i?(e,n,t)=>byte_utils_isBuffer(e)?new Uint8Array(e.subarray(n,t)):e.slice(n,t):(e,n,t)=>e.slice(n,t),f=i?(e,n)=>(e=e.map((e=>e instanceof Uint8Array?e:globalThis.Buffer.from(e))),asU8A(globalThis.Buffer.concat(e,n))):(e,n)=>{const t=new Uint8Array(n);let r=0;for(let n of e)r+n.length>t.length&&(n=n.subarray(0,t.length-r)),t.set(n,r),r+=n.length;return t},l=i?e=>globalThis.Buffer.allocUnsafe(e):e=>new Uint8Array(e);function utf8ToBytes(e){const n=[];let t=0;for(let r=0;r<e.length;r++){let o=e.charCodeAt(r);o<128?n[t++]=o:o<2048?(n[t++]=o>>6|192,n[t++]=63&o|128):55296==(64512&o)&&r+1<e.length&&56320==(64512&e.charCodeAt(r+1))?(o=65536+((1023&o)<<10)+(1023&e.charCodeAt(++r)),n[t++]=o>>18|240,n[t++]=o>>12&63|128,n[t++]=o>>6&63|128,n[t++]=63&o|128):(n[t++]=o>>12|224,n[t++]=o>>6&63|128,n[t++]=63&o|128)}return n}function utf8Slice(e,n,t){const r=[];for(;n<t;){const o=e[n];let i=null,a=o>239?4:o>223?3:o>191?2:1;if(n+a<=t){let t,r,s,c;switch(a){case 1:o<128&&(i=o);break;case 2:t=e[n+1],128==(192&t)&&(c=(31&o)<<6|63&t,c>127&&(i=c));break;case 3:t=e[n+1],r=e[n+2],128==(192&t)&&128==(192&r)&&(c=(15&o)<<12|(63&t)<<6|63&r,c>2047&&(c<55296||c>57343)&&(i=c));break;case 4:t=e[n+1],r=e[n+2],s=e[n+3],128==(192&t)&&128==(192&r)&&128==(192&s)&&(c=(15&o)<<18|(63&t)<<12|(63&r)<<6|63&s,c>65535&&c<1114112&&(i=c))}}null===i?(i=65533,a=1):i>65535&&(i-=65536,r.push(i>>>10&1023|55296),i=56320|1023&i),r.push(i),n+=a}return function decodeCodePointsArray(e){const n=e.length;if(n<=h)return String.fromCharCode.apply(String,e);let t="",r=0;for(;r<n;)t+=String.fromCharCode.apply(String,e.slice(r,r+=h));return t}(r)}const h=4096;class Bl{constructor(e=256){this.chunkSize=e,this.cursor=0,this.maxCursor=-1,this.chunks=[],this._initReuseChunk=null}reset(){this.cursor=0,this.maxCursor=-1,this.chunks.length&&(this.chunks=[]),null!==this._initReuseChunk&&(this.chunks.push(this._initReuseChunk),this.maxCursor=this._initReuseChunk.length-1)}push(e){let n=this.chunks[this.chunks.length-1];if(this.cursor+e.length<=this.maxCursor+1){const t=n.length-(this.maxCursor-this.cursor)-1;n.set(e,t)}else{if(n){const e=n.length-(this.maxCursor-this.cursor)-1;e<n.length&&(this.chunks[this.chunks.length-1]=n.subarray(0,e),this.maxCursor=this.cursor-1)}e.length<64&&e.length<this.chunkSize?(n=l(this.chunkSize),this.chunks.push(n),this.maxCursor+=n.length,null===this._initReuseChunk&&(this._initReuseChunk=n),n.set(e,0)):(this.chunks.push(e),this.maxCursor+=e.length)}this.cursor+=e.length}toBytes(e=!1){let n;if(1===this.chunks.length){const t=this.chunks[0];e&&this.cursor>t.length/2?(n=this.cursor===t.length?t:t.subarray(0,this.cursor),this._initReuseChunk=null,this.chunks=[]):n=d(t,0,this.cursor)}else n=f(this.chunks,this.cursor);return e&&this.reset(),n}}const p="CBOR decode error:",y="CBOR encode error:",g=[];function assertEnoughData(e,n,t){if(e.length-n<t)throw new Error(`${p} not enough data for type`)}g[23]=1,g[24]=2,g[25]=3,g[26]=5,g[27]=9;const w=[24,256,65536,4294967296,BigInt("18446744073709551616")];function readUint8(e,n,t){assertEnoughData(e,n,1);const r=e[n];if(!0===t.strict&&r<w[0])throw new Error(`${p} integer encoded in more bytes than necessary (strict decode)`);return r}function readUint16(e,n,t){assertEnoughData(e,n,2);const r=e[n]<<8|e[n+1];if(!0===t.strict&&r<w[1])throw new Error(`${p} integer encoded in more bytes than necessary (strict decode)`);return r}function readUint32(e,n,t){assertEnoughData(e,n,4);const r=16777216*e[n]+(e[n+1]<<16)+(e[n+2]<<8)+e[n+3];if(!0===t.strict&&r<w[2])throw new Error(`${p} integer encoded in more bytes than necessary (strict decode)`);return r}function readUint64(e,n,t){assertEnoughData(e,n,8);const r=16777216*e[n]+(e[n+1]<<16)+(e[n+2]<<8)+e[n+3],o=16777216*e[n+4]+(e[n+5]<<16)+(e[n+6]<<8)+e[n+7],i=(BigInt(r)<<BigInt(32))+BigInt(o);if(!0===t.strict&&i<w[3])throw new Error(`${p} integer encoded in more bytes than necessary (strict decode)`);if(i<=Number.MAX_SAFE_INTEGER)return Number(i);if(!0===t.allowBigInt)return i;throw new Error(`${p} integers outside of the safe integer range are not supported`)}function encodeUint(e,n){return encodeUintValue(e,0,n.value)}function encodeUintValue(e,n,t){if(t<w[0]){const r=Number(t);e.push([n|r])}else if(t<w[1]){const r=Number(t);e.push([24|n,r])}else if(t<w[2]){const r=Number(t);e.push([25|n,r>>>8,255&r])}else if(t<w[3]){const r=Number(t);e.push([26|n,r>>>24&255,r>>>16&255,r>>>8&255,255&r])}else{const r=BigInt(t);if(!(r<w[4]))throw new Error(`${p} encountered BigInt larger than allowable range`);{const t=[27|n,0,0,0,0,0,0,0];let o=Number(r&BigInt(4294967295)),i=Number(r>>BigInt(32)&BigInt(4294967295));t[8]=255&o,o>>=8,t[7]=255&o,o>>=8,t[6]=255&o,o>>=8,t[5]=255&o,t[4]=255&i,i>>=8,t[3]=255&i,i>>=8,t[2]=255&i,i>>=8,t[1]=255&i,e.push(t)}}}encodeUint.encodedSize=function encodedSize(e){return encodeUintValue.encodedSize(e.value)},encodeUintValue.encodedSize=function encodedSize(e){return e<w[0]?1:e<w[1]?2:e<w[2]?3:e<w[3]?5:9},encodeUint.compareTokens=function compareTokens(e,n){return e.value<n.value?-1:e.value>n.value?1:0};const T=BigInt(-1),b=BigInt(1);function encodeNegint(e,n){const t=n.value,r="bigint"==typeof t?t*T-b:-1*t-1;encodeUintValue(e,n.type.majorEncoded,r)}function toToken(e,n,t,r){assertEnoughData(e,n,t+r);const o=d(e,n+t,n+t+r);return new Token(Type.bytes,o,t+r)}function decodeBytesCompact(e,n,t,r){return toToken(e,n,1,t)}function tokenBytes(e){return void 0===e.encodedBytes&&(e.encodedBytes=e.type===Type.string?u(e.value):e.value),e.encodedBytes}function encodeBytes(e,n){const t=tokenBytes(n);encodeUintValue(e,n.type.majorEncoded,t.length),e.push(t)}function _3string_toToken(e,n,t,r,o){const i=t+r;assertEnoughData(e,n,i);const a=new Token(Type.string,c(e,n+t,n+i),i);return!0===o.retainStringBytes&&(a.byteValue=d(e,n+t,n+i)),a}function decodeStringCompact(e,n,t,r){return _3string_toToken(e,n,1,t,r)}encodeNegint.encodedSize=function encodedSize(e){const n=e.value,t="bigint"==typeof n?n*T-b:-1*n-1;return t<w[0]?1:t<w[1]?2:t<w[2]?3:t<w[3]?5:9},encodeNegint.compareTokens=function compareTokens(e,n){return e.value<n.value?1:e.value>n.value?-1:0},encodeBytes.encodedSize=function encodedSize(e){const n=tokenBytes(e);return encodeUintValue.encodedSize(n.length)+n.length},encodeBytes.compareTokens=function compareTokens(e,n){return function compareBytes(e,n){return e.length<n.length?-1:e.length>n.length?1:function compare(e,n){if(byte_utils_isBuffer(e)&&byte_utils_isBuffer(n))return e.compare(n);for(let t=0;t<e.length;t++)if(e[t]!==n[t])return e[t]<n[t]?-1:1;return 0}(e,n)}(tokenBytes(e),tokenBytes(n))};const m=encodeBytes;function _4array_toToken(e,n,t,r){return new Token(Type.array,r,t)}function decodeArrayCompact(e,n,t,r){return _4array_toToken(0,0,1,t)}function encodeArray(e,n){encodeUintValue(e,Type.array.majorEncoded,n.value)}function _5map_toToken(e,n,t,r){return new Token(Type.map,r,t)}function decodeMapCompact(e,n,t,r){return _5map_toToken(0,0,1,t)}function encodeMap(e,n){encodeUintValue(e,Type.map.majorEncoded,n.value)}function decodeTagCompact(e,n,t,r){return new Token(Type.tag,t,1)}function encodeTag(e,n){encodeUintValue(e,Type.tag.majorEncoded,n.value)}encodeArray.compareTokens=encodeUint.compareTokens,encodeArray.encodedSize=function encodedSize(e){return encodeUintValue.encodedSize(e.value)},encodeMap.compareTokens=encodeUint.compareTokens,encodeMap.encodedSize=function encodedSize(e){return encodeUintValue.encodedSize(e.value)},encodeTag.compareTokens=encodeUint.compareTokens,encodeTag.encodedSize=function encodedSize(e){return encodeUintValue.encodedSize(e.value)};const k=20,v=21,U=22,E=23;function createToken(e,n,t){if(t){if(!1===t.allowNaN&&Number.isNaN(e))throw new Error(`${p} NaN values are not supported`);if(!1===t.allowInfinity&&(e===1/0||e===-1/0))throw new Error(`${p} Infinity values are not supported`)}return new Token(Type.float,e,n)}function encodeFloat(e,n,t){const r=n.value;if(!1===r)e.push([Type.float.majorEncoded|k]);else if(!0===r)e.push([Type.float.majorEncoded|v]);else if(null===r)e.push([Type.float.majorEncoded|U]);else if(void 0===r)e.push([Type.float.majorEncoded|E]);else{let n,o=!1;t&&!0===t.float64||(encodeFloat16(r),n=readFloat16(B,1),r===n||Number.isNaN(r)?(B[0]=249,e.push(B.slice(0,3)),o=!0):(encodeFloat32(r),n=readFloat32(B,1),r===n&&(B[0]=250,e.push(B.slice(0,5)),o=!0))),o||(!function encodeFloat64(e){A.setFloat64(0,e,!1)}(r),n=readFloat64(B,1),B[0]=251,e.push(B.slice(0,9)))}}encodeFloat.encodedSize=function encodedSize(e,n){const t=e.value;if(!1===t||!0===t||null==t)return 1;if(!n||!0!==n.float64){encodeFloat16(t);let e=readFloat16(B,1);if(t===e||Number.isNaN(t))return 3;if(encodeFloat32(t),e=readFloat32(B,1),t===e)return 5}return 9};const C=new ArrayBuffer(9),A=new DataView(C,1),B=new Uint8Array(C,0);function encodeFloat16(e){if(e===1/0)A.setUint16(0,31744,!1);else if(e===-1/0)A.setUint16(0,64512,!1);else if(Number.isNaN(e))A.setUint16(0,32256,!1);else{A.setFloat32(0,e);const n=A.getUint32(0),t=(2139095040&n)>>23,r=8388607&n;if(255===t)A.setUint16(0,31744,!1);else if(0===t)A.setUint16(0,(2147483648&e)>>16|r>>13,!1);else{const e=t-127;e<-24?A.setUint16(0,0):e<-14?A.setUint16(0,(2147483648&n)>>16|1<<24+e,!1):A.setUint16(0,(2147483648&n)>>16|e+15<<10|r>>13,!1)}}}function readFloat16(e,n){if(e.length-n<2)throw new Error(`${p} not enough data for float16`);const t=(e[n]<<8)+e[n+1];if(31744===t)return 1/0;if(64512===t)return-1/0;if(32256===t)return NaN;const r=t>>10&31,o=1023&t;let i;return i=0===r?o*2**-24:31!==r?(o+1024)*2**(r-25):0===o?1/0:NaN,32768&t?-i:i}function encodeFloat32(e){A.setFloat32(0,e,!1)}function readFloat32(e,n){if(e.length-n<4)throw new Error(`${p} not enough data for float32`);const t=(e.byteOffset||0)+n;return new DataView(e.buffer,t,4).getFloat32(0,!1)}function readFloat64(e,n){if(e.length-n<8)throw new Error(`${p} not enough data for float64`);const t=(e.byteOffset||0)+n;return new DataView(e.buffer,t,8).getFloat64(0,!1)}function invalidMinor(e,n,t){throw new Error(`${p} encountered invalid minor (${t}) for major ${e[n]>>>5}`)}function errorer(e){return()=>{throw new Error(`${p} ${e}`)}}encodeFloat.compareTokens=encodeUint.compareTokens;const I=[];for(let e=0;e<=23;e++)I[e]=invalidMinor;I[24]=function decodeUint8(e,n,t,r){return new Token(Type.uint,readUint8(e,n+1,r),2)},I[25]=function decodeUint16(e,n,t,r){return new Token(Type.uint,readUint16(e,n+1,r),3)},I[26]=function decodeUint32(e,n,t,r){return new Token(Type.uint,readUint32(e,n+1,r),5)},I[27]=function decodeUint64(e,n,t,r){return new Token(Type.uint,readUint64(e,n+1,r),9)},I[28]=invalidMinor,I[29]=invalidMinor,I[30]=invalidMinor,I[31]=invalidMinor;for(let e=32;e<=55;e++)I[e]=invalidMinor;I[56]=function decodeNegint8(e,n,t,r){return new Token(Type.negint,-1-readUint8(e,n+1,r),2)},I[57]=function decodeNegint16(e,n,t,r){return new Token(Type.negint,-1-readUint16(e,n+1,r),3)},I[58]=function decodeNegint32(e,n,t,r){return new Token(Type.negint,-1-readUint32(e,n+1,r),5)},I[59]=function decodeNegint64(e,n,t,r){const o=readUint64(e,n+1,r);if("bigint"!=typeof o){const e=-1-o;if(e>=Number.MIN_SAFE_INTEGER)return new Token(Type.negint,e,9)}if(!0!==r.allowBigInt)throw new Error(`${p} integers outside of the safe integer range are not supported`);return new Token(Type.negint,T-BigInt(o),9)},I[60]=invalidMinor,I[61]=invalidMinor,I[62]=invalidMinor,I[63]=invalidMinor;for(let e=64;e<=87;e++)I[e]=decodeBytesCompact;I[88]=function decodeBytes8(e,n,t,r){return toToken(e,n,2,readUint8(e,n+1,r))},I[89]=function decodeBytes16(e,n,t,r){return toToken(e,n,3,readUint16(e,n+1,r))},I[90]=function decodeBytes32(e,n,t,r){return toToken(e,n,5,readUint32(e,n+1,r))},I[91]=function decodeBytes64(e,n,t,r){const o=readUint64(e,n+1,r);if("bigint"==typeof o)throw new Error(`${p} 64-bit integer bytes lengths not supported`);return toToken(e,n,9,o)},I[92]=invalidMinor,I[93]=invalidMinor,I[94]=invalidMinor,I[95]=errorer("indefinite length bytes/strings are not supported");for(let e=96;e<=119;e++)I[e]=decodeStringCompact;I[120]=function decodeString8(e,n,t,r){return _3string_toToken(e,n,2,readUint8(e,n+1,r),r)},I[121]=function decodeString16(e,n,t,r){return _3string_toToken(e,n,3,readUint16(e,n+1,r),r)},I[122]=function decodeString32(e,n,t,r){return _3string_toToken(e,n,5,readUint32(e,n+1,r),r)},I[123]=function decodeString64(e,n,t,r){const o=readUint64(e,n+1,r);if("bigint"==typeof o)throw new Error(`${p} 64-bit integer string lengths not supported`);return _3string_toToken(e,n,9,o,r)},I[124]=invalidMinor,I[125]=invalidMinor,I[126]=invalidMinor,I[127]=errorer("indefinite length bytes/strings are not supported");for(let e=128;e<=151;e++)I[e]=decodeArrayCompact;I[152]=function decodeArray8(e,n,t,r){return _4array_toToken(0,0,2,readUint8(e,n+1,r))},I[153]=function decodeArray16(e,n,t,r){return _4array_toToken(0,0,3,readUint16(e,n+1,r))},I[154]=function decodeArray32(e,n,t,r){return _4array_toToken(0,0,5,readUint32(e,n+1,r))},I[155]=function decodeArray64(e,n,t,r){const o=readUint64(e,n+1,r);if("bigint"==typeof o)throw new Error(`${p} 64-bit integer array lengths not supported`);return _4array_toToken(0,0,9,o)},I[156]=invalidMinor,I[157]=invalidMinor,I[158]=invalidMinor,I[159]=function decodeArrayIndefinite(e,n,t,r){if(!1===r.allowIndefinite)throw new Error(`${p} indefinite length items not allowed`);return _4array_toToken(0,0,1,1/0)};for(let e=160;e<=183;e++)I[e]=decodeMapCompact;I[184]=function decodeMap8(e,n,t,r){return _5map_toToken(0,0,2,readUint8(e,n+1,r))},I[185]=function decodeMap16(e,n,t,r){return _5map_toToken(0,0,3,readUint16(e,n+1,r))},I[186]=function decodeMap32(e,n,t,r){return _5map_toToken(0,0,5,readUint32(e,n+1,r))},I[187]=function decodeMap64(e,n,t,r){const o=readUint64(e,n+1,r);if("bigint"==typeof o)throw new Error(`${p} 64-bit integer map lengths not supported`);return _5map_toToken(0,0,9,o)},I[188]=invalidMinor,I[189]=invalidMinor,I[190]=invalidMinor,I[191]=function decodeMapIndefinite(e,n,t,r){if(!1===r.allowIndefinite)throw new Error(`${p} indefinite length items not allowed`);return _5map_toToken(0,0,1,1/0)};for(let e=192;e<=215;e++)I[e]=decodeTagCompact;I[216]=function decodeTag8(e,n,t,r){return new Token(Type.tag,readUint8(e,n+1,r),2)},I[217]=function decodeTag16(e,n,t,r){return new Token(Type.tag,readUint16(e,n+1,r),3)},I[218]=function decodeTag32(e,n,t,r){return new Token(Type.tag,readUint32(e,n+1,r),5)},I[219]=function decodeTag64(e,n,t,r){return new Token(Type.tag,readUint64(e,n+1,r),9)},I[220]=invalidMinor,I[221]=invalidMinor,I[222]=invalidMinor,I[223]=invalidMinor;for(let e=224;e<=243;e++)I[e]=errorer("simple values are not supported");I[244]=invalidMinor,I[245]=invalidMinor,I[246]=invalidMinor,I[247]=function decodeUndefined(e,n,t,r){if(!1===r.allowUndefined)throw new Error(`${p} undefined values are not supported`);return!0===r.coerceUndefinedToNull?new Token(Type.null,null,1):new Token(Type.undefined,void 0,1)},I[248]=errorer("simple values are not supported"),I[249]=function decodeFloat16(e,n,t,r){return createToken(readFloat16(e,n+1),3,r)},I[250]=function decodeFloat32(e,n,t,r){return createToken(readFloat32(e,n+1),5,r)},I[251]=function decodeFloat64(e,n,t,r){return createToken(readFloat64(e,n+1),9,r)},I[252]=invalidMinor,I[253]=invalidMinor,I[254]=invalidMinor,I[255]=function decodeBreak(e,n,t,r){if(!1===r.allowIndefinite)throw new Error(`${p} indefinite length items not allowed`);return new Token(Type.break,void 0,1)};const M=[];for(let e=0;e<24;e++)M[e]=new Token(Type.uint,e,1);for(let e=-1;e>=-24;e--)M[31-e]=new Token(Type.negint,e,1);M[64]=new Token(Type.bytes,new Uint8Array(0),1),M[96]=new Token(Type.string,"",1),M[128]=new Token(Type.array,0,1),M[160]=new Token(Type.map,0,1),M[244]=new Token(Type.false,!1,1),M[245]=new Token(Type.true,!0,1),M[246]=new Token(Type.null,null,1);const S={float64:!1,mapSorter:function mapSorter(e,n){const t=Array.isArray(e[0])?e[0][0]:e[0],r=Array.isArray(n[0])?n[0][0]:n[0];if(t.type!==r.type)return t.type.compare(r.type);const o=t.type.major,i=D[o].compareTokens(t,r);0===i&&console.warn("WARNING: complex key types used, CBOR key sorting guarantees are gone");return i},quickEncodeToken:function quickEncodeToken(e){switch(e.type){case Type.false:return fromArray([244]);case Type.true:return fromArray([245]);case Type.null:return fromArray([246]);case Type.bytes:return e.value.length?void 0:fromArray([64]);case Type.string:return""===e.value?fromArray([96]):void 0;case Type.array:return 0===e.value?fromArray([128]):void 0;case Type.map:return 0===e.value?fromArray([160]):void 0;case Type.uint:return e.value<24?fromArray([Number(e.value)]):void 0;case Type.negint:if(e.value>=-24)return fromArray([31-Number(e.value)])}}};const D=function makeCborEncoders(){const e=[];return e[Type.uint.major]=encodeUint,e[Type.negint.major]=encodeNegint,e[Type.bytes.major]=encodeBytes,e[Type.string.major]=m,e[Type.array.major]=encodeArray,e[Type.map.major]=encodeMap,e[Type.tag.major]=encodeTag,e[Type.float.major]=encodeFloat,e}(),x=new Bl;class Ref{constructor(e,n){this.obj=e,this.parent=n}includes(e){let n=this;do{if(n.obj===e)return!0}while(n=n.parent);return!1}static createCheck(e,n){if(e&&e.includes(n))throw new Error(`${y} object contains circular references`);return new Ref(n,e)}}const $={null:new Token(Type.null,null),undefined:new Token(Type.undefined,void 0),true:new Token(Type.true,!0),false:new Token(Type.false,!1),emptyArray:new Token(Type.array,0),emptyMap:new Token(Type.map,0)},N={number:(e,n,t,r)=>Number.isInteger(e)&&Number.isSafeInteger(e)?new Token(e>=0?Type.uint:Type.negint,e):new Token(Type.float,e),bigint:(e,n,t,r)=>e>=BigInt(0)?new Token(Type.uint,e):new Token(Type.negint,e),Uint8Array:(e,n,t,r)=>new Token(Type.bytes,e),string:(e,n,t,r)=>new Token(Type.string,e),boolean:(e,n,t,r)=>e?$.true:$.false,null:(e,n,t,r)=>$.null,undefined:(e,n,t,r)=>$.undefined,ArrayBuffer:(e,n,t,r)=>new Token(Type.bytes,new Uint8Array(e)),DataView:(e,n,t,r)=>new Token(Type.bytes,new Uint8Array(e.buffer,e.byteOffset,e.byteLength)),Array(e,n,t,r){if(!e.length)return!0===t.addBreakTokens?[$.emptyArray,new Token(Type.break)]:$.emptyArray;r=Ref.createCheck(r,e);const o=[];let i=0;for(const n of e)o[i++]=objectToTokens(n,t,r);return t.addBreakTokens?[new Token(Type.array,e.length),o,new Token(Type.break)]:[new Token(Type.array,e.length),o]},Object(e,n,t,r){const o="Object"!==n,i=o?e.keys():Object.keys(e),a=o?e.size:i.length;if(!a)return!0===t.addBreakTokens?[$.emptyMap,new Token(Type.break)]:$.emptyMap;r=Ref.createCheck(r,e);const s=[];let c=0;for(const n of i)s[c++]=[objectToTokens(n,t,r),objectToTokens(o?e.get(n):e[n],t,r)];return function sortMapEntries(e,n){n.mapSorter&&e.sort(n.mapSorter)}(s,t),t.addBreakTokens?[new Token(Type.map,a),s,new Token(Type.break)]:[new Token(Type.map,a),s]}};N.Map=N.Object,N.Buffer=N.Uint8Array;for(const e of"Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64".split(" "))N[`${e}Array`]=N.DataView;function objectToTokens(e,n={},t){const r=is(e),o=n&&n.typeEncoders&&n.typeEncoders[r]||N[r];if("function"==typeof o){const i=o(e,r,n,t);if(null!=i)return i}const i=N[r];if(!i)throw new Error(`${y} unsupported type: ${r}`);return i(e,r,n,t)}function tokensToEncoded(e,n,t,r){if(Array.isArray(n))for(const o of n)tokensToEncoded(e,o,t,r);else t[n.type.major](e,n,r)}function encodeCustom(e,n,t){const r=objectToTokens(e,t);if(!Array.isArray(r)&&t.quickEncodeToken){const e=t.quickEncodeToken(r);if(e)return e;const o=n[r.type.major];if(o.encodedSize){const e=o.encodedSize(r,t),n=new Bl(e);if(o(n,r,t),1!==n.chunks.length)throw new Error(`Unexpected error: pre-calculated length for ${r} was wrong`);return asU8A(n.chunks[0])}}return x.reset(),tokensToEncoded(x,r,n,t),x.toBytes(!0)}const _={strict:!1,allowIndefinite:!0,allowUndefined:!0,allowBigInt:!0};class Tokeniser{constructor(e,n={}){this._pos=0,this.data=e,this.options=n}pos(){return this._pos}done(){return this._pos>=this.data.length}next(){const e=this.data[this._pos];let n=M[e];if(void 0===n){const t=I[e];if(!t)throw new Error(`${p} no decoder for major type ${e>>>5} (byte 0x${e.toString(16).padStart(2,"0")})`);const r=31&e;n=t(this.data,this._pos,r,this.options)}return this._pos+=n.encodedLength,n}}const j=Symbol.for("DONE"),z=Symbol.for("BREAK");function tokensToObject(e,n){if(e.done())return j;const t=e.next();if(t.type===Type.break)return z;if(t.type.terminal)return t.value;if(t.type===Type.array)return function tokenToArray(e,n,t){const r=[];for(let o=0;o<e.value;o++){const i=tokensToObject(n,t);if(i===z){if(e.value===1/0)break;throw new Error(`${p} got unexpected break to lengthed array`)}if(i===j)throw new Error(`${p} found array but not enough entries (got ${o}, expected ${e.value})`);r[o]=i}return r}(t,e,n);if(t.type===Type.map)return function tokenToMap(e,n,t){const r=!0===t.useMaps,o=r?void 0:{},i=r?new Map:void 0;for(let a=0;a<e.value;a++){const s=tokensToObject(n,t);if(s===z){if(e.value===1/0)break;throw new Error(`${p} got unexpected break to lengthed map`)}if(s===j)throw new Error(`${p} found map but not enough entries (got ${a} [no key], expected ${e.value})`);if(!0!==r&&"string"!=typeof s)throw new Error(`${p} non-string keys not supported (got ${typeof s})`);if(!0===t.rejectDuplicateMapKeys&&(r&&i.has(s)||!r&&s in o))throw new Error(`${p} found repeat map key "${s}"`);const c=tokensToObject(n,t);if(c===j)throw new Error(`${p} found map but not enough entries (got ${a} [no value], expected ${e.value})`);r?i.set(s,c):o[s]=c}return r?i:o}(t,e,n);if(t.type===Type.tag){if(n.tags&&"function"==typeof n.tags[t.value]){const r=tokensToObject(e,n);return n.tags[t.value](r)}throw new Error(`${p} tag not supported (${t.value})`)}throw new Error("unsupported")}function decode(e,n){const[t,r]=function decodeFirst(e,n){if(!(e instanceof Uint8Array))throw new Error(`${p} data to decode must be a Uint8Array`);const t=(n=Object.assign({},_,n)).tokenizer||new Tokeniser(e,n),r=tokensToObject(t,n);if(r===j)throw new Error(`${p} did not find any content to decode`);if(r===z)throw new Error(`${p} got unexpected break`);return[r,e.subarray(t.pos())]}(e,n);if(r.length>0)throw new Error(`${p} too many terminals, data makes no sense`);return t}var F=function base(e,n){if(e.length>=255)throw new TypeError("Alphabet too long");for(var t=new Uint8Array(256),r=0;r<t.length;r++)t[r]=255;for(var o=0;o<e.length;o++){var i=e.charAt(o),a=i.charCodeAt(0);if(255!==t[a])throw new TypeError(i+" is ambiguous");t[a]=o}var s=e.length,c=e.charAt(0),u=Math.log(s)/Math.log(256),d=Math.log(256)/Math.log(s);function decodeUnsafe(e){if("string"!=typeof e)throw new TypeError("Expected String");if(0===e.length)return new Uint8Array;var n=0;if(" "!==e[n]){for(var r=0,o=0;e[n]===c;)r++,n++;for(var i=(e.length-n)*u+1>>>0,a=new Uint8Array(i);e[n];){var d=t[e.charCodeAt(n)];if(255===d)return;for(var f=0,l=i-1;(0!==d||f<o)&&-1!==l;l--,f++)d+=s*a[l]>>>0,a[l]=d%256>>>0,d=d/256>>>0;if(0!==d)throw new Error("Non-zero carry");o=f,n++}if(" "!==e[n]){for(var h=i-o;h!==i&&0===a[h];)h++;for(var p=new Uint8Array(r+(i-h)),y=r;h!==i;)p[y++]=a[h++];return p}}}return{encode:function encode(n){if(n instanceof Uint8Array||(ArrayBuffer.isView(n)?n=new Uint8Array(n.buffer,n.byteOffset,n.byteLength):Array.isArray(n)&&(n=Uint8Array.from(n))),!(n instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(0===n.length)return"";for(var t=0,r=0,o=0,i=n.length;o!==i&&0===n[o];)o++,t++;for(var a=(i-o)*d+1>>>0,u=new Uint8Array(a);o!==i;){for(var f=n[o],l=0,h=a-1;(0!==f||l<r)&&-1!==h;h--,l++)f+=256*u[h]>>>0,u[h]=f%s>>>0,f=f/s>>>0;if(0!==f)throw new Error("Non-zero carry");r=l,o++}for(var p=a-r;p!==a&&0===u[p];)p++;for(var y=c.repeat(t);p<a;++p)y+=e.charAt(u[p]);return y},decodeUnsafe,decode:function decode(e){var t=decodeUnsafe(e);if(t)return t;throw new Error(`Non-${n} character`)}}};const V=F,O=(new Uint8Array(0),e=>{if(e instanceof Uint8Array&&"Uint8Array"===e.constructor.name)return e;if(e instanceof ArrayBuffer)return new Uint8Array(e);if(ArrayBuffer.isView(e))return new Uint8Array(e.buffer,e.byteOffset,e.byteLength);throw new Error("Unknown type, must be binary type")});class Encoder{constructor(e,n,t){this.name=e,this.prefix=n,this.baseEncode=t}encode(e){if(e instanceof Uint8Array)return`${this.prefix}${this.baseEncode(e)}`;throw Error("Unknown type, must be binary type")}}class Decoder{constructor(e,n,t){if(this.name=e,this.prefix=n,void 0===n.codePointAt(0))throw new Error("Invalid prefix character");this.prefixCodePoint=n.codePointAt(0),this.baseDecode=t}decode(e){if("string"==typeof e){if(e.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(e.slice(this.prefix.length))}throw Error("Can only multibase decode strings")}or(e){return or(this,e)}}class ComposedDecoder{constructor(e){this.decoders=e}or(e){return or(this,e)}decode(e){const n=e[0],t=this.decoders[n];if(t)return t.decode(e);throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}}const or=(e,n)=>new ComposedDecoder({...e.decoders||{[e.prefix]:e},...n.decoders||{[n.prefix]:n}});class Codec{constructor(e,n,t,r){this.name=e,this.prefix=n,this.baseEncode=t,this.baseDecode=r,this.encoder=new Encoder(e,n,t),this.decoder=new Decoder(e,n,r)}encode(e){return this.encoder.encode(e)}decode(e){return this.decoder.decode(e)}}const from=({name:e,prefix:n,encode:t,decode:r})=>new Codec(e,n,t,r),baseX=({prefix:e,name:n,alphabet:t})=>{const{encode:r,decode:o}=V(t,n);return from({prefix:e,name:n,encode:r,decode:e=>O(o(e))})},rfc4648=({name:e,prefix:n,bitsPerChar:t,alphabet:r})=>from({prefix:n,name:e,encode:e=>((e,n,t)=>{const r="="===n[n.length-1],o=(1<<t)-1;let i="",a=0,s=0;for(let r=0;r<e.length;++r)for(s=s<<8|e[r],a+=8;a>t;)a-=t,i+=n[o&s>>a];if(a&&(i+=n[o&s<<t-a]),r)for(;i.length*t&7;)i+="=";return i})(e,r,t),decode:n=>((e,n,t,r)=>{const o={};for(let e=0;e<n.length;++e)o[n[e]]=e;let i=e.length;for(;"="===e[i-1];)--i;const a=new Uint8Array(i*t/8|0);let s=0,c=0,u=0;for(let n=0;n<i;++n){const i=o[e[n]];if(void 0===i)throw new SyntaxError(`Non-${r} character`);c=c<<t|i,s+=t,s>=8&&(s-=8,a[u++]=255&c>>s)}if(s>=t||255&c<<8-s)throw new SyntaxError("Unexpected end of data");return a})(n,r,t,e)}),R=rfc4648({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),L=(rfc4648({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),rfc4648({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),rfc4648({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),rfc4648({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),rfc4648({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),rfc4648({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),rfc4648({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),rfc4648({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5}),baseX({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}));baseX({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"});var P=function varint_encode(e,n,t){n=n||[];var r=t=t||0;for(;e>=J;)n[t++]=255&e|q,e/=128;for(;e&G;)n[t++]=255&e|q,e>>>=7;return n[t]=0|e,varint_encode.bytes=t-r+1,n},q=128,G=-128,J=Math.pow(2,31);var K=function read(e,n){var t,r=0,o=0,i=n=n||0,a=e.length;do{if(i>=a)throw read.bytes=0,new RangeError("Could not decode varint");t=e[i++],r+=o<28?(t&W)<<o:(t&W)*Math.pow(2,o),o+=7}while(t>=Q);return read.bytes=i-n,r},Q=128,W=127;var H=Math.pow(2,7),X=Math.pow(2,14),Z=Math.pow(2,21),Y=Math.pow(2,28),ee=Math.pow(2,35),ne=Math.pow(2,42),te=Math.pow(2,49),re=Math.pow(2,56),oe=Math.pow(2,63);const ie={encode:P,decode:K,encodingLength:function(e){return e<H?1:e<X?2:e<Z?3:e<Y?4:e<ee?5:e<ne?6:e<te?7:e<re?8:e<oe?9:10}},src_varint_decode=(e,n=0)=>[ie.decode(e,n),ie.decode.bytes],encodeTo=(e,n,t=0)=>(ie.encode(e,n,t),n),encodingLength=e=>ie.encodingLength(e);class Digest{constructor(e,n,t,r){this.code=e,this.size=n,this.digest=t,this.bytes=r}}const format=(e,n)=>{const{bytes:t,version:r}=e;return 0===r?toStringV0(t,baseCache(e),n||L.encoder):toStringV1(t,baseCache(e),n||R.encoder)},ae=new WeakMap,baseCache=e=>{const n=ae.get(e);if(null==n){const n=new Map;return ae.set(e,n),n}return n};class CID{constructor(e,n,t,r){this.code=n,this.version=e,this.multihash=t,this.bytes=r,this["/"]=r}get asCID(){return this}get byteOffset(){return this.bytes.byteOffset}get byteLength(){return this.bytes.byteLength}toV0(){switch(this.version){case 0:return this;case 1:{const{code:e,multihash:n}=this;if(e!==se)throw new Error("Cannot convert a non dag-pb CID to CIDv0");if(n.code!==ce)throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");return CID.createV0(n)}default:throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)}}toV1(){switch(this.version){case 0:{const{code:e,digest:n}=this.multihash,t=((e,n)=>{const t=n.byteLength,r=encodingLength(e),o=r+encodingLength(t),i=new Uint8Array(o+t);return encodeTo(e,i,0),encodeTo(t,i,r),i.set(n,o),new Digest(e,t,n,i)})(e,n);return CID.createV1(this.code,t)}case 1:return this;default:throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`)}}equals(e){return CID.equals(this,e)}static equals(e,n){const t=n;return t&&e.code===t.code&&e.version===t.version&&((e,n)=>{if(e===n)return!0;{const t=n;return e.code===t.code&&e.size===t.size&&t.bytes instanceof Uint8Array&&((e,n)=>{if(e===n)return!0;if(e.byteLength!==n.byteLength)return!1;for(let t=0;t<e.byteLength;t++)if(e[t]!==n[t])return!1;return!0})(e.bytes,t.bytes)}})(e.multihash,t.multihash)}toString(e){return format(this,e)}toJSON(){return{"/":format(this)}}link(){return this}get[Symbol.toStringTag](){return"CID"}[Symbol.for("nodejs.util.inspect.custom")](){return`CID(${this.toString()})`}static asCID(e){if(null==e)return null;const n=e;if(n instanceof CID)return n;if(null!=n["/"]&&n["/"]===n.bytes||n.asCID===n){const{version:e,code:t,multihash:r,bytes:o}=n;return new CID(e,t,r,o||encodeCID(e,t,r.bytes))}if(!0===n[ue]){const{version:e,multihash:t,code:r}=n,o=(e=>{const n=O(e),[t,r]=src_varint_decode(n),[o,i]=src_varint_decode(n.subarray(r)),a=n.subarray(r+i);if(a.byteLength!==o)throw new Error("Incorrect length");return new Digest(t,o,a,n)})(t);return CID.create(e,r,o)}return null}static create(e,n,t){if("number"!=typeof n)throw new Error("String codecs are no longer supported");if(!(t.bytes instanceof Uint8Array))throw new Error("Invalid digest");switch(e){case 0:if(n!==se)throw new Error(`Version 0 CID must use dag-pb (code: ${se}) block encoding`);return new CID(e,n,t,t.bytes);case 1:{const r=encodeCID(e,n,t.bytes);return new CID(e,n,t,r)}default:throw new Error("Invalid version")}}static createV0(e){return CID.create(0,se,e)}static createV1(e,n){return CID.create(1,e,n)}static decode(e){const[n,t]=CID.decodeFirst(e);if(t.length)throw new Error("Incorrect length");return n}static decodeFirst(e){const n=CID.inspectBytes(e),t=n.size-n.multihashSize,r=O(e.subarray(t,t+n.multihashSize));if(r.byteLength!==n.multihashSize)throw new Error("Incorrect length");const o=r.subarray(n.multihashSize-n.digestSize),i=new Digest(n.multihashCode,n.digestSize,o,r);return[0===n.version?CID.createV0(i):CID.createV1(n.codec,i),e.subarray(n.size)]}static inspectBytes(e){let n=0;const next=()=>{const[t,r]=src_varint_decode(e.subarray(n));return n+=r,t};let t=next(),r=se;if(18===t?(t=0,n=0):r=next(),0!==t&&1!==t)throw new RangeError(`Invalid CID version ${t}`);const o=n,i=next(),a=next(),s=n+a;return{version:t,codec:r,multihashCode:i,digestSize:a,multihashSize:s-o,size:s}}static parse(e,n){const[t,r]=parseCIDtoBytes(e,n),o=CID.decode(r);if(0===o.version&&"Q"!==e[0])throw Error("Version 0 CID string must not include multibase prefix");return baseCache(o).set(t,e),o}}const parseCIDtoBytes=(e,n)=>{switch(e[0]){case"Q":{const t=n||L;return[L.prefix,t.decode(`${L.prefix}${e}`)]}case L.prefix:{const t=n||L;return[L.prefix,t.decode(e)]}case R.prefix:{const t=n||R;return[R.prefix,t.decode(e)]}default:if(null==n)throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");return[e[0],n.decode(e)]}},toStringV0=(e,n,t)=>{const{prefix:r}=t;if(r!==L.prefix)throw Error(`Cannot string encode V0 in ${t.name} encoding`);const o=n.get(r);if(null==o){const o=t.encode(e).slice(1);return n.set(r,o),o}return o},toStringV1=(e,n,t)=>{const{prefix:r}=t,o=n.get(r);if(null==o){const o=t.encode(e);return n.set(r,o),o}return o},se=112,ce=18,encodeCID=(e,n,t)=>{const r=encodingLength(e),o=r+encodingLength(n),i=new Uint8Array(o+t.byteLength);return encodeTo(e,i,0),encodeTo(n,i,r),i.set(t,o),i},ue=Symbol.for("@ipld/js-cid/CID");const de={float64:!0,typeEncoders:{Object:function cidEncoder(e){if(e.asCID!==e&&e["/"]!==e.bytes)return null;const n=CID.asCID(e);if(!n)return null;const t=new Uint8Array(n.bytes.byteLength+1);return t.set(n.bytes,1),[new Token(Type.tag,42),new Token(Type.bytes,t)]},undefined:function undefinedEncoder(){throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded")},number:function numberEncoder(e){if(Number.isNaN(e))throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");if(e===1/0||e===-1/0)throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");return null}}};const fe={allowIndefinite:!1,coerceUndefinedToNull:!0,allowNaN:!1,allowInfinity:!1,allowBigInt:!0,strict:!0,useMaps:!1,rejectDuplicateMapKeys:!0,tags:[]};fe.tags[42]=function cidDecoder(e){if(0!==e[0])throw new Error("Invalid CID for CBOR tag 42; expected leading 0x00");return CID.decode(e.subarray(1))};const le="dag-cbor",he=113,src_encode=e=>function encode(e,n){return n=Object.assign({},S,n),encodeCustom(e,D,n)}(e,de),src_decode=e=>decode(e,fe)}}]);