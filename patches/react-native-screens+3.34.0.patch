diff --git a/node_modules/react-native-screens/android/src/main/java/com/swmansion/rnscreens/ScreenContainer.kt b/node_modules/react-native-screens/android/src/main/java/com/swmansion/rnscreens/ScreenContainer.kt
index cf44d7d..463dba7 100644
--- a/node_modules/react-native-screens/android/src/main/java/com/swmansion/rnscreens/ScreenContainer.kt
+++ b/node_modules/react-native-screens/android/src/main/java/com/swmansion/rnscreens/ScreenContainer.kt
@@ -2,6 +2,7 @@ package com.swmansion.rnscreens
 
 import android.content.Context
 import android.content.ContextWrapper
+import android.view.MotionEvent
 import android.view.View
 import android.view.ViewGroup
 import android.view.ViewParent
@@ -14,6 +15,7 @@ import com.facebook.react.ReactRootView
 import com.facebook.react.bridge.ReactContext
 import com.facebook.react.modules.core.ChoreographerCompat
 import com.facebook.react.modules.core.ReactChoreographer
+import com.facebook.react.views.view.ReactViewGroup
 import com.facebook.react.uimanager.ThemedReactContext
 import com.facebook.react.uimanager.UIManagerHelper
 import com.swmansion.rnscreens.Screen.ActivityState
@@ -42,6 +44,7 @@ open class ScreenContainer(
             }
         }
     private var parentScreenWrapper: ScreenFragmentWrapper? = null
+    private var shouldBreakJSUpdateCount = 0;
 
     override fun onLayout(
         changed: Boolean,
@@ -260,6 +263,55 @@ open class ScreenContainer(
         super.onAttachedToWindow()
         isAttached = true
         setupFragmentManager()
+        parentScreenWrapper.find { it.screen.activityState == ActivityState.ON_TOP }
+                ?: return
+        
+        val parentView = parent as? ViewGroup
+        if (parentView == null || parentView.childCount != 2) {
+           return
+       }
+
+       val tabBar = (parentView.getChildAt(1) as? ViewGroup)?.getChildAt(0) as? ViewGroup ?: return
+
+       for (index in 0 until tabBar.childCount) {
+           val tabBarItem = tabBar.getChildAt(index) as? ReactViewGroup ?: return
+
+           tabBarItem.setOnInterceptTouchEventListener { viewGroup, motionEvent ->
+               if (motionEvent.action != MotionEvent.ACTION_UP) {
+                   return@setOnInterceptTouchEventListener false
+               }
+               if (parentScreenWrapper[index].screen.activityState == ActivityState.ON_TOP) {
+                   return@setOnInterceptTouchEventListener false
+               }
+               parentScreenWrapper.forEach {
+                   it.screen.setActivityState(ActivityState.INACTIVE)
+               }
+               parentScreenWrapper[index].screen.setActivityState(ActivityState.ON_TOP)
+
+               for (itemIndex in 0 until tabBar.childCount) {
+                   var item = tabBar.getChildAt(itemIndex) as? ViewGroup
+                   if (item == null || item.childCount != 2) {
+                       item = (tabBar.getChildAt(itemIndex) as? ViewGroup)?.getChildAt(0) as? ViewGroup
+                       if (item == null || item.childCount != 2) {
+                           continue
+                       }
+                   }
+                   var aboveView = item.getChildAt(0) as? ReactViewGroup
+                   var belowView = item.getChildAt(1) as? ReactViewGroup
+                   if (((aboveView?.alpha ?: 0f) (belowView?.alpha ?: 0f)) != 1.0f) {
+                       continue
+                   }
+                   aboveView?.setOpacityIfPossible(if (itemIndex == index) 0f else 1f)
+                   belowView?.setOpacityIfPossible(if (itemIndex == index) 1f else 0f)
+               }
+               shouldBreakJSUpdateCount = 1;
+               createTransaction().let {
+                   topScreen?.fragment?.let { fragment -> detachScreen(it, fragment) }
+                   attachScreen(it, parentScreenWrapper[index].fragment)
+               }
+               true
+           }
+       }
     }
 
     /** Removes fragments from fragment manager that are attached to this container  */
diff --git a/node_modules/react-native-screens/common/cpp/react/renderer/components/rnscreens/RNSScreenComponentDescriptor.h b/node_modules/react-native-screens/common/cpp/react/renderer/components/rnscreens/RNSScreenComponentDescriptor.h
index 37aac4e..5fb5505 100644
--- a/node_modules/react-native-screens/common/cpp/react/renderer/components/rnscreens/RNSScreenComponentDescriptor.h
+++ b/node_modules/react-native-screens/common/cpp/react/renderer/components/rnscreens/RNSScreenComponentDescriptor.h
@@ -6,8 +6,8 @@
 #include <react/debug/react_native_assert.h>
 #include <react/renderer/components/rnscreens/Props.h>
 #include <react/renderer/core/ConcreteComponentDescriptor.h>
+#include <react/renderer/components/rnscreens/utils/RectUtil.h>
 #include "RNSScreenShadowNode.h"
-#include "utils/RectUtil.h"
 
 namespace facebook {
 namespace react {
diff --git a/node_modules/react-native-screens/ios/RNSFullWindowOverlay.mm b/node_modules/react-native-screens/ios/RNSFullWindowOverlay.mm
index ca1278a..856fcdc 100644
--- a/node_modules/react-native-screens/ios/RNSFullWindowOverlay.mm
+++ b/node_modules/react-native-screens/ios/RNSFullWindowOverlay.mm
@@ -33,6 +33,29 @@ - (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event
   return NO;
 }
 
+// Here is just copied from UIViewReact, but we have modified `self.reactSubviews` to `self.subviews`
+// because `RNSFullWindowOverlayContainer` is just a simple UIView without the `reactSubviews` property.
+- (NSArray<UIView *> *)reactZIndexSortedSubviews
+{
+  // Check if sorting is required - in most cases it won't be.
+  BOOL sortingRequired = NO;
+  for (UIView *subview in self.subviews) {
+    if (subview.reactZIndex != 0) {
+      sortingRequired = YES;
+      break;
+    }
+  }
+  return sortingRequired ? [self.subviews sortedArrayUsingComparator:^NSComparisonResult(UIView *a, UIView *b) {
+    if (a.reactZIndex > b.reactZIndex) {
+      return NSOrderedDescending;
+    } else {
+      // Ensure sorting is stable by treating equal zIndex as ascending so
+      // that original order is preserved.
+      return NSOrderedAscending;
+    }
+  }] : self.subviews;
+}
+
 - (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event
 {
   BOOL canReceiveTouchEvents = ([self isUserInteractionEnabled] && ![self isHidden]);
diff --git a/node_modules/react-native-screens/ios/RNSScreen.mm b/node_modules/react-native-screens/ios/RNSScreen.mm
index b673407..91d2c33 100644
--- a/node_modules/react-native-screens/ios/RNSScreen.mm
+++ b/node_modules/react-native-screens/ios/RNSScreen.mm
@@ -2,6 +2,7 @@
 
 #import "RNSScreen.h"
 #import "RNSScreenContainer.h"
+#import "RNSScreenNavigationContainer.h"
 #import "RNSScreenWindowTraits.h"
 
 #ifdef RCT_NEW_ARCH_ENABLED
@@ -456,8 +457,87 @@ - (BOOL)isMountedUnderScreenOrReactRoot
 #undef RNS_EXPECTED_VIEW
 }
 
+- (void)addGestureToTabBarItem {
+  UIView *superview = self.superview.superview.superview.superview.superview;
+  if (superview.subviews.count == 2) {
+    UIView *tabBarView = [[superview.subviews[1] subviews] firstObject];
+    for (UIView *view in tabBarView.subviews) {
+      for (UIGestureRecognizer *gestureRecognizer in view.gestureRecognizers) {
+        [view removeGestureRecognizer:gestureRecognizer];
+      }
+      UITapGestureRecognizer *tapGestureRecognizer = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(switchTabFromGesture:)];
+      [view addGestureRecognizer:tapGestureRecognizer];
+    }
+  }
+}
+
+- (void)switchTabFromGesture:(UITapGestureRecognizer *)gesture {
+  NSInteger index = [gesture.view.superview.subviews indexOfObject:gesture.view];
+  if (index == NSNotFound) {
+    return;
+  }
+
+  id _containerView = [gesture.view.superview.superview.superview.subviews firstObject];
+  if (![_containerView isKindOfClass:[RNSScreenNavigationContainerView class]]) {
+    return;
+  }
+  RNSScreenNavigationContainerView *containerView = (RNSScreenNavigationContainerView *)_containerView;
+
+  id _navigationController = containerView.subviews.firstObject.nextResponder;
+  if (![_navigationController isKindOfClass:[UINavigationController class]]) {
+    return;
+  }
+
+  UINavigationController *navigationController = (UINavigationController *)_navigationController;
+  id _subviews = navigationController.view.superview.reactSubviews;
+  if (![[_subviews firstObject] isKindOfClass:[RNSScreenView class]]) {
+    return;
+  }
+  NSArray<RNSScreenView *> *screenViews = (NSArray<RNSScreenView *> *)_subviews;
+
+  if (index < 0 || index >= screenViews.count) {
+    return;
+  }
+
+  if (screenViews[index].activityState == RNSActivityStateOnTop) {
+    return;
+  }
+
+
+  [screenViews enumerateObjectsUsingBlock:^(RNSScreenView *obj, NSUInteger idx, BOOL *stop) {
+    obj.activityState = (idx == index) ? RNSActivityStateOnTop : RNSActivityStateInactive;
+  }];
+  // containerView.shouldBreakJSUpdateCount = 1;
+  UIViewController *controller = screenViews[index].controller;
+  [navigationController setViewControllers:@[controller] animated:NO];
+
+  [gesture.view.superview.subviews enumerateObjectsUsingBlock:^(__kindof UIView *obj, NSUInteger idx, BOOL *stop) {
+    NSArray<UIView *> *opacityViewList = obj.subviews;
+    if ([opacityViewList count] != 2) {
+      opacityViewList = [opacityViewList firstObject].subviews;
+      if ([opacityViewList count] != 2) {
+      	return;
+      }
+    }
+    if ((opacityViewList[0].alpha + opacityViewList[1].alpha) != 1) {
+      return;
+    }
+    if (index == idx) {
+      opacityViewList[0].alpha = 0;
+      opacityViewList[1].alpha = 1;
+    } else {
+      opacityViewList[0].alpha = 1;
+      opacityViewList[1].alpha = 0;
+    }
+  }];
+}
+
+
 - (void)didMoveToWindow
 {
+  if (self.activityState == 2) {
+    [self addGestureToTabBarItem];
+  }
   // For RN touches to work we need to instantiate and connect RCTTouchHandler. This only applies
   // for screens that aren't mounted under RCTRootView e.g., modals that are mounted directly to
   // root application window.
diff --git a/node_modules/react-native-screens/ios/RNSScreenNavigationContainer.h b/node_modules/react-native-screens/ios/RNSScreenNavigationContainer.h
index defd0d5..72eb79d 100644
--- a/node_modules/react-native-screens/ios/RNSScreenNavigationContainer.h
+++ b/node_modules/react-native-screens/ios/RNSScreenNavigationContainer.h
@@ -8,6 +8,7 @@
 @end
 
 @interface RNSScreenNavigationContainerView : RNSScreenContainerView
+@property (nonatomic, assign) NSInteger shouldBreakJSUpdateCount;
 
 @end
 
diff --git a/node_modules/react-native-screens/ios/RNSScreenNavigationContainer.mm b/node_modules/react-native-screens/ios/RNSScreenNavigationContainer.mm
index f10671e..f1c2feb 100644
--- a/node_modules/react-native-screens/ios/RNSScreenNavigationContainer.mm
+++ b/node_modules/react-native-screens/ios/RNSScreenNavigationContainer.mm
@@ -29,7 +29,12 @@ - (void)updateContainer
     if (screen.activityState == RNSActivityStateOnTop) {
       // there should never be more than one screen with `RNSActivityStateOnTop`
       // since this component should be used for `tabs` and `drawer` navigators
-      [(RNSContainerNavigationController *)self.controller setViewControllers:@[ screen.controller ] animated:NO];
+      // [(RNSContainerNavigationController *)self.controller setViewControllers:@[ screen.controller ] animated:NO];
+      if (self.shouldBreakJSUpdateCount > 0) {
+        self.shouldBreakJSUpdateCount = 0;
+      } else {
+        [(RNSContainerNavigationController *)self.controller setViewControllers:@[ screen.controller ] animated:NO];
+      }
       [screen notifyFinishTransitioning];
     }
   }
diff --git a/node_modules/react-native-screens/ios/RNSScreenStack.mm b/node_modules/react-native-screens/ios/RNSScreenStack.mm
index ea27b03..7e9e417 100644
--- a/node_modules/react-native-screens/ios/RNSScreenStack.mm
+++ b/node_modules/react-native-screens/ios/RNSScreenStack.mm
@@ -741,6 +741,12 @@ - (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer
   // RNSPanGestureRecognizer will receive events iff topScreen.fullScreenSwipeEnabled == YES;
   // Events are filtered in gestureRecognizer:shouldReceivePressOrTouchEvent: method
   if ([gestureRecognizer isKindOfClass:[RNSPanGestureRecognizer class]]) {
+    // We cannot only simply filter this `fullScreenSwipe` gesture by `location + gestureResponseDistance`, so we also need to rely on `swipeDirection + translationInView`.
+    RNSPanGestureRecognizer *panGestureRecognizer = (RNSPanGestureRecognizer *)gestureRecognizer;
+    CGPoint translation = [panGestureRecognizer translationInView:panGestureRecognizer.view];
+    if (((abs(translation.x) - abs(translation.y)) * (topScreen.swipeDirection == RNSScreenSwipeDirectionHorizontal ? 1 : -1)) <= 0) {
+      return NO;
+    }
     if ([self isInGestureResponseDistance:gestureRecognizer topScreen:topScreen]) {
       _isFullWidthSwiping = YES;
       [self cancelTouchesInParent];
diff --git a/node_modules/react-native-screens/ios/RNSScreenStackAnimator.mm b/node_modules/react-native-screens/ios/RNSScreenStackAnimator.mm
index abb2cf6..9b060f8 100644
--- a/node_modules/react-native-screens/ios/RNSScreenStackAnimator.mm
+++ b/node_modules/react-native-screens/ios/RNSScreenStackAnimator.mm
@@ -128,22 +128,33 @@ - (void)animateSimplePushWithShadowEnabled:(BOOL)shadowEnabled
       shadowView.alpha = 0.0;
     }
 
-    [UIView animateWithDuration:[self transitionDuration:transitionContext]
-        animations:^{
-          fromViewController.view.transform = leftTransform;
-          toViewController.view.transform = CGAffineTransformIdentity;
-          if (shadowView) {
-            shadowView.alpha = RNSShadowViewMaxAlpha;
-          }
-        }
-        completion:^(BOOL finished) {
-          if (shadowView) {
-            [shadowView removeFromSuperview];
-          }
-          fromViewController.view.transform = CGAffineTransformIdentity;
-          toViewController.view.transform = CGAffineTransformIdentity;
-          [transitionContext completeTransition:![transitionContext transitionWasCancelled]];
-        }];
+    // [UIView animateWithDuration:[self transitionDuration:transitionContext]
+    //     animations:^{
+    //       fromViewController.view.transform = leftTransform;
+    //       toViewController.view.transform = CGAffineTransformIdentity;
+    //       if (shadowView) {
+    //         shadowView.alpha = RNSShadowViewMaxAlpha;
+    //       }
+    //     }
+    //     completion:^(BOOL finished) {
+    //       if (shadowView) {
+    //         [shadowView removeFromSuperview];
+    //       }
+    //       fromViewController.view.transform = CGAffineTransformIdentity;
+    //       toViewController.view.transform = CGAffineTransformIdentity;
+    //       [transitionContext completeTransition:![transitionContext transitionWasCancelled]];
+    //     }];
+    UIViewPropertyAnimator *modalAnimator = [[UIViewPropertyAnimator alloc] initWithDuration:[self transitionDuration:transitionContext] timingParameters:[[UISpringTimingParameters alloc] initWithMass:3 stiffness:1000 damping:500 initialVelocity:CGVectorMake(0, 0)]];
+    [modalAnimator addAnimations:^{
+      fromViewController.view.transform = CGAffineTransformIdentity;
+      toViewController.view.transform = CGAffineTransformIdentity;
+    }];
+    [modalAnimator addCompletion:^(UIViewAnimatingPosition finalPosition) {
+      fromViewController.view.transform = CGAffineTransformIdentity;
+      toViewController.view.transform = CGAffineTransformIdentity;
+      [transitionContext completeTransition:![transitionContext transitionWasCancelled]];
+    }];
+    [modalAnimator startAnimation];
   } else if (_operation == UINavigationControllerOperationPop) {
     toViewController.view.transform = leftTransform;
     [[transitionContext containerView] insertSubview:toViewController.view belowSubview:fromViewController.view];
diff --git a/node_modules/react-native-screens/ios/RNSScreenStackHeaderConfig.mm b/node_modules/react-native-screens/ios/RNSScreenStackHeaderConfig.mm
index de7f368..3f4c775 100644
--- a/node_modules/react-native-screens/ios/RNSScreenStackHeaderConfig.mm
+++ b/node_modules/react-native-screens/ios/RNSScreenStackHeaderConfig.mm
@@ -147,7 +147,8 @@ - (void)updateViewControllerIfNeeded
   BOOL isInFullScreenModal = nav == nil && _screenView.stackPresentation == RNSScreenStackPresentationFullScreenModal;
   // if nav is nil, it means we can be in a fullScreen modal, so there is no nextVC, but we still want to update
   if (vc != nil && (nextVC == vc || isInFullScreenModal || isPresentingVC)) {
-    [RNSScreenStackHeaderConfig updateViewController:self.screenView.controller withConfig:self animated:YES];
+    // [RNSScreenStackHeaderConfig updateViewController:self.screenView.controller withConfig:self animated:YES];
+    [RNSScreenStackHeaderConfig updateViewController:self.screenView.controller withConfig:self animated:NO];
     // As the header might have change in `updateViewController` we need to ensure that header height
     // returned by the `onHeaderHeightChange` event is correct.
     [self.screenView.controller calculateAndNotifyHeaderHeightChangeIsModal:NO];
@@ -482,7 +483,22 @@ + (void)updateViewController:(UIViewController *)vc
   if (!shouldHide && !config.translucent) {
     // when nav bar is not translucent we chage edgesForExtendedLayout to avoid system laying out
     // the screen underneath navigation controllers
-    vc.edgesForExtendedLayout = UIRectEdgeNone;
+    // vc.edgesForExtendedLayout = UIRectEdgeNone;
+    // When using hideWhenScrolling, we cannot set UIRectEdgeNone as it leads to significant gesture lag and conflicts
+    __block BOOL shouldResetExtendedLayout = true;
+    [config.reactSubviews enumerateObjectsUsingBlock:^(UIView * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
+      UIView *view = [obj.subviews firstObject];
+      if (![view isKindOfClass:[RNSSearchBar class]]) {
+        return;
+      }
+      RNSSearchBar *searchBar = (RNSSearchBar *)view;
+      if (searchBar.hideWhenScrolling) {
+        shouldResetExtendedLayout = false;
+      }
+    }];
+    if (shouldResetExtendedLayout) {
+      vc.edgesForExtendedLayout = UIRectEdgeNone;
+    }
   } else {
     // system default is UIRectEdgeAll
     vc.edgesForExtendedLayout = UIRectEdgeAll;
@@ -808,7 +824,7 @@ static RCTResizeMode resizeModeFromCppEquiv(react::ImageResizeMode resizeMode)
 }
 
 /**
- * Fabric implementation of helper method for +loadBackButtonImageInViewController:withConfig:
+ * Fabric implementation of helper method for loadBackButtonImageInViewController:withConfig:
  * There is corresponding Paper implementation (with different parameter type) in Paper specific section.
  */
 + (RCTImageSource *)imageSourceFromImageView:(RCTImageComponentView *)view
@@ -932,7 +948,7 @@ - (void)didSetProps:(NSArray<NSString *> *)changedProps
 }
 
 /**
- * Paper implementation of helper method for +loadBackButtonImageInViewController:withConfig:
+ * Paper implementation of helper method for loadBackButtonImageInViewController:withConfig:
  * There is corresponding Fabric implementation (with different parameter type) in Fabric specific section.
  */
 + (RCTImageSource *)imageSourceFromImageView:(RCTImageView *)view
diff --git a/node_modules/react-native-screens/ios/UIWindow+RNScreens.mm b/node_modules/react-native-screens/ios/UIWindow+RNScreens.mm
index e295dcc..e473645 100644
--- a/node_modules/react-native-screens/ios/UIWindow+RNScreens.mm
+++ b/node_modules/react-native-screens/ios/UIWindow+RNScreens.mm
@@ -1,11 +1,22 @@
 #import "RNSFullWindowOverlay.h"
 #import "UIWindow+RNScreens.h"
+#import <React/RCTUtils.h>
 
 @implementation UIWindow (RNScreens)
 
 - (void)didAddSubview:(UIView *)subview
 {
   if (![subview isKindOfClass:[RNSFullWindowOverlayContainer class]]) {
+    // We only bring `RNSFullWindowOverlayContainer` above the `UIModal`; we don't handle other things like `SPAlert`
+    NSString *subviewClassString = NSStringFromClass([subview class]);
+    if (![subviewClassString hasPrefix:@"UI"] && ![subviewClassString hasPrefix:@"_UI"]) {
+      return;
+    }
+
+    if ([RCTPresentedViewController() isKindOfClass:[UIAlertController class]]) {
+      return;
+    }
+
     for (UIView *view in self.subviews) {
       if ([view isKindOfClass:[RNSFullWindowOverlayContainer class]]) {
         [self bringSubviewToFront:view];
diff --git a/node_modules/react-native-screens/lib/module/components/Screen.web.js b/node_modules/react-native-screens/lib/module/components/Screen.web.js
index 04a3491..947c23c 100644
--- a/node_modules/react-native-screens/lib/module/components/Screen.web.js
+++ b/node_modules/react-native-screens/lib/module/components/Screen.web.js
@@ -7,6 +7,8 @@ export const InnerScreen = View;
 // We're using class component here because of the error from reanimated:
 // createAnimatedComponent` does not support stateless functional components; use a class component instead.
 export class NativeScreen extends React.Component {
+  // Just to help determine whether `View.setNativeProps`` can be called in `react-native-web.createAnimatedComponent`
+  setNativeProps() {}
   render() {
     let {
       active,
diff --git a/node_modules/react-native-screens/src/components/Screen.web.tsx b/node_modules/react-native-screens/src/components/Screen.web.tsx
index c624a49..9084542 100644
--- a/node_modules/react-native-screens/src/components/Screen.web.tsx
+++ b/node_modules/react-native-screens/src/components/Screen.web.tsx
@@ -9,6 +9,8 @@ export const InnerScreen = View;
 // We're using class component here because of the error from reanimated:
 // createAnimatedComponent` does not support stateless functional components; use a class component instead.
 export class NativeScreen extends React.Component<ScreenProps> {
+  // Just to help determine whether `View.setNativeProps`` can be called in `react-native-web.createAnimatedComponent`
+  setNativeProps() {}
   render(): JSX.Element {
     let {
       active,
